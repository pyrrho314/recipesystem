

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>AstroData – References &mdash; ADConfig 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="ADConfig 0.1 documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">ADConfig 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-AstroData">
<span id="astrodata-references"></span><h1><tt class="docutils literal"><span class="pre">AstroData</span></tt> &#8211; References<a class="headerlink" href="#module-AstroData" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="AstroData.AstroData">
<em class="property">class </em><tt class="descclassname">AstroData.</tt><tt class="descname">AstroData</tt><big>(</big><em>dataset=None</em>, <em>mode='readonly'</em>, <em>phu=None</em>, <em>header=None</em>, <em>data=None</em>, <em>store=None</em>, <em>storeClobber=False</em>, <em>exts=None</em>, <em>extInsts=None</em><big>)</big><a class="headerlink" href="#AstroData.AstroData" title="Permalink to this definition">¶</a></dt>
<dd><p>The AstroData class abstracts datasets stored in MEF files
and provides uniform interfaces for working on datasets from different
instruments and modes.  Configuration packages are used to describe
the specific data characteristics, layout, and to store type-specific
implementations.</p>
<p>MEFs can be generalized as lists of header-data units (HDU), with key-value 
pairs populating headers, and pixel values populating the data array.
AstroData interprets a MEF as a single complex entity.  The individual
&#8220;extensions&#8221; within the MEF are available using Python list (&#8220;[]&#8221;) syntax; 
they are wrapped in AstroData objects (see 
<tt class="xref py py-meth docutils literal"><span class="pre">AstroData.__getitem__()</span></tt>). 
AstroData uses <tt class="docutils literal"><span class="pre">pyfits</span></tt> for MEF I/O and <tt class="docutils literal"><span class="pre">numpy</span></tt> for pixel manipulations.</p>
<p>While the <tt class="docutils literal"><span class="pre">pyfits</span></tt> and <tt class="docutils literal"><span class="pre">numpy</span></tt> objects are available to the programmer, 
<tt class="docutils literal"><span class="pre">AstroData</span></tt> provides analogous methods for most <tt class="docutils literal"><span class="pre">pyfits</span></tt> functionalities 
which allows it to maintain the dataset  as a cohesive whole. The programmer 
does however use the <tt class="docutils literal"><span class="pre">numpy.ndarrays</span></tt> directly for pixel manipulation.
Simple AstroData arithmetic is also provided by the <tt class="docutils literal"><span class="pre">astrodata.adutils.arith</span></tt> 
module which implement AstroData methods for addition, subtraction, multiplication 
and division.</p>
<p>In order to identify types of dataset and provide type-specific behavior,
<tt class="docutils literal"><span class="pre">AstroData</span></tt> relies on configuration packages either in the <tt class="docutils literal"><span class="pre">PYTHONPATH</span></tt> environment
variable or the <tt class="docutils literal"><span class="pre">Astrodata</span></tt> package environment variables, <tt class="docutils literal"><span class="pre">ADCONFIGPATH</span></tt> and
<tt class="docutils literal"><span class="pre">RECIPEPATH</span></tt>. A configuration package (eg. <tt class="docutils literal"><span class="pre">astrodata_Gemini</span></tt>) contains definitions for
all instruments and modes. A configuration package contains type
definitions, meta-data functions, information lookup tables, and any other code
or information needed to handle specific types of dataset.</p>
<p>This allows <tt class="docutils literal"><span class="pre">AstroData</span></tt> to manage access to the dataset for convenience and
consistency. For example, <tt class="docutils literal"><span class="pre">AstroData</span></tt> is able:</p>
<ul class="simple">
<li>to allow reduction scripts to have easy access to dataset classification 
information in a consistent way across all instruments and modes;</li>
<li>to provide consistent interfaces for obtaining common meta-data across all
instruments and modes;</li>
<li>to relate internal extensions, e.g. discriminate between science and 
variance arrays and associate them properly;</li>
<li>to help propagate header-data units important to the given instrument mode,
but unknown to general purpose transformations.</li>
</ul>
<p>In general, the purpose of <tt class="docutils literal"><span class="pre">AstroData</span></tt> is to provide smart dataset-oriented interfaces
that adapt to dataset type. The primary interfaces are for file
handling, dataset-type checking, and managing meta-data, but <tt class="docutils literal"><span class="pre">AstroData</span></tt> also
integrates other functionalities.</p>
<dl class="method">
<dt id="AstroData.AstroData.add">
<tt class="descname">add</tt><big>(</big><em>input_b</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.add" title="Permalink to this definition">¶</a></dt>
<dd><p>The add function uses numpy.add to add input_b to an AstroData object
(input_a), where input_b could be either another AstroData object, a
dictionary, list, float or integer, or a DescriptorValue (DV) object.</p>
<p>If input_b is an AstroData object, the add function will add each science
extension in the input AstroData object (input_a) with the corresponding
science extension in input_b and update the variance and data quality
extensions accordingly.</p>
<p>If input_b is a dictionary, float, integer or a DescriptorValue object, the
corresponding single value is added to each science extension in the input
AstroData object (input_a).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>input_a</strong> (<a class="reference internal" href="#module-AstroData" title="AstroData"><em>AstroData</em></a>) &#8211; input AstroData object to be operated on by input_b</li>
<li><strong>input_b</strong> (<em>AstroData, dictionary, list, float, integer, DescriptorValue</em>) &#8211; input value to operate on the input AstroData object
(input_a). This value can be an AstroData object, a
dictionary, where the key is either the (EXTNAME, EXTVER)
tuple or an EXTVER integer for each science extension and
the value is a float or integer, a list of floats or
integers, where the values in the list correspond to the
science extensions in numerical order, a single float or
integer, or a DescriptorValue object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.append">
<tt class="descname">append</tt><big>(</big><em>moredata=None</em>, <em>data=None</em>, <em>header=None</em>, <em>auto_number=False</em>, <em>do_deepcopy=False</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.append" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>moredata</strong> (<em>pyfits.HDU, pyfits.HDUList, or AstroData</em>) &#8211; either an AstroData instance, an HDUList instance, 
or an HDU instance to add to this AstroData object.
When present, data and header arguments will be ignored.</li>
<li><strong>data</strong> (<em>numpy.ndarray</em>) &#8211; <tt class="docutils literal"><span class="pre">data</span></tt> and <tt class="docutils literal"><span class="pre">header</span></tt> are used to construct a new HDU which is then 
added to the <tt class="docutils literal"><span class="pre">HDUList</span></tt> associated to the <tt class="docutils literal"><span class="pre">AstroData</span></tt> instance. The <tt class="docutils literal"><span class="pre">data</span></tt> 
argument should be set
to a valid <tt class="docutils literal"><span class="pre">numpy</span></tt> array. If <tt class="docutils literal"><span class="pre">modedata</span></tt> is not specified, <tt class="docutils literal"><span class="pre">data</span></tt> and <tt class="docutils literal"><span class="pre">header</span></tt>
must both be set.</li>
<li><strong>header</strong> (<em>pyfits.Header</em>) &#8211; <tt class="docutils literal"><span class="pre">data</span></tt> and <tt class="docutils literal"><span class="pre">header</span></tt> are used
to construct a new HDU which is then added to the <tt class="docutils literal"><span class="pre">HDUList</span></tt> associated to 
<tt class="docutils literal"><span class="pre">AstroData</span></tt> instance. The <tt class="docutils literal"><span class="pre">header</span></tt> argument should be set to a
valid <tt class="docutils literal"><span class="pre">pyfits.Header</span></tt> object. If <tt class="docutils literal"><span class="pre">moredata</span></tt> is not specified, <tt class="docutils literal"><span class="pre">data</span></tt> and
<tt class="docutils literal"><span class="pre">header</span></tt> must both be set.</li>
<li><strong>auto_number</strong> (<em>boolean</em>) &#8211; auto-increment the extension version, <tt class="docutils literal"><span class="pre">EXTVER</span></tt>, to fit file convention</li>
<li><strong>extname</strong> (<em>string</em>) &#8211; extension name as set in keyword <tt class="docutils literal"><span class="pre">EXTNAME</span></tt> (eg. &#8216;SCI&#8217;, &#8216;VAR&#8217;, &#8216;DQ&#8217;)
This is used only when <tt class="docutils literal"><span class="pre">header</span></tt> and <tt class="docutils literal"><span class="pre">data</span></tt> are used and <tt class="docutils literal"><span class="pre">moredata</span></tt> is
empty.</li>
<li><strong>extver</strong> (<em>int</em>) &#8211; extension version as set in keyword <tt class="docutils literal"><span class="pre">EXTVER</span></tt>.
This is used only when <tt class="docutils literal"><span class="pre">header</span></tt> and <tt class="docutils literal"><span class="pre">data</span></tt> are used and <tt class="docutils literal"><span class="pre">moredata</span></tt> is
empty.</li>
<li><strong>do_deepcopy</strong> (<em>boolean</em>) &#8211; deepcopy the input before appending.  Might be useful
when auto_number is True and the input comes from another AD object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This function appends header-data units (HDUs) to the AstroData
instance.</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#AstroData.AstroData.close" title="Permalink to this definition">¶</a></dt>
<dd><p>The close(..) function will close the <tt class="docutils literal"><span class="pre">HDUList</span></tt> associated with this
<tt class="docutils literal"><span class="pre">AstroData</span></tt> instance.</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.count_exts">
<tt class="descname">count_exts</tt><big>(</big><em>extname=None</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.count_exts" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>extname</strong> (<em>string</em>) &#8211; the name of the extension, equivalent to the
value associated with the &#8220;EXTNAME&#8221; key in the extension 
header.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">number of extensions of that name</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
<p>The count_exts(..) function counts the extensions of a given name
(as stored in the HDUs &#8220;EXTNAME&#8221; header).</p>
</dd></dl>

<dl class="attribute">
<dt id="AstroData.AstroData.data">
<tt class="descname">data</tt><a class="headerlink" href="#AstroData.AstroData.data" title="Permalink to this definition">¶</a></dt>
<dd><p>The data property can only be used for single-HDU AstroData
instances, such as those returned during iteration. It is a property
attribute which uses <em>get_data(..)</em> and <em>set_data(..)</em> to access the
data members with &#8220;=&#8221; syntax. To set the data member, use <em>ad.data =
newdata</em>, where <em>newdata</em> must be a numpy array. To get the data
member, use <em>npdata = ad.data</em>.</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.discover_status">
<tt class="descname">discover_status</tt><big>(</big><big>)</big><a class="headerlink" href="#AstroData.AstroData.discover_status" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns the set of processing types applicable to 
this dataset.
:returns: a list of classification name strings
:rtype: list of strings</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.discover_types">
<tt class="descname">discover_types</tt><big>(</big><em>all=False</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.discover_types" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>all</strong> &#8211; a flag which  controls how the classes are returned... if
True, then the function will return a dictionary of three lists,
&#8216;all&#8217;, &#8216;status&#8217;, and &#8216;typology&#8217;.  If False, the return value is a
list which is in fact the &#8216;all&#8217; list, containing all the status and
typology related types together.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a list of DataClassification objects, or a dictionary of lists
if the C{all} flag is set.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list | dict</td>
</tr>
</tbody>
</table>
<p>This function provides a list of classifications of both processing
status and typology which apply to the data encapsulated by this
instance,  identified by their string names.</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.discover_typology">
<tt class="descname">discover_typology</tt><big>(</big><big>)</big><a class="headerlink" href="#AstroData.AstroData.discover_typology" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns a list of classification names
for typology related classifications, as apply to this
dataset.
:return: DataClassification objects in a list
:rtype: list</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.div">
<tt class="descname">div</tt><big>(</big><em>denominator</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.div" title="Permalink to this definition">¶</a></dt>
<dd><p>The div function uses numpy.divide to divide an AstroData object (input_a)
by input_b, where input_b could be either another AstroData object, a
dictionary, list, float or integer, or a DescriptorValue (DV) object.</p>
<p>If input_b is an AstroData object, the div function will divide each
science extension in the input AstroData object (input_a) with the
corresponding science extension in input_b and update the variance and data
quality extensions accordingly.</p>
<p>If input_b is a dictionary, float, integer or a DescriptorValue object,
each science extension in the input AstroData object (input_a) is divided
by the corresponding single value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>input_a</strong> (<a class="reference internal" href="#module-AstroData" title="AstroData"><em>AstroData</em></a>) &#8211; input AstroData object to be operated on by input_b</li>
<li><strong>input_b</strong> (<em>AstroData, dictionary, list, float, integer, DescriptorValue</em>) &#8211; input value to operate on the input AstroData object
(input_a). This value can be an AstroData object, a
dictionary, where the key is either the (EXTNAME, EXTVER)
tuple or an EXTVER integer for each science extension and
the value is a float or integer, a list of floats or
integers, where the values in the list correspond to the
science extensions in numerical order, a single float or
integer, or a DescriptorValue object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.ext_get_key_value">
<tt class="descname">ext_get_key_value</tt><big>(</big><em>extension</em>, <em>key</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.ext_get_key_value" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>extension</strong> (<em>int or (EXTNAME, EXTVER) tuple</em>) &#8211; identifies which extension, either an integer index 
or (EXTNAME, EXTVER) tuple</li>
<li><strong>key</strong> (<em>string</em>) &#8211; name of header entry to retrieve</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">string</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the value associated with the key, or None if not present</p>
</td>
</tr>
</tbody>
</table>
<p>This function returns the value from the given extension&#8217;s
header, with &#8220;0&#8221; being the first data extension.  To get
values from the PHU use phu_get_key_value(..).</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.ext_set_key_value">
<tt class="descname">ext_set_key_value</tt><big>(</big><em>extension=None</em>, <em>keyword=None</em>, <em>value=None</em>, <em>comment=None</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.ext_set_key_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Add or update a keyword in the header of an extension of the AstroData
object with a specific value and, optionally, a comment. To add or
update a keyword in the PHU of the AstroData object, use
phu_set_key_value().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>extension</strong> (<em>int or (EXTNAME, EXTVER) tuple</em>) &#8211; Name of the extension to add or update. The index [0]
refers to the first extension in the AstroData
object.</li>
<li><strong>keyword</strong> (<em>string</em>) &#8211; Name of the keyword to add or update in the extension</li>
<li><strong>value</strong> (<em>int, float or string</em>) &#8211; Value of the keyword to add or update in the extension</li>
<li><strong>comment</strong> (<em>string</em>) &#8211; Comment of the keyword to add or update in the
extension</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="AstroData.AstroData.filename">
<tt class="descname">filename</tt><a class="headerlink" href="#AstroData.AstroData.filename" title="Permalink to this definition">¶</a></dt>
<dd><p>The filename member is monitored so that the mode can be changed from readonly when the filename is changed.</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.get_classification_library">
<tt class="descname">get_classification_library</tt><big>(</big><big>)</big><a class="headerlink" href="#AstroData.AstroData.get_classification_library" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will return a handle to the ClassificationLibrary.  
NOTE: the ClassificationLibrary is a singleton, this call will either
return the currently extant instance or, if not extant,
will create the classification library (using the default context).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A reference to the system classification library</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">L{ClassificationLibrary}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.get_data">
<tt class="descname">get_data</tt><big>(</big><big>)</big><a class="headerlink" href="#AstroData.AstroData.get_data" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">data array associated with the single extension</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">pyfits.ndarray</td>
</tr>
</tbody>
</table>
<p>The <tt class="docutils literal"><span class="pre">get_data(..)</span></tt> member is the function behind the property-style
&#8220;data&#8221; member and returns appropriate HDU&#8217;s data member(s) specifically
for the case in which the <tt class="docutils literal"><span class="pre">AstroData</span></tt> instance has ONE HDU (in addition to
the PHU). This allows a single-extension <tt class="docutils literal"><span class="pre">AstroData</span></tt>, such as <tt class="docutils literal"><span class="pre">AstroData</span></tt>
generates through iteration,  to be used as though it simply is just the
one extension, e.g. allowing <tt class="docutils literal"><span class="pre">ad.data</span></tt> to be used in place of the more
esoteric and ultimately more dangerous <tt class="docutils literal"><span class="pre">ad[0].data</span></tt>. One
is dealing with single extension <tt class="docutils literal"><span class="pre">AstroData</span></tt> instances when iterating over
the <tt class="docutils literal"><span class="pre">AstroData</span></tt> extensions and when picking out an extension by integer
or tuple indexing, e.g.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">ad</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">[</span><span class="n">SCI</span><span class="p">]:</span>
    <span class="c"># ad is a single-HDU index</span>
    <span class="n">ad</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">newdata</span>

<span class="c"># assuming the named extension exists,</span>
<span class="c"># sd will be a single-HDU AstroData</span>
<span class="n">sd</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[(</span><span class="s">&quot;SCI&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.get_hdu">
<tt class="descname">get_hdu</tt><big>(</big><em>extid</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.get_hdu" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>extid</strong> (<em>int | tuple</em>) &#8211; specifies the extention (pyfits.HDU) to return.</td>
</tr>
</tbody>
</table>
<p>:returns:the extension specified
:rtype:pyfits.HDU</p>
<p>This function returns the HDU identified by the C{extid} argument. This
argument can be an integer or (EXTNAME, EXTVER) tuple.</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.get_hdulist">
<tt class="descname">get_hdulist</tt><big>(</big><big>)</big><a class="headerlink" href="#AstroData.AstroData.get_hdulist" title="Permalink to this definition">¶</a></dt>
<dd><p>This function retrieves the HDUList. NOTE: The HDUList should also be
&#8216;released&#8217; by calling L{release_hdulist}, as access is reference
counted. This function is also aliased to L{get_hdulist(..)&lt;get_hdulist&gt;}.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The AstroData&#8217;s HDUList as returned by pyfits.open()</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">pyfits.HDUList</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.get_header">
<tt class="descname">get_header</tt><big>(</big><em>extension=None</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.get_header" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">header</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">pyfits.Header</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Raises Errors.SingleHDUMemberExcept:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">Will raise an exception if more
than one extension exists. 
(note: The PHU is not considered an extension in this case)</td>
</tr>
</tbody>
</table>
<p>The <tt class="docutils literal"><span class="pre">get_header(..)</span></tt> function returns the header member for Single-HDU
<tt class="docutils literal"><span class="pre">AstroData</span></tt> instances (which are those that have only one extension plus
PHU). This case  can be assured when iterating over extensions using
<tt class="docutils literal"><span class="pre">AstroData</span></tt>, e.g.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">ad</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">[</span><span class="n">SCI</span><span class="p">]:</span> 
    <span class="o">...</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.get_headers">
<tt class="descname">get_headers</tt><big>(</big><big>)</big><a class="headerlink" href="#AstroData.AstroData.get_headers" title="Permalink to this definition">¶</a></dt>
<dd><p>Function returns header member(s) for all extension (except PHU).
:return: list of pyfits.Header instances
:rtype: pyfits.Header</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.get_int_ext">
<tt class="descname">get_int_ext</tt><big>(</big><em>extension</em>, <em>hduref=False</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.get_int_ext" title="Permalink to this definition">¶</a></dt>
<dd><p>getInxExt takes an extension index, either an integer
or (EXTNAME, EXTVER) tuple, and returns the index location
of the extension.  If hduref is set to True, then the index
returned is relative to the HDUList (0=PHU, 1=First non-PHU extension).
If hduref == False (the default) then the index returned is relative to 
the AstroData numbering convention, where index=0 is the first non-PHU
extension in the MEF file.</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.get_key_value">
<tt class="descname">get_key_value</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.get_key_value" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>key</strong> (<em>string</em>) &#8211; name of header value to set</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the specified value</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">string</td>
</tr>
</tbody>
</table>
<p>The get_key_value(..) function is used to get the value associated
with a given key in the data-header unit of a single-HDU
AstroData instance (such as returned by iteration). The value argument
will be converted to string, so it must have a string operator member
function or be passed in as string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note :</th><td class="field-body"><p class="first">Single extension AstroData objects are those with only a single
header-data unit besides the PHU.  They may exist if a single
extension file is loaded, but in general are produced by indexing or
iteration instructions, i.e.:</p>
<blockquote>
<div><p>sead = ad[(&#8220;SCI&#8221;,1)]</p>
<dl class="docutils">
<dt>for sead in ad[&#8220;SCI&#8221;]:</dt>
<dd><p class="first last">...</p>
</dd>
</dl>
</div></blockquote>
<p class="last">The variable &#8220;sead&#8221; above is ensured to hold a single extension
AstroData object, and can be used more convieniently.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.get_status">
<tt class="descname">get_status</tt><big>(</big><em>prune=False</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.get_status" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns the set of type names (strings) which apply to
this dataset and which come from the status section of the AstroData
Type library. &#8216;Status&#8217; classifications are those which tend to change
during the reduction of a dataset based on the amount of processing,
e.g. RAW vs PREPARED.  Strictly, a &#8216;status&#8217; type 
is any type defined in or below the status part of the 
<tt class="docutils literal"><span class="pre">classification</span></tt> directory within the 
configuration package. For example, in the Gemini type configuration 
this means any type 
definition files in or below the 
&#8216;astrodata_Gemini/ADCONFIG/classification/status&#8217; directory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a list of string classification names</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list of strings</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.get_types">
<tt class="descname">get_types</tt><big>(</big><em>prune=False</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.get_types" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>prune</strong> (<em>bool</em>) &#8211; flag which controls &#8216;pruning&#8217; the returned type list 
so that only the leaf node type for a given set of related types
is returned.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a list of classification names that apply to this data</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list of strings</td>
</tr>
</tbody>
</table>
<p>The get_types(..) function returns a list of type names, where type 
names are as always, strings. It is possible to &#8216;prune&#8217; the list so
that only leaf nodes are returned, which is useful when leaf
nodes take precedence such
as for descriptors.</p>
<p>Note: types are divided into two categories, one intended for types
which represent processing status (i.e. RAW vs PREPARED), and another
which contains a more traditional &#8216;typology&#8217; consisting of a 
hierarchical tree of dataset types. This latter tree maps roughly to
instrument-modes, with instrument types branching from the general
observatory type, (e.g. &#8216;GEMINI&#8217;).</p>
<p>To retrieve only status types, use get_status(..); to retreive just
typological types use get_typology(..).  Note that the system does not
enforce what checks are actually performed by types in each category,
that is, one could miscategorize a type when authoring a configuration
package. Both classifications use the same DataClassification objects
to classify datasets. It is up to  those implementing the
type-specific configuration package to ensure types related to status
appear in the correct part of the configuration space.</p>
<p>Currently the distinction betwen status and typology is not used by the
system (e.g. in type-specific default recipe assignments) and is
provided as a service for higher level code, e.g. primitives and
scripts which make use of the distinction.</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.get_typology">
<tt class="descname">get_typology</tt><big>(</big><em>prune=False</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.get_typology" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns the set of type names (strings) which apply to
this dataset and which come from the typology section of the AstroData
Type library. &#8216;Typology&#8217; classifications are those which tend to remain
with the data in spite of reduction status, e.g. those related to the
instrument-mode of the dataset or of the datasets used to produce
it. Strictly these consist of any type defined in or below
the correct configuration directory, for example, in Gemini&#8217;s configuration
package, it would be anything in the
&#8220;astrodata_Gemini/ADCONFIG/classification/types&#8221;  directory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a list of classification name strings</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list of strings</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="AstroData.AstroData.header">
<tt class="descname">header</tt><a class="headerlink" href="#AstroData.AstroData.header" title="Permalink to this definition">¶</a></dt>
<dd><p>The header property can only be used for single-HDU AstroData
instances, such as those returned during iteration. It is a
property attribute which uses <em>get_header(..)</em> and
<em>set_header(..)</em> to access the header member with the &#8220;=&#8221; syntax.
To set the header member, use <em>ad.header = newheader</em>, where
<em>newheader</em> must be a pyfits.Header object. To get the header
member, use <em>hduheader = ad.header</em>.</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.info">
<tt class="descname">info</tt><big>(</big><em>oid=False</em>, <em>table=False</em>, <em>help=False</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.info" title="Permalink to this definition">¶</a></dt>
<dd><p>The info(..) function prints to the shell information regarding
the phu and the extensions found in an AstroData object.  It is a 
high-level wrappers for <tt class="docutils literal"><span class="pre">infostr(..)</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.infostr">
<tt class="descname">infostr</tt><big>(</big><em>as_html=False</em>, <em>oid=False</em>, <em>table=False</em>, <em>help=False</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.infostr" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>as_html</strong> (<em>bool</em>) &#8211; return as HTML formatted string</li>
<li><strong>oid</strong> (<em>bool</em>) &#8211; include object id</li>
<li><strong>help</strong> (<em>bool</em>) &#8211; include sub-data reference information</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The infostr(..) function is used to get a string ready for display
either as plain text or HTML.  It provides AstroData-relative
information.</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.insert">
<tt class="descname">insert</tt><big>(</big><em>index</em>, <em>moredata=None</em>, <em>data=None</em>, <em>header=None</em>, <em>auto_number=False</em>, <em>extname=None</em>, <em>extver=False</em>, <em>do_deepcopy=False</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.insert" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>index</strong> (<em>integer or (EXTNAME,EXTVER) tuple</em>) &#8211; the extension index, either an int or (EXTNAME, EXTVER)
pair before which the extension is to be inserted. Note, the 
first data extension is [0], you cannot insert before the PHU.
Index always refers to Astrodata Numbering system, 0 = HDU</li>
<li><strong>moredata</strong> (<em>pyfits.HDU, pyfits.HDUList, or AstroData</em>) &#8211; Either an AstroData instance, an HDUList instance, or
an HDU instance. When present, data and header will be ignored.</li>
<li><strong>data</strong> (<em>numpy.ndarray</em>) &#8211; <tt class="docutils literal"><span class="pre">data</span></tt> and <tt class="docutils literal"><span class="pre">header</span></tt> are used to construct a new HDU which is then 
added to the <tt class="docutils literal"><span class="pre">HDUList</span></tt> associated to the <tt class="docutils literal"><span class="pre">AstroData</span></tt> instance. The <tt class="docutils literal"><span class="pre">data</span></tt> 
argument should be set
to a valid <tt class="docutils literal"><span class="pre">numpy</span></tt> array. If <tt class="docutils literal"><span class="pre">modedata</span></tt> is not specified, <tt class="docutils literal"><span class="pre">data</span></tt> and <tt class="docutils literal"><span class="pre">header</span></tt>
must both be set.</li>
<li><strong>header</strong> (<em>pyfits.Header</em>) &#8211; <tt class="docutils literal"><span class="pre">data</span></tt> and <tt class="docutils literal"><span class="pre">header</span></tt> are used
to construct a new HDU which is then added to the <tt class="docutils literal"><span class="pre">HDUList</span></tt> associated to 
<tt class="docutils literal"><span class="pre">AstroData</span></tt> instance. The <tt class="docutils literal"><span class="pre">header</span></tt> argument should be set to a
valid <tt class="docutils literal"><span class="pre">pyfits.Header</span></tt> object. If <tt class="docutils literal"><span class="pre">moredata</span></tt> is not specified, <tt class="docutils literal"><span class="pre">data</span></tt> and
<tt class="docutils literal"><span class="pre">header</span></tt> must both be set.</li>
<li><strong>auto_number</strong> (<em>boolean</em>) &#8211; auto-increment the extension version, <tt class="docutils literal"><span class="pre">EXTVER</span></tt>, to fit file convention</li>
<li><strong>do_deepcopy</strong> (<em>boolean</em>) &#8211; deepcopy the input before appending.  Might be useful
when auto_number is True and the input comes from another AD object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This function inserts header-data units (HDUs) to the AstroData
instance.</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.is_type">
<tt class="descname">is_type</tt><big>(</big><em>*typenames</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.is_type" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>typenames</strong> (<em>string or list of strings</em>) &#8211; specifies the type name to check.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal"><span class="pre">True</span></tt> if the given types all apply to this dataset,
<tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Bool</td>
</tr>
</tbody>
</table>
<p>This function checks the <tt class="docutils literal"><span class="pre">AstroData</span></tt> object to see if it is the
given type(s) and returns True if so.  If a list of types is given
as inputs, all the types must match the <tt class="docutils literal"><span class="pre">AstroData</span></tt> object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note :</th><td class="field-body"><tt class="docutils literal"><span class="pre">AstroData.check_type(..)</span></tt> is an alias for 
<tt class="docutils literal"><span class="pre">AstroData.is_type(..)</span></tt>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.ishdu">
<tt class="descname">ishdu</tt><big>(</big><em>md=None</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.ishdu" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks to see if md (moredata) is acutally an hdu.
:returns: True or False
:rtype: boolean</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.moredata_work">
<tt class="descname">moredata_work</tt><big>(</big><em>append=False</em>, <em>insert=False</em>, <em>autonum=False</em>, <em>md=None</em>, <em>hduindx=None</em>, <em>hdul=None</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.moredata_work" title="Permalink to this definition">¶</a></dt>
<dd><p>create a master table out of the host and update the EXTVER 
for the guest as it is being updated in the table</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.mult">
<tt class="descname">mult</tt><big>(</big><em>input_b</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.mult" title="Permalink to this definition">¶</a></dt>
<dd><p>The mult function uses numpy.multiply to multiply an AstroData object
(input_a) by input_b, where input_b could be either another AstroData
object, a dictionary, list, float or integer, or a DescriptorValue (DV)
object.</p>
<p>If input_b is an AstroData object, the mult function will multiply each
science extension in the input AstroData object (input_a) with the
corresponding science extension in input_b and update the variance and data
quality extensions accordingly.</p>
<p>If input_b is a dictionary, float, integer or a DescriptorValue object,
each science extension in the input AstroData object (input_a) is
multiplied by the corresponding single value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>input_a</strong> (<a class="reference internal" href="#module-AstroData" title="AstroData"><em>AstroData</em></a>) &#8211; input AstroData object to be operated on by input_b</li>
<li><strong>input_b</strong> (<em>AstroData, dictionary, list, float, integer, DescriptorValue</em>) &#8211; input value to operate on the input AstroData object
(input_a). This value can be an AstroData object, a
dictionary, where the key is either the (EXTNAME, EXTVER)
tuple or an EXTVER integer for each science extension and
the value is a float or integer, a list of floats or
integers, where the values in the list correspond to the
science extensions in numerical order, a single float or
integer, or a DescriptorValue object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.next">
<tt class="descname">next</tt><big>(</big><big>)</big><a class="headerlink" href="#AstroData.AstroData.next" title="Permalink to this definition">¶</a></dt>
<dd><p>This function exists so that AstroData can be used as an iterator.
This function returns the objects &#8220;ext&#8221; in the following line:</p>
<p>for ext in gemdatainstance:</p>
<p>If this AstroData instance is associated with a subset of the data in
the MEF to which it refers, then this iterator goes through that subset
in order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a single extension AstroData instance representing the
&#8216;current&#8217; extension in the AstroData iteration loop.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">AstroData</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.onehdu_work">
<tt class="descname">onehdu_work</tt><big>(</big><em>append=False</em>, <em>insert=False</em>, <em>replace=False</em>, <em>extver=None</em>, <em>extname=None</em>, <em>header=None</em>, <em>data=None</em>, <em>autonum=False</em>, <em>hduindx=None</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.onehdu_work" title="Permalink to this definition">¶</a></dt>
<dd><p>does extension work for one HDU</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.open">
<tt class="descname">open</tt><big>(</big><em>source</em>, <em>mode='readonly'</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.open" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>source</strong> (<em>string | AstroData | pyfits.HDUList</em>) &#8211; source contains some reference for the dataset to 
be opened and associated with this instance. Generally
it would be a filename, but can also be
an AstroData instance or a pyfits.HDUList instance.</li>
<li><strong>mode</strong> (<em>string</em>) &#8211; IO access mode, same as the pyfits open mode, &#8216;readonly,
&#8216;update&#8217;, or &#8216;append&#8217;.  The mode is passed to pyfits so
if it is an illegal mode name, pyfits will be the
subsystem reporting the error.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This function wraps a source dataset, which can be in memory as another
AstroData or pyfits HDUList, or on disk, given as the string filename.</p>
<p>Please note that generally one does not use &#8216;open&#8217; directly, but passes
the filename to the AstroData constructor. The constructor uses
open(..) however.  Most users should use the constructor, which may 
perform extra operations.</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.phu_get_key_value">
<tt class="descname">phu_get_key_value</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.phu_get_key_value" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>key</strong> (<em>string</em>) &#8211; name of header value to retrieve</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">string</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the key&#8217;s value as string or None if not present.</td>
</tr>
</tbody>
</table>
<p>The phu_get_key_value(..) function returns the value associated with the
given key within the primary header unit
of the dataset. The value is returned as a string (storage format)
and must be converted as necessary by the caller.</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.phu_set_key_value">
<tt class="descname">phu_set_key_value</tt><big>(</big><em>keyword=None</em>, <em>value=None</em>, <em>comment=None</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.phu_set_key_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Add or update a keyword in the PHU of the AstroData object with a
specific value and, optionally, a comment</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>keyword</strong> (<em>string</em>) &#8211; Name of the keyword to add or update in the PHU</li>
<li><strong>value</strong> (<em>int, float or string</em>) &#8211; Value of the keyword to add or update in the PHU</li>
<li><strong>comment</strong> (<em>string</em>) &#8211; Comment of the keyword to add or update in the PHU</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.re_phukeys">
<tt class="descname">re_phukeys</tt><big>(</big><em>rekey</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.re_phukeys" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rekey</strong> (<em>string</em>) &#8211; A regular expression</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a list of keys from the PHU that matched C{rekey}</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
</tbody>
</table>
<p>The re_phukeys(..) function returns all keys in this dataset&#8217;s PHU 
which match the given  regular expression.</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.release_hdulist">
<tt class="descname">release_hdulist</tt><big>(</big><big>)</big><a class="headerlink" href="#AstroData.AstroData.release_hdulist" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will release a reference to the HDUList... don&#8217;t call 
unless you have called L{get_hdulist} at some prior point. 
(Note, release_hdulist is aliased to L{release_hdulist(..)&lt;release_hdulist&gt;})</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.remove">
<tt class="descname">remove</tt><big>(</big><em>index</em>, <em>hdui=False</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.remove" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>index</strong> (<em>integer or (EXTNAME,EXTVER) tuple</em>) &#8211; the extension index, either an int or (EXTNAME, EXTVER)
pair before which the extension is to be inserted. Note, the 
first data extension is [0], you cannot insert before the PHU.
Index always refers to Astrodata Numbering system, 0 = HDU</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.rename_ext">
<tt class="descname">rename_ext</tt><big>(</big><em>name</em>, <em>ver=None</em>, <em>force=True</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.rename_ext" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>string</em>) &#8211; New &#8216;EXTNAME&#8217; for the given extension.</li>
<li><strong>ver</strong> (<em>int</em>) &#8211; New &#8216;EXTVER&#8217; for the given extension</li>
<li><strong>force</strong> (<em>boolean</em>) &#8211; ???  Default=True</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Note: This member only works on single extension <tt class="docutils literal"><span class="pre">AstroData</span></tt> instances.</p>
<p>The <tt class="docutils literal"><span class="pre">rename_ext(..)</span></tt> function is used in order to rename an HDU with a new
EXTNAME and EXTVER identifier.  Merely changing the EXTNAME and 
EXTEVER values in the extensions <tt class="docutils literal"><span class="pre">pyfits.Header</span></tt> are not sufficient.
Though the values change in the <tt class="docutils literal"><span class="pre">pyfits.Header</span></tt> object, there are special
HDU class members which are not updated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Warning :</th><td class="field-body">This function manipulates private (or somewhat private)  HDU
members, specifically &#8216;name&#8217; and &#8216;_extver&#8217;. STSCI has been
informed of the issue and
has made a special HDU function for performing the renaming. 
When generally available, this new function will be used instead of
manipulating the  HDU&#8217;s properties directly, and this function will 
call the new <tt class="docutils literal"><span class="pre">pyfits.HDUList(..)</span></tt> function.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.setExtname">
<tt class="descname">setExtname</tt><big>(</big><em>name</em>, <em>ver=None</em>, <em>force=True</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.setExtname" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>string</em>) &#8211; New &#8216;EXTNAME&#8217; for the given extension.</li>
<li><strong>ver</strong> (<em>int</em>) &#8211; New &#8216;EXTVER&#8217; for the given extension</li>
<li><strong>force</strong> (<em>boolean</em>) &#8211; ???  Default=True</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Note: This member only works on single extension <tt class="docutils literal"><span class="pre">AstroData</span></tt> instances.</p>
<p>The <tt class="docutils literal"><span class="pre">rename_ext(..)</span></tt> function is used in order to rename an HDU with a new
EXTNAME and EXTVER identifier.  Merely changing the EXTNAME and 
EXTEVER values in the extensions <tt class="docutils literal"><span class="pre">pyfits.Header</span></tt> are not sufficient.
Though the values change in the <tt class="docutils literal"><span class="pre">pyfits.Header</span></tt> object, there are special
HDU class members which are not updated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Warning :</th><td class="field-body">This function manipulates private (or somewhat private)  HDU
members, specifically &#8216;name&#8217; and &#8216;_extver&#8217;. STSCI has been
informed of the issue and
has made a special HDU function for performing the renaming. 
When generally available, this new function will be used instead of
manipulating the  HDU&#8217;s properties directly, and this function will 
call the new <tt class="docutils literal"><span class="pre">pyfits.HDUList(..)</span></tt> function.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.set_data">
<tt class="descname">set_data</tt><big>(</big><em>newdata</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.set_data" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>newdata</strong> (<em>numpy.ndarray</em>) &#8211; new data objects</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Raises Errors.SingleHDUMemberExcept:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">if AstroData instance has more 
than one extension (not including PHU).</td>
</tr>
</tbody>
</table>
<p>This function sets the data member of a data section of an <tt class="docutils literal"><span class="pre">AstroData</span></tt>
object, specifically for the case in which the <tt class="docutils literal"><span class="pre">AstroData</span></tt> instance has
ONE header-data unit (in addition to PHU).  This case is assured when
iterating over the <tt class="docutils literal"><span class="pre">AstroData</span></tt> extensions, as in:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">ad</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">[</span><span class="n">SCI</span><span class="p">]:</span>
    <span class="o">...</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.set_header">
<tt class="descname">set_header</tt><big>(</big><em>header</em>, <em>extension=None</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.set_header" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>header</strong> (<em>pyfits.Header</em>) &#8211; pyfits Header to set for given extension</li>
<li><strong>extension</strong> (<em>int or tuple, pyfits compatible extension index</em>) &#8211; Extension index to retrieve header, if None
or not present then this must be a single extension AstroData
instance, which contains just the PHU and a single data extension,
and the data extension&#8217;s header is returned.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Raises Errors.SingleHDUMemberExcept:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first last">Will raise an exception if more 
than one extension exists.</p>
</td>
</tr>
</tbody>
</table>
<p>The <tt class="docutils literal"><span class="pre">set_header(..)</span></tt> function sets the extension header member for single
extension (which are those that have only one extension plus PHU). This
case  is assured when iterating over extensions using <tt class="docutils literal"><span class="pre">AstroData</span></tt>, e.g.:</p>
<blockquote>
<div><dl class="docutils">
<dt>for ad in dataset[SCI]: </dt>
<dd>...</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.set_key_value">
<tt class="descname">set_key_value</tt><big>(</big><em>key</em>, <em>value</em>, <em>comment=None</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.set_key_value" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>key</strong> (<em>string</em>) &#8211; name of data header value to set</li>
<li><strong>value</strong> (<em>int, float, string</em>) &#8211; value to apply to header</li>
<li><strong>comment</strong> (<em>string</em>) &#8211; value to be put in the comment part of the header key</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The set_key_value(..) function is used to set the value (and optionally
the comment) associated
with a given key in the data-header of a single-HDU AstroData instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note :</th><td class="field-body"><p class="first">Single extension AstroData objects are those with only a single
header-data unit besides the PHU.  They may exist if a single
extension file is loaded, but in general are produced by indexing or
iteration instructions, i.e.:</p>
<blockquote>
<div><p>sead = ad[(&#8220;SCI&#8221;,1)]</p>
<dl class="docutils">
<dt>for sead in ad[&#8220;SCI&#8221;]:</dt>
<dd><p class="first last">...</p>
</dd>
</dl>
</div></blockquote>
<p class="last">The variable &#8220;sead&#8221; above is ensured to hold a single extension
AstroData object, and can be used more convieniently.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.store_original_name">
<tt class="descname">store_original_name</tt><big>(</big><big>)</big><a class="headerlink" href="#AstroData.AstroData.store_original_name" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will add the key &#8216;ORIGNAME&#8217; to PHU of an astrodata object 
containing the filename when object was instantiated (without any 
directory info, ie. the basename).</p>
<p>If key has all ready been added (ie. has undergone processing where
store_original_name was performed before), then the value original 
filename is just returned.  If the key is there, but does not match
the original filename of the object, then the original name is 
returned, NOT the value in the PHU. The value in the PHU can always be
found using ad.phu_get_key_value(&#8216;ORIGNAME&#8217;).</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.sub">
<tt class="descname">sub</tt><big>(</big><em>input_b</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.sub" title="Permalink to this definition">¶</a></dt>
<dd><p>The sub function uses numpy.subtract to subtract input_b from an AstroData
object (input_a), where input_b could be either another AstroData object, a
dictionary, list, float or integer, or a DescriptorValue (DV) object.</p>
<p>If input_b is an AstroData object, the sub function will subtract each
science extension from input_b from the corresponding science extension in
the input AstroData object (input_a) and update the variance and data
quality extensions accordingly.</p>
<p>If input_b is a dictionary, float, integer or a DescriptorValue object, the
corresponding single value is subtracted from each science extension in the
input AstroData object (input_a).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>input_a</strong> (<a class="reference internal" href="#module-AstroData" title="AstroData"><em>AstroData</em></a>) &#8211; input AstroData object to be operated on by input_b</li>
<li><strong>input_b</strong> (<em>AstroData, dictionary, list, float, integer, DescriptorValue</em>) &#8211; input value to operate on the input AstroData object
(input_a). This value can be an AstroData object, a
dictionary, where the key is either the (EXTNAME, EXTVER)
tuple or an EXTVER integer for each science extension and
the value is a float or integer, a list of floats or
integers, where the values in the list correspond to the
science extensions in numerical order, a single float or
integer, or a DescriptorValue object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.translate_int_ext">
<tt class="descname">translate_int_ext</tt><big>(</big><em>integer</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.translate_int_ext" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used internally to support AstroData
instances associated with a subset of the full MEF file
associated with this instance. This function, if this instance
is not associated with the entire MEF, will return whatever
is in the extensions list at that index, otherwise, it returns
the integer passed in. In the first case it can be a tuple which
is returned if tuples were used to specify the subset of 
extensions from the MEF which are associated with this instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">int | tuple</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the pyfits-index, relative to the containing HDUList</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.verify_header">
<tt class="descname">verify_header</tt><big>(</big><em>extname=None</em>, <em>extver=None</em>, <em>header=None</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.verify_header" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>extname</strong> (<em>integer</em>) &#8211; extension name (ex, &#8216;SCI&#8217;, &#8216;VAR&#8217;, &#8216;DQ&#8217;)</li>
<li><strong>extver</strong> &#8211; extension version</li>
<li><strong>header</strong> (<em>pyfits.core.Header</em>) &#8211; a valid pyfits.Header object</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This is a helper function for insert, append and replace that compares
the extname argument with the extname in the header. If the key does
not exist it adds it, if its different, it changes it to match the 
argument
:returns header: a validated pyfits.Header object
:rtype: pyfits.core.Header</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.write">
<tt class="descname">write</tt><big>(</big><em>filename=None</em>, <em>clobber=False</em>, <em>rename=None</em>, <em>prefix=None</em>, <em>suffix=None</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.write" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> (<em>string</em>) &#8211; name of the file to write to. Optional if the instance
already has a filename defined, which might not be the case for new AstroData
instances created in memory.</li>
<li><strong>clobber</strong> (<em>bool</em>) &#8211; This flag drives if AstroData will overwrite an existing
file.</li>
<li><strong>rename</strong> (<em>bool</em>) &#8211; This flag allows you to write the AstroData instance to
a new filename, but leave the &#8216;current&#8217; name in tact in memory.</li>
<li><strong>prefix</strong> &#8211; Add a prefix to <tt class="docutils literal"><span class="pre">filename</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>type prefix: string
:param suffix: Add a suffix to <tt class="docutils literal"><span class="pre">filename</span></tt>.
type suffix: string</p>
<p>The write function acts similarly to the <tt class="docutils literal"><span class="pre">pyfits</span> <span class="pre">HDUList.writeto(..)</span></tt>
function if a filename is given, or like <tt class="docutils literal"><span class="pre">pyfits.HDUList.update(..)</span></tt> if 
no name is given, using whatever the current name is set to. When a name
is given, this becomes the new name of the <tt class="docutils literal"><span class="pre">AstroData</span></tt> object and
will be used on subsequent calls to  write for which a filename is not
provided. If the <tt class="docutils literal"><span class="pre">clobber</span></tt> flag is <tt class="docutils literal"><span class="pre">False</span></tt> (the default) then <tt class="docutils literal"><span class="pre">write(..)</span></tt>
throws an exception if the file already exists.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="AstroData.correlate">
<tt class="descclassname">AstroData.</tt><tt class="descname">correlate</tt><big>(</big><em>*iary</em><big>)</big><a class="headerlink" href="#AstroData.correlate" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>iary</strong> (<em>list of AstroData instance</em>) &#8211; A list of AstroData instances for which a correlation dictionary
will be constructed.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a list of tuples containing correlated extensions from the arguments.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list of tuples</td>
</tr>
</tbody>
</table>
<p>The <tt class="docutils literal"><span class="pre">correlate(..)</span></tt> function is a module-level helper function which returns
a list of tuples of Single Extension <tt class="docutils literal"><span class="pre">AstroData</span></tt> instances which associate
extensions from each listed AstroData object, to identically named
extensions among the rest of the input array. The <tt class="docutils literal"><span class="pre">correlate(..)</span></tt> function
accepts a variable number of arguments, all of which should be <tt class="docutils literal"><span class="pre">AstroData</span></tt>
instances.</p>
<p>The function returns a structured dictionary of dictionaries of lists of
<tt class="docutils literal"><span class="pre">AstroData</span></tt> objects. For example, given three inputs, <em>ad</em>, <em>bd</em> and <em>cd</em>, all
with three &#8220;SCI&#8221;, &#8220;VAR&#8221; and &#8220;DQ&#8221; extensions. Given <em>adlist = [ad, bd,
cd]</em>, then <em>corstruct = correlate(adlist)</em> will return to <em>corstruct</em> a
dictionary first keyed by the EXTNAME, then keyed by tuple. The contents
(e.g. of <em>corstruct[&#8220;SCI&#8221;][1]</em>) are just a list of AstroData instances each
containing a header-data unit from <em>ad</em>, <em>bd</em>, and <em>cd</em> respectively.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Info :</th><td class="field-body">to appear in the list, all the given arguments must have an extension
with the given (EXTNAME,EXTVER) for that tuple.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="AstroData.prep_output">
<tt class="descclassname">AstroData.</tt><tt class="descname">prep_output</tt><big>(</big><em>input_ary=None</em>, <em>name=None</em>, <em>clobber=False</em><big>)</big><a class="headerlink" href="#AstroData.prep_output" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>input_ary</strong> (<em>list of AstroData Instances</em>) &#8211; The input array from which propagated content (such as
the  source PHU) will be taken. Note: the zero-th element in the list
is  used as the reference dataset for PHU or other items which require
a particular reference.</li>
<li><strong>name</strong> &#8211; File name to use for returned AstroData, optional.</li>
<li><strong>clobber</strong> (<em>bool</em>) &#8211; By default <tt class="docutils literal"><span class="pre">prep_output(..)</span></tt> checks to see if a file of the
given name already exists, and will raise an exception if found.
Set <em>clobber</em> to <em>True</em> to override this behavior and potentially
overwrite the extant file.  The dataset on disk will not be overwritten
as a direct result of prep_output, which only prepares the object
in memory, but will occur when the AstroData object returned is 
written (i.e. <tt class="docutils literal"><span class="pre">ad.write(..)</span></tt>)).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">an <tt class="docutils literal"><span class="pre">AstroData</span></tt> instance initialized with appropriate
header-data units such as the PHU, Standard Gemini headers
and with type-specific associated  data-header units such as
binary table Mask Definition tables (MDF).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">AstroData</p>
</td>
</tr>
</tbody>
</table>
<p>..info: File will not have been written to disk by <tt class="docutils literal"><span class="pre">prep_output(..)</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">prep_output(..)</span></tt> function creates a new <tt class="docutils literal"><span class="pre">AstroData</span></tt> object ready for
appending output information (e.g. <tt class="docutils literal"><span class="pre">ad.append(..)</span></tt>).  While you can also
create an empty <tt class="docutils literal"><span class="pre">AstroData</span></tt> object by giving no arguments to the <tt class="docutils literal"><span class="pre">AstroData</span></tt>
constructor  (i.e. <tt class="docutils literal"><span class="pre">ad</span> <span class="pre">=</span> <span class="pre">AstroData()</span></tt>), <tt class="docutils literal"><span class="pre">prep_output(..)</span></tt> exists for the
common case where a new dataset object is intended as the output of
some processing on a list of source datasets, and some information
from the source inputs must be propagated.</p>
<p>The <tt class="docutils literal"><span class="pre">prep_output(..)</span></tt> function makes use of this knowledge to ensure the
file meets standards in what is considered a complete output file given
such a combination.  In the future this function can make use of dataset
history and structure definitions in the ADCONFIG configuration space. As
<tt class="docutils literal"><span class="pre">prep_output</span></tt> improves, scripts and primitives that use it
will benefit in a forward compatible way, in that their output datasets will
benefit from more automatic propagation, validations, and data flow control,
such as the emergence of history database propagation.</p>
<p>Presently, it already provides the following:</p>
<ul class="simple">
<li>Ensures that all standard headers are in place in the new file, using the
configuration .</li>
<li>Copy the PHU of the reference image (<tt class="docutils literal"><span class="pre">input_ary[0]</span></tt>).</li>
<li>Propagate associated information such as the MDF in the case of a MOS 
observation, configurable by the Astrodata Structures system.</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="AstroData.re_header_keys">
<tt class="descclassname">AstroData.</tt><tt class="descname">re_header_keys</tt><big>(</big><em>rekey</em>, <em>header</em><big>)</big><a class="headerlink" href="#AstroData.re_header_keys" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>rekey</strong> (<em>string</em>) &#8211; a regular expression to match keys in header</li>
<li><strong>header</strong> (<em>pyfits.Header</em>) &#8211; a <tt class="docutils literal"><span class="pre">pyfits.Header</span></tt> object as returned by <tt class="docutils literal"><span class="pre">ad[(&quot;SCI&quot;,1)].header</span></tt></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">a list of matching keys</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list of strings</p>
</td>
</tr>
</tbody>
</table>
<p>This utility function returns a list of keys from 
the input header that match the regular expression.</p>
</dd></dl>

<span class="target" id="module-AstroDataType"></span><dl class="class">
<dt id="AstroDataType.BadArgument">
<em class="property">class </em><tt class="descclassname">AstroDataType.</tt><tt class="descname">BadArgument</tt><a class="headerlink" href="#AstroDataType.BadArgument" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for raising a particular exception</p>
</dd></dl>

<dl class="class">
<dt id="AstroDataType.CLAlreadyExists">
<em class="property">class </em><tt class="descclassname">AstroDataType.</tt><tt class="descname">CLAlreadyExists</tt><a class="headerlink" href="#AstroDataType.CLAlreadyExists" title="Permalink to this definition">¶</a></dt>
<dd><p>This class exists to return a singleton of the ClassificationLibrary instance.
See L{ClassificationLibrary} for more information.</p>
<p>B{NOTE}: This should be refactored into a non-exception calling version that uses
the __new__ operator instead of __init__. This method is required because __init__
cannot return a value, so instead throws an exception if the ClassficationLibrary
has already been created. Please use the AstroData interfaces for the 
classification to access data classification information so that your code does not
break when this is refactored. That interface is far more convienent and in most
cases you only need to use the ClassificationLibrary if you are working with
data and therefore have access to an AstroData instance.</p>
</dd></dl>

<dl class="class">
<dt id="AstroDataType.ClassificationLibrary">
<em class="property">class </em><tt class="descclassname">AstroDataType.</tt><tt class="descname">ClassificationLibrary</tt><big>(</big><em>context='default'</em><big>)</big><a class="headerlink" href="#AstroDataType.ClassificationLibrary" title="Permalink to this definition">¶</a></dt>
<dd><p>This class exists as the proper full interface to the classification features,
though most users should merely use the classification interface provided
through AstroData. Single DataClassification 
class instances can report if their own classifications apply, but only a complete 
library encapsulates
the whole classification system.
To find if a single classification applies, the coder 
asks the library by providing the classification by name. DataClassification 
objects
are not passed around, but used only to detect the classfication.
Script authors therefore should not 
converse directly with the data classification classes, and instead
allow them to be managed by the Library.</p>
<p>This Library also knows how to produce HTML documentation of itself, so 
that the classification
definitions can be the sole source of such information and thus keep the 
documentation as up to date as possible.</p>
<p>&#64;note: Classification Names, aka Gemini Type Names, are strings, the 
python objects are not used to 
report types, only detect them.  When passed in and out of functions
classifications are always represented by their string names.</p>
<p>&#64;note: This class is a singleton, which means on the second attempt to create 
it, instead of a new instance one will recieve
a pointer to the instance already created. This ensures that only one 
library will be loaded in
a given program, which desireable for efficiency and coherence to a single
type family for a given processing
session.</p>
<p>The way this is accomplished is that the constructor for ClassificationLibrary keeps a class static variable
with it&#8217;s own instance pointer, if this pointer is already set, the constructor (aka __init__()) throws an
exception, an instance of CLAlreadyExists which will contain the reference to the ClassificationLibrary instance.</p>
<p>To make this work it is not advised to instantiate the ClassificationLibrary in a single regular call like
C{cl = ClassificationLibrary()}, instead, use code such as the following:</p>
<div class="highlight-python"><pre>if (self.classification_library == None):
      try:
          self.classification_library = ClassificationLibrary()
      except CLAlreadyExists, s:
          self.classification_library = s.clInstance
          
  return self.classification_library</pre>
</div>
<p>The L{AstroData.get_classification_library} function retrieves the instance handle 
this way.</p>
<p>This method is slated to be replaced, to avoid being affected by the change
use the AstroData class&#8217; interface to classification features.</p>
<dl class="method">
<dt id="AstroDataType.ClassificationLibrary.check_type">
<tt class="descname">check_type</tt><big>(</big><em>typename</em>, <em>dataset</em><big>)</big><a class="headerlink" href="#AstroDataType.ClassificationLibrary.check_type" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will check to see if a given type applies to a given dataset.</p>
<p>&#64;param typename: then name of the type to check the C{dataset} against.
&#64;type typename: string</p>
<p>&#64;param dataset: the data set in question
&#64;type dataset: either L{AstroData} instance or B{string}
&#64;returns: True if the type applies to the dataset, False otherwise
&#64;rtype: Bool</p>
</dd></dl>

<dl class="method">
<dt id="AstroDataType.ClassificationLibrary.discover_classifications">
<tt class="descname">discover_classifications</tt><big>(</big><em>dataset</em>, <em>classification_dict</em><big>)</big><a class="headerlink" href="#AstroDataType.ClassificationLibrary.discover_classifications" title="Permalink to this definition">¶</a></dt>
<dd><p>discoverClassificatons will return a list of classifications (&#8220;data types&#8221;).
&#8216;dataset&#8217; should be an HDUList or AstroData instance.</p>
<p>&#64;param dataset: the data set in question
&#64;type dataset: either L{AstroData} instance or B{string}
&#64;return: Returns list of DataClassification names
&#64;rtype: list of strings</p>
</dd></dl>

<dl class="method">
<dt id="AstroDataType.ClassificationLibrary.discover_status">
<tt class="descname">discover_status</tt><big>(</big><em>dataset</em><big>)</big><a class="headerlink" href="#AstroDataType.ClassificationLibrary.discover_status" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns a list of string names for the processing
status related classifications
which apply to this dataset.
&#64;param dataset: the data set in question
&#64;type dataset: either L{AstroData} instance or L{HDUList}
&#64;returns: the data type classifications which apply to the given dataset
&#64;rtype: list of strings</p>
</dd></dl>

<dl class="method">
<dt id="AstroDataType.ClassificationLibrary.discover_types">
<tt class="descname">discover_types</tt><big>(</big><em>dataset</em>, <em>all=False</em><big>)</big><a class="headerlink" href="#AstroDataType.ClassificationLibrary.discover_types" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns a list of string names for the classifications
which apply to this dataset.
&#64;param dataset: the data set in question
&#64;type dataset: either L{AstroData} instance or L{HDUList}
&#64;param all: flag to drive if a dictionary of three different lists
is returned, if C{all} is True.  If False, a list of all status and processing
types is returned as a list of strong names.  If True, a dictionary 
is returned.  Element with the key &#8220;typology&#8221; will contain the typology
related classifications, key &#8220;status&#8221; will contain the processing status related
classifications, and key &#8220;all&#8221; will contain the union of both sets and is the 
list returned when &#8220;all&#8221; is False.
&#64;type all: Bool
&#64;returns: the data type classifications which apply to the given dataset
&#64;rtype: list or dict of lists</p>
</dd></dl>

<dl class="method">
<dt id="AstroDataType.ClassificationLibrary.discover_typology">
<tt class="descname">discover_typology</tt><big>(</big><em>dataset</em><big>)</big><a class="headerlink" href="#AstroDataType.ClassificationLibrary.discover_typology" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns a list of string names for the typological
classifications
which apply to this dataset.
&#64;param dataset: the data set in question
&#64;type dataset: either L{AstroData} instance or L{HDUList}
&#64;returns: the data type classifications which apply to the given dataset
&#64;rtype: list of strings</p>
</dd></dl>

<dl class="method">
<dt id="AstroDataType.ClassificationLibrary.get_type_obj">
<tt class="descname">get_type_obj</tt><big>(</big><em>typename</em><big>)</big><a class="headerlink" href="#AstroDataType.ClassificationLibrary.get_type_obj" title="Permalink to this definition">¶</a></dt>
<dd><p>Generally users do not need DataClassification instances, however
if you really do need that object, say to write an editor... this function
will retrieve it.
&#64;param typename: the name of the classification for which you want the
associated DataClassification instance
&#64;type typename: string
&#64;returns: the correct DataClassification instance
&#64;rtype: DataClassification</p>
</dd></dl>

<dl class="method">
<dt id="AstroDataType.ClassificationLibrary.gviz_doc">
<tt class="descname">gviz_doc</tt><big>(</big><em>writeout=False</em>, <em>astrotype=None</em>, <em>assign_dict=None</em><big>)</big><a class="headerlink" href="#AstroDataType.ClassificationLibrary.gviz_doc" title="Permalink to this definition">¶</a></dt>
<dd><p>This function generates output in the &#8220;dot&#8221; language, which
is used as input for the graphviz &#8220;dot&#8221; program which creates
directed graphs in many different outputs.  We are interested
in the SVG output, though it should be sufficient for any
of the suppreqorted output formats.
&#64;param writeout: controls if the buffer created is written out
to a file. Note that at this time the buffer will be written out to 
a hardcoded directory.
&#64;type writeout: Bool
&#64;returns: buffer containing DOT language commands as can be interpreted
by the graphviz product.
&#64;rtype: string</p>
</dd></dl>

<dl class="method">
<dt id="AstroDataType.ClassificationLibrary.html_doc">
<tt class="descname">html_doc</tt><big>(</big><big>)</big><a class="headerlink" href="#AstroDataType.ClassificationLibrary.html_doc" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces a full HTML page of documentation on the current classification 
dictionary, aka Type Dictionary.
&#64;returns: HTML for the classification library
&#64;rtype: string</p>
</dd></dl>

<dl class="method">
<dt id="AstroDataType.ClassificationLibrary.load">
<tt class="descname">load</tt><big>(</big><big>)</big><a class="headerlink" href="#AstroDataType.ClassificationLibrary.load" title="Permalink to this definition">¶</a></dt>
<dd><p>This function loads the classification library, in general 
by obtaining python modules containing classes 
which descend from DataClassification (or share its interface)
and evaluating them.
&#64;returns: Nothing</p>
</dd></dl>

<dl class="method">
<dt id="AstroDataType.ClassificationLibrary.load_types">
<tt class="descname">load_types</tt><big>(</big><em>spacename</em>, <em>globaldict</em>, <em>tdict</em><big>)</big><a class="headerlink" href="#AstroDataType.ClassificationLibrary.load_types" title="Permalink to this definition">¶</a></dt>
<dd><p>This function loads all the modules matching a given naming convention
(regular expression &#8220;B{gemdtype.(?P&lt;modname&gt;.*?).py$}&#8221;)
recursively within the given path. Loaded files are assumed to be
either DataClassifications or share DataClassification&#8217;s interface.
Note, multiple DataClassifications can be put in the same file, 
and it is important to add the new class to the C{newtypes} variable
in the definition file, or else the load function will not see it.</p>
</dd></dl>

<dl class="method">
<dt id="AstroDataType.ClassificationLibrary.trace_parents">
<tt class="descname">trace_parents</tt><big>(</big><big>)</big><a class="headerlink" href="#AstroDataType.ClassificationLibrary.trace_parents" title="Permalink to this definition">¶</a></dt>
<dd><p>DataClassifications are generally specified by name for the user
and only the AstroDataType module cares about the actual dataclassification
object.  However, it&#8217;s needed in order to trace precedence when assigning
features, like descriptor calculator or primitive sets.  In this function
we trace through the string names of parents, and create members which
will make it easy to walk the tree.</p>
<p>The short explanation of what this function does is set the DCO members,
parentDCO and childDCOs, as well as the children member which contains the
string names of the child types.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="AstroDataType.DataClassification">
<em class="property">class </em><tt class="descclassname">AstroDataType.</tt><tt class="descname">DataClassification</tt><a class="headerlink" href="#AstroDataType.DataClassification" title="Permalink to this definition">¶</a></dt>
<dd><p>The DataClassification Class encapsulates a single classification type, and
knows how to recognize that type when given a pyfits.HDUList instance.
Matching is currently done against PHU header keys, though the object
is designed to be able to look elsewhere for classifying information.
Classification configurations are classes subclassed from DataClassification
with the class variables set appropriately to indicate the PHU requirements.</p>
<p>The DataClassification class also allows specifying one type as dependant on
another type, in which case the other type will try to match the PHU headers
defined for it. When used through GeminiData applicable classification names are
cached so the PHU is not checked repeatedly.</p>
<p>This object is not intended for general us, and is a worker class for
the L{ClassificationLibrary}, from the users point of view data classifications
are handled as strings, i.e. classification names.  L{ClassificationLibrary}
is therefore the proper interface to use
for retrieving type information. However, most users will use the L{AstroData}
classification interface which in turn rely on L{ClassificationLibrary}.</p>
<p>NOTE: The configuration system and public interface makes a distinction between
&#8220;typology&#8221; classifications and &#8220;processing status&#8221; classifications. Technically
there is no real difference between these two types of classification, the 
difference occurs in the purpose of the two, and the interfaces allow getting
one or the other type, or both. In principle however, typology classifications
relate to instrument-modes or other classifications that more or less still apply
to the data after it has been transformed by processing (e.g. GMOS_IMAGE data
is still GMOS_IMAGE data after flat fielding), and processing status 
classifications will fail to apply after processing (e.g. GMOS_UNPREPARED data
is no longer GMOS_UNPREPARED after running prepare, but changes instead 
to GMOS_PREPARED).</p>
<dl class="method">
<dt id="AstroDataType.DataClassification.assert_type">
<tt class="descname">assert_type</tt><big>(</big><em>hdulist</em><big>)</big><a class="headerlink" href="#AstroDataType.DataClassification.assert_type" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will check to see if the given HDUList instance is
of its classification. Currently this function checks PHU keys
in the C{hdulist} argument as well as check to see if any classifications
upon which this classification is dependent apply.  To extend
what is checked to other details, such as headers in data extensions,
this function must change or be overridden by a child class.
&#64;param hdulist: an HDUList as returned by pyfits.open()
&#64;type hdulist: pyfits.HDUList
&#64;return: C{True} if this class applies to C{hdulist}, C{False} otherwise.
&#64;rtype: bool</p>
</dd></dl>

<dl class="method">
<dt id="AstroDataType.DataClassification.get_all_super_types">
<tt class="descname">get_all_super_types</tt><big>(</big><em>height=0</em><big>)</big><a class="headerlink" href="#AstroDataType.DataClassification.get_all_super_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of all parents and grandparents of self in level order of self. Within each
level, sorting is based on how typereqs was input. For example, if typereqs = [a,b,d,c], then
that level will be [a,b,d,c] and the first parents in the level above will be from a, then b, 
then d and then c.</p>
<p>&#64;param height: The height from which to get achieve parents up to. A height &lt;= 0, will return 
all parents/grandparents.
&#64;type height: int</p>
<p>&#64;return: A List of parents and grandparents of DataClassification type. To
get the name of the type, simply take an element from the list use the &#8216;.name&#8217;.
&#64;rtype: list</p>
</dd></dl>

<dl class="method">
<dt id="AstroDataType.DataClassification.get_super_types">
<tt class="descname">get_super_types</tt><big>(</big><em>append_to=None</em><big>)</big><a class="headerlink" href="#AstroDataType.DataClassification.get_super_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of all immediate parents.</p>
<p>&#64;return: A List of parents of DataClassificationType. To
get the name of the type, simply take an element from the list use the &#8216;.name&#8217;.
&#64;rtype: list</p>
</dd></dl>

<dl class="method">
<dt id="AstroDataType.DataClassification.gvizNodes">
<tt class="descname">gvizNodes</tt><big>(</big><big>)</big><a class="headerlink" href="#AstroDataType.DataClassification.gvizNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>This function supports the automatic generation of a class graph
which is driven by the Classification Library. This function returns
a &#8220;dot language&#8221; representation of the node, which can contain things
such as an URL to click (we use SVG output), or any other information
about the node.
&#64;return: A representation of the node  in &#8220;dot&#8221; language for graphing purposes
&#64;rtype: String</p>
</dd></dl>

<dl class="method">
<dt id="AstroDataType.DataClassification.gviz_links">
<tt class="descname">gviz_links</tt><big>(</big><em>direct=None</em>, <em>assign_dict=None</em><big>)</big><a class="headerlink" href="#AstroDataType.DataClassification.gviz_links" title="Permalink to this definition">¶</a></dt>
<dd><p>This function supports the automatic generation of a class graph
driven by the Classification Library. This system builds a script
for &#8220;dot&#8221;.  The ClassifcationLibrary class handles the script template
and calls DataClassification functions to get the component strings.
Links are directed from parent type to sub type.
&#64;return: a string containing node links for dot script graph visualization
language
&#64;rtype: string</p>
</dd></dl>

<dl class="method">
<dt id="AstroDataType.DataClassification.gviz_node">
<tt class="descname">gviz_node</tt><big>(</big><big>)</big><a class="headerlink" href="#AstroDataType.DataClassification.gviz_node" title="Permalink to this definition">¶</a></dt>
<dd><p>This function supports the automatic generation of a class graph
which is driven by the Classification Library. This function returns
a &#8220;dot language&#8221; representation of the node, which can contain things
such as an URL to click (we use SVG output), or any other information
about the node.
&#64;return: A representation of the node  in &#8220;dot&#8221; language for graphing purposes
&#64;rtype: String</p>
</dd></dl>

<dl class="method">
<dt id="AstroDataType.DataClassification.html_doc">
<tt class="descname">html_doc</tt><big>(</big><big>)</big><a class="headerlink" href="#AstroDataType.DataClassification.html_doc" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns a string representation for an HTML table which documents this
particular classification using the definition itself. Note that the C{usage} member
of DataClassification is used to describe the use of this classification and will
be used to provide context and purpose of the classification
when generating the documentation.
&#64;return: HTML table
&#64;rtype: string</p>
</dd></dl>

<dl class="method">
<dt id="AstroDataType.DataClassification.html_edit_form">
<tt class="descname">html_edit_form</tt><big>(</big><big>)</big><a class="headerlink" href="#AstroDataType.DataClassification.html_edit_form" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns a full HTML block of text ready to present as a web form
to allow for online editing of types. This supports the browser/web based
editing interface for DataClassification types.
&#64;returns: a string containing an HTML form filled with default values taken
from this instance&#8217;s class members.
&#64;rtype: string</p>
</dd></dl>

<dl class="method">
<dt id="AstroDataType.DataClassification.is_subtype_of">
<tt class="descname">is_subtype_of</tt><big>(</big><em>supertype</em><big>)</big><a class="headerlink" href="#AstroDataType.DataClassification.is_subtype_of" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to check type relationships. For this type to be
a &#8220;subtype&#8221; of the given type both must occur in a linked tree.
A
node which is a relative leaf is a considered a subtype of its relative root.
This is used to resolve conflicts that can occur when objects, features
or subsystems are associated with a given classification. Since AstroData
instances generally have more than one classification which applies to them
and some associated objects, features, or subsystems require that
they are the only one ultimately associated with a particular AstroData
instance, such as is the case with Descriptors, this function is used
to correct the most common case of this, in which one of the types is
a subtype of the other, and therefore can be taken to override the
parent level association.
&#64;param supertype: string name for &#8220;supertype&#8221;
&#64;type supertype: string
&#64;rtype: Bool
&#64;returns: True if the classification detected by this DataClassification 
is subtype of the named C{supertype}.</p>
</dd></dl>

<dl class="method">
<dt id="AstroDataType.DataClassification.python_class">
<tt class="descname">python_class</tt><big>(</big><big>)</big><a class="headerlink" href="#AstroDataType.DataClassification.python_class" title="Permalink to this definition">¶</a></dt>
<dd><p>This function generates a DataClassification Class based on self.
The purpose of this is to support classification editors.
&#64;returns: a string containing python source code for this instance. Note, of 
course, if you add functions or members to a child class derived from
DataClassification, they will not be recognized by this function and
will not be represented in the outputed code.
&#64;rtype: string</p>
</dd></dl>

<dl class="method">
<dt id="AstroDataType.DataClassification.write_class">
<tt class="descname">write_class</tt><big>(</big><big>)</big><a class="headerlink" href="#AstroDataType.DataClassification.write_class" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates python code and writes it to fullpath if not protected.  Note, to
&#8220;protect&#8221; a file one must access the .py definition directly and set 
&#8216;editprotect = True.</p>
<p>NOTE: this is a fairly dangerous function to call, it will overwrite the file
from which this classification was originally loaded. This is intended only
to be called from DataClassification definition editors, presumably using
a dedicated server in which it is OK to perhaps stomp the original file,
considering one loses the previous file. That is, this is used in a 
browser based interface in which the code is under version control, and 
not used for image processing, but only to support the editor.  The revision
control gives us safety against stomping a classification by mistake,
and the fact that it is an isolated set of the code not used for data 
processing ensures that any mistakes do not affect our running system since
we do not check these changes in automatically, but do so manually after they 
can be checked.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="AstroDataType.LibraryNotLoaded">
<em class="property">class </em><tt class="descclassname">AstroDataType.</tt><tt class="descname">LibraryNotLoaded</tt><a class="headerlink" href="#AstroDataType.LibraryNotLoaded" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for raising a particular exceptions</p>
</dd></dl>

<div class="section" id="module-Calculator">
<span id="calculator"></span><h2><tt class="docutils literal"><span class="pre">Calculator</span></tt><a class="headerlink" href="#module-Calculator" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Calculator.Calculator">
<em class="property">class </em><tt class="descclassname">Calculator.</tt><tt class="descname">Calculator</tt><a class="headerlink" href="#Calculator.Calculator" title="Permalink to this definition">¶</a></dt>
<dd><p>The Descriptor Calculator in an object with one member fucntion for 
each descriptor (where descriptors are conceptually types of statistical
or other values which can be thought of as applying to all data. In practice
a descriptor might not be 100% general, it may apply only to a vast majority
of data types, or require some generic handling.
Though
in practice some descriptors may still not really apply to some data types
they will return a valid descriptor value (e.g. if there was an instrumen without
a filter wheel, data from that instrument would still return a sensible value
for the filter descriptor (&#8220;none&#8221; or &#8220;blank&#8221;).</p>
<p>A Calculator is associated with particular classifications of data, such that
it can be assigned to AstroData instances cooresponding to that classification.
It is important that configurations not lead to multiple Calculators associated
with one DataSet (this can happen since AstroData instances have more than one
classification can have a Calculator associated with it.  The system handles one
case of this where one of the two types contributing a Calculator is a subtype
of the other, in which case the system uses the subtypes descriptor, assuming it
&#8220;overrides&#8221; the other.  In any other case the system will throw and exception
when trying to assign the calculator to the AstroData instance.</p>
<p>&#64;note: the base class, besides being a parent class for defining new Calculators
is also the default Calculator for when none is specifically assigned. 
It uses &#8216;FITS_Keywords.py&#8217;
to map variables for descriptors to FITS specific header keywords, 
then does the retrieval from the headers in the dataset, as appropriate.
Ideally this method should work for all prepared data, at which point we would like
to have stored the standard values in the data header where it is directly retrieved
rather than calculated.</p>
<p>&#64;ivar usage: Used to document this Descriptor.</p>
</dd></dl>

<dl class="class">
<dt id="Calculator.CalculatorExcept">
<em class="property">class </em><tt class="descclassname">Calculator.</tt><tt class="descname">CalculatorExcept</tt><big>(</big><em>msg='Exception Raised in Descriptor system'</em><big>)</big><a class="headerlink" href="#Calculator.CalculatorExcept" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is an exception class for the Calculator module</p>
</dd></dl>

</div>
<div class="section" id="module-CalibrationDefinitionLibrary">
<span id="calibrationdefinitionlibrary"></span><h2><tt class="docutils literal"><span class="pre">CalibrationDefinitionLibrary</span></tt><a class="headerlink" href="#module-CalibrationDefinitionLibrary" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="CalibrationDefinitionLibrary.CalibrationDefinitionLibrary">
<em class="property">class </em><tt class="descclassname">CalibrationDefinitionLibrary.</tt><tt class="descname">CalibrationDefinitionLibrary</tt><a class="headerlink" href="#CalibrationDefinitionLibrary.CalibrationDefinitionLibrary" title="Permalink to this definition">¶</a></dt>
<dd><p>This class deals with obtaining request data from XML calibration files and generating 
the corresponding request.</p>
<dl class="method">
<dt id="CalibrationDefinitionLibrary.CalibrationDefinitionLibrary.OBSOLETE_update_xml_index">
<tt class="descname">OBSOLETE_update_xml_index</tt><big>(</big><big>)</big><a class="headerlink" href="#CalibrationDefinitionLibrary.CalibrationDefinitionLibrary.OBSOLETE_update_xml_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-updates the xml index, could be useful if this becomes long running and there are changes to
the xml files, etc.</p>
</dd></dl>

<dl class="method">
<dt id="CalibrationDefinitionLibrary.CalibrationDefinitionLibrary.generate_cal_index">
<tt class="descname">generate_cal_index</tt><big>(</big><em>caltype</em><big>)</big><a class="headerlink" href="#CalibrationDefinitionLibrary.CalibrationDefinitionLibrary.generate_cal_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a xml URI index for each caltype. This could seem kind of inefficient, but 
this is used to take advantage of the generalized utility function pick_config.</p>
<p>&#64;param caltype: The calibration needed to generate the index.
&#64;type caltype: string</p>
<p>&#64;return: Returns a dictionary of the form: {DataClassification.name:xmlFile}.
For example: {&#8216;GMOS&#8217;:&#8217;GMOS-bias.xml&#8217;,&#8217;NIRI&#8217;:&#8217;NIRI-bias.xml&#8217;}. 
&#64;rtype: dict</p>
</dd></dl>

<dl class="method">
<dt id="CalibrationDefinitionLibrary.CalibrationDefinitionLibrary.get_cal_req">
<tt class="descname">get_cal_req</tt><big>(</big><em>inputs</em>, <em>caltype</em>, <em>write_input=False</em><big>)</big><a class="headerlink" href="#CalibrationDefinitionLibrary.CalibrationDefinitionLibrary.get_cal_req" title="Permalink to this definition">¶</a></dt>
<dd><p>For each input finds astrodata type to find corresponding xml file,
loads the file.</p>
<p>&#64;param inputs: list of input fits AstroData instances
&#64;type inputs: list</p>
<p>&#64;param caltype: Calibration, ie bias, flat, dark, etc.
&#64;type caltype: string</p>
<p>&#64;return: Returns a list of Calibration Request Events.
&#64;rtype: list</p>
</dd></dl>

<dl class="method">
<dt id="CalibrationDefinitionLibrary.CalibrationDefinitionLibrary.parse_property">
<tt class="descname">parse_property</tt><big>(</big><em>property_node</em>, <em>desc</em>, <em>ad</em><big>)</big><a class="headerlink" href="#CalibrationDefinitionLibrary.CalibrationDefinitionLibrary.parse_property" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a xmldom property, returning a {key:(extension,elemType,value)}.</p>
<p>&#64;param property_node: xmlDom Element, that should be a &#8216;property&#8217;. Consult the xml calibration file
definitions for more information.
&#64;type property_node:  Dom Element</p>
<p>&#64;param desc: Descriptor for the type ad.
&#64;type desc: Calculator</p>
<p>&#64;param ad: An Astrodata instance for the input file.
&#64;type ad: Astrodata instance</p>
<p>&#64;return: {key:(extension,elemType,value)}, based of calibration xml attributes.
&#64;rtype: dict</p>
</dd></dl>

<dl class="method">
<dt id="CalibrationDefinitionLibrary.CalibrationDefinitionLibrary.parse_query">
<tt class="descname">parse_query</tt><big>(</big><em>xml_dom_query_node</em>, <em>caltype</em>, <em>inputf</em><big>)</big><a class="headerlink" href="#CalibrationDefinitionLibrary.CalibrationDefinitionLibrary.parse_query" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a query from XML Calibration File and returns a Calibration
request event with the corresponding information. Unfinished: priority 
parsing value</p>
<p>&#64;param xml_dom_query_node: a query XML Dom Node; ie &lt;DOM Element: query at 0x921392c&gt;
&#64;type xml_dom_query_node: Dom Element</p>
<p>&#64;param caltype: Calibration, ie bias, flat, dark, etc.
&#64;type caltype: string</p>
<p>&#64;param input: an input fits URI
&#64;type input: string</p>
<p>&#64;return: Returns a Calibration Request Event.
&#64;rtype: CalibrationRequestEvent</p>
</dd></dl>

<dl class="method">
<dt id="CalibrationDefinitionLibrary.CalibrationDefinitionLibrary.str_property">
<tt class="descname">str_property</tt><big>(</big><em>prop</em><big>)</big><a class="headerlink" href="#CalibrationDefinitionLibrary.CalibrationDefinitionLibrary.str_property" title="Permalink to this definition">¶</a></dt>
<dd><p>A cleaner way to print properties out.</p>
<p>&#64;param prop: A property as defined by the xml schema.
&#64;type prop: dict</p>
<p>&#64;return: A clean, one line property.
&#64;rtype: str</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-ConfigSpace">
<span id="config-space"></span><h2><tt class="docutils literal"><span class="pre">config</span> <span class="pre">space</span></tt><a class="headerlink" href="#module-ConfigSpace" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="ConfigSpace.ConfigSpace">
<em class="property">class </em><tt class="descclassname">ConfigSpace.</tt><tt class="descname">ConfigSpace</tt><a class="headerlink" href="#ConfigSpace.ConfigSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>This class exists to connect to a configuration space, such as 
AstroDataType libraries or Descriptors. It provides tools to simplify 
accessing configuration information and also providing indirection to
allow configurations to be stored with alternate storage methodologies,
such as in relational databases.  This flexibility is useful due to the
many deployment contexts of the Gemini Reduction Package.</p>
<dl class="method">
<dt id="ConfigSpace.ConfigSpace.config_walk">
<tt class="descname">config_walk</tt><big>(</big><em>spacename</em><big>)</big><a class="headerlink" href="#ConfigSpace.ConfigSpace.config_walk" title="Permalink to this definition">¶</a></dt>
<dd><p>This function can be iterated over in the style of os.walk()
&#64;param spacename: name of the space, &#8220;types&#8221;, &#8220;statustypes&#8221;,
&#8220;descriptors&#8221;, or &#8220;structures&#8221;.
&#64;param spacename: string
&#64;returns: via yeild, a (root, dirn, files) tuple</p>
</dd></dl>

<dl class="method">
<dt id="ConfigSpace.ConfigSpace.general_walk">
<tt class="descname">general_walk</tt><big>(</big><em>dir</em>, <em>exts=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#ConfigSpace.ConfigSpace.general_walk" title="Permalink to this definition">¶</a></dt>
<dd><p>A generalized walk, that ignores all the .svn / .cvs folders. I found this can be a little useful, 
although it will probably be thrown out at some point.</p>
<p>&#64;param path: Root path to throw in os.walk.
&#64;type path: str</p>
<p>&#64;param exts: list of valid type extensions to process. If exts is left as [], then everything is valid.
the exts should be supplied in the form [&#8221;.fits&#8221;,&#8221;.log&#8221;,&#8221;.jpg&#8221;].
&#64;type exts: list of str</p>
<p>&#64;return: Basically, takes the output of os.walk, but without the .svn stuff.
&#64;rtype: yields a 3-tuple (dirpath, dirnames, filenames).</p>
</dd></dl>

<dl class="method">
<dt id="ConfigSpace.ConfigSpace.get_config_dirs">
<tt class="descname">get_config_dirs</tt><big>(</big><em>spacename</em><big>)</big><a class="headerlink" href="#ConfigSpace.ConfigSpace.get_config_dirs" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns a list of directories to walk for a given 
configuration space.
&#64;param spacename: name of the config space to collect directories for
&#64;type spacename: string
&#64;returns: list of directories
&#64;rtype: list</p>
</dd></dl>

<dl class="method">
<dt id="ConfigSpace.ConfigSpace.get_recipe_dirs">
<tt class="descname">get_recipe_dirs</tt><big>(</big><big>)</big><a class="headerlink" href="#ConfigSpace.ConfigSpace.get_recipe_dirs" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns a list of directories to walk for a given 
configuration space.
&#64;param spacename: name of the config space to collect directories for
&#64;type spacename: string
&#64;returns: list of directories
&#64;rtype: list</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ConfigSpace.ConfigSpaceExcept">
<em class="property">class </em><tt class="descclassname">ConfigSpace.</tt><tt class="descname">ConfigSpaceExcept</tt><big>(</big><em>msg='Exception Raised in ConfigSpace system'</em><big>)</big><a class="headerlink" href="#ConfigSpace.ConfigSpaceExcept" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is an exception class for the ConfigSpace module</p>
</dd></dl>

<dl class="function">
<dt id="ConfigSpace.lookup_path">
<tt class="descclassname">ConfigSpace.</tt><tt class="descname">lookup_path</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#ConfigSpace.lookup_path" title="Permalink to this definition">¶</a></dt>
<dd><p>This module level function takes a lookup name and returns a path to the file.</p>
</dd></dl>

</div>
<div class="section" id="module-DataSpider">
<span id="data-spider"></span><h2><tt class="docutils literal"><span class="pre">data</span> <span class="pre">spider</span></tt><a class="headerlink" href="#module-DataSpider" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="DataSpider.DataSpider">
<em class="property">class </em><tt class="descclassname">DataSpider.</tt><tt class="descname">DataSpider</tt><big>(</big><em>context=None</em><big>)</big><a class="headerlink" href="#DataSpider.DataSpider" title="Permalink to this definition">¶</a></dt>
<dd><p>DataSpider() is a work class to encapsulate
reusable code to work the AstroData related classes.
e.g. it will walk a directory using AstroData
to check type sizes.</p>
<dl class="method">
<dt id="DataSpider.DataSpider.datasetwalk">
<tt class="descname">datasetwalk</tt><big>(</big><em>directory='.'</em>, <em>only='all'</em>, <em>pheads=None</em>, <em>showinfo=False</em>, <em>onlyStatus=False</em>, <em>onlyTypology=False</em>, <em>showDescriptors=None</em>, <em>filemask=None</em>, <em>showCals=False</em>, <em>incolog=True</em>, <em>stayTop=False</em>, <em>recipe=None</em>, <em>raiseExcept=False</em>, <em>where=None</em>, <em>batchnum=None</em>, <em>opti=None</em><big>)</big><a class="headerlink" href="#DataSpider.DataSpider.datasetwalk" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively walk a given directory and put type information to stdout</p>
</dd></dl>

<dl class="method">
<dt id="DataSpider.DataSpider.typewalk">
<tt class="descname">typewalk</tt><big>(</big><em>directory='.'</em>, <em>only='all'</em>, <em>pheads=None</em>, <em>showinfo=False</em>, <em>onlyStatus=False</em>, <em>onlyTypology=False</em>, <em>showDescriptors=None</em>, <em>filemask=None</em>, <em>showCals=False</em>, <em>incolog=True</em>, <em>stayTop=False</em>, <em>recipe=None</em>, <em>raiseExcept=False</em>, <em>where=None</em>, <em>batchnum=None</em>, <em>opti=None</em><big>)</big><a class="headerlink" href="#DataSpider.DataSpider.typewalk" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively walk a given directory and put type information to stdout</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-Descriptors">
<span id="descriptor"></span><h2><tt class="docutils literal"><span class="pre">Descriptor</span></tt><a class="headerlink" href="#module-Descriptors" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="Descriptors.get_calculator">
<tt class="descclassname">Descriptors.</tt><tt class="descname">get_calculator</tt><big>(</big><em>dataset</em><big>)</big><a class="headerlink" href="#Descriptors.get_calculator" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets the Calculator instance appropriate for 
the specified dataset.
Conflicts, arising from Calculators being associated with more than one
AstroData type classification, are resolved by traversing the type tree to
see if one type is a subtype of the other so the more specific type can be
used.
&#64;param dataset: the dataset to load a calculator for
&#64;type dataset: AstroData
&#64;returns: the appropriate Calculator instance for this type of dataset
&#64;rtype: Calculator</p>
<dl class="docutils">
<dt>&#64;note: OPEN ISSUE: how to deal with conflicts not resolved this way... i.e.</dt>
<dd>if there are two assignments related to types which do not appear
in the same type trees.</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-Errors">
<span id="errors"></span><h2><tt class="docutils literal"><span class="pre">Errors</span></tt><a class="headerlink" href="#module-Errors" title="Permalink to this headline">¶</a></h2>
<dl class="exception">
<dt id="Errors.ArithError">
<em class="property">exception </em><tt class="descclassname">Errors.</tt><tt class="descname">ArithError</tt><big>(</big><em>message=None</em><big>)</big><a class="headerlink" href="#Errors.ArithError" title="Permalink to this definition">¶</a></dt>
<dd><p>For general Exceptions raised within the arith.py toolbox</p>
</dd></dl>

<dl class="exception">
<dt id="Errors.AstroDataError">
<em class="property">exception </em><tt class="descclassname">Errors.</tt><tt class="descname">AstroDataError</tt><big>(</big><em>message=None</em><big>)</big><a class="headerlink" href="#Errors.AstroDataError" title="Permalink to this definition">¶</a></dt>
<dd><p>For general Exceptions raised in the AstroData Class Module</p>
</dd></dl>

<dl class="exception">
<dt id="Errors.AstroDataReadonlyError">
<em class="property">exception </em><tt class="descclassname">Errors.</tt><tt class="descname">AstroDataReadonlyError</tt><big>(</big><em>message=None</em><big>)</big><a class="headerlink" href="#Errors.AstroDataReadonlyError" title="Permalink to this definition">¶</a></dt>
<dd><p>For general Exceptions raised in the AstroData Class Module</p>
</dd></dl>

<dl class="exception">
<dt id="Errors.CalcError">
<em class="property">exception </em><tt class="descclassname">Errors.</tt><tt class="descname">CalcError</tt><big>(</big><em>message=None</em><big>)</big><a class="headerlink" href="#Errors.CalcError" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception raised for instances when the keyword required for calculation
within a descriptor function is found but the descriptor code is unable to
calculate and return a value</p>
</dd></dl>

<dl class="exception">
<dt id="Errors.CalibrationDefinitionLibraryError">
<em class="property">exception </em><tt class="descclassname">Errors.</tt><tt class="descname">CalibrationDefinitionLibraryError</tt><big>(</big><em>message=None</em><big>)</big><a class="headerlink" href="#Errors.CalibrationDefinitionLibraryError" title="Permalink to this definition">¶</a></dt>
<dd><p>Exceptions raised for CallibrationDefinitionLibrary.py</p>
</dd></dl>

<dl class="exception">
<dt id="Errors.CollapseError">
<em class="property">exception </em><tt class="descclassname">Errors.</tt><tt class="descname">CollapseError</tt><big>(</big><em>message=None</em><big>)</big><a class="headerlink" href="#Errors.CollapseError" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception raised for instances when the values for a given EXTVER are not
the same</p>
</dd></dl>

<dl class="exception">
<dt id="Errors.CorruptDataError">
<em class="property">exception </em><tt class="descclassname">Errors.</tt><tt class="descname">CorruptDataError</tt><big>(</big><em>message=None</em><big>)</big><a class="headerlink" href="#Errors.CorruptDataError" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception raised for instances when an AstroData object does not contain
any pixel data extensions</p>
</dd></dl>

<dl class="exception">
<dt id="Errors.DescriptorError">
<em class="property">exception </em><tt class="descclassname">Errors.</tt><tt class="descname">DescriptorError</tt><big>(</big><em>message=None</em><big>)</big><a class="headerlink" href="#Errors.DescriptorError" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for descriptor exceptions</p>
</dd></dl>

<dl class="exception">
<dt id="Errors.DescriptorTypeError">
<em class="property">exception </em><tt class="descclassname">Errors.</tt><tt class="descname">DescriptorTypeError</tt><big>(</big><em>message=None</em><big>)</big><a class="headerlink" href="#Errors.DescriptorTypeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception raised for instances when a descriptor function cannot return a
value for a given AstroData Type i.e., dispersion_axis for IMAGE data</p>
</dd></dl>

<dl class="exception">
<dt id="Errors.DescriptorsError">
<em class="property">exception </em><tt class="descclassname">Errors.</tt><tt class="descname">DescriptorsError</tt><big>(</big><em>message=None</em><big>)</big><a class="headerlink" href="#Errors.DescriptorsError" title="Permalink to this definition">¶</a></dt>
<dd><p>For general exceptions raised in the Descriptors.py module</p>
</dd></dl>

<dl class="exception">
<dt id="Errors.EmptyKeyError">
<em class="property">exception </em><tt class="descclassname">Errors.</tt><tt class="descname">EmptyKeyError</tt><big>(</big><em>message=None</em><big>)</big><a class="headerlink" href="#Errors.EmptyKeyError" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception raised for errors when a PHU keyword was found to but was empty
or &#8216; &#8216;.</p>
</dd></dl>

<dl class="exception">
<dt id="Errors.Error">
<em class="property">exception </em><tt class="descclassname">Errors.</tt><tt class="descname">Error</tt><big>(</big><em>message=None</em><big>)</big><a class="headerlink" href="#Errors.Error" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for exceptions in this module.</p>
</dd></dl>

<dl class="exception">
<dt id="Errors.ExistError">
<em class="property">exception </em><tt class="descclassname">Errors.</tt><tt class="descname">ExistError</tt><big>(</big><em>message=None</em><big>)</big><a class="headerlink" href="#Errors.ExistError" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception raised for instances when a descriptor doesn&#8217;t exist for a
particular instrument</p>
</dd></dl>

<dl class="exception">
<dt id="Errors.ExtTableError">
<em class="property">exception </em><tt class="descclassname">Errors.</tt><tt class="descname">ExtTableError</tt><big>(</big><em>message=None</em><big>)</big><a class="headerlink" href="#Errors.ExtTableError" title="Permalink to this definition">¶</a></dt>
<dd><p>General exception raised for Errors in ExtTable.py</p>
</dd></dl>

<dl class="exception">
<dt id="Errors.FatalDeprecation">
<em class="property">exception </em><tt class="descclassname">Errors.</tt><tt class="descname">FatalDeprecation</tt><big>(</big><em>message=None</em><big>)</big><a class="headerlink" href="#Errors.FatalDeprecation" title="Permalink to this definition">¶</a></dt>
<dd><p>Raised when code that isn&#8217;t supposed to be called anymore is called anyway.</p>
</dd></dl>

<dl class="exception">
<dt id="Errors.IncompatibleOperand">
<em class="property">exception </em><tt class="descclassname">Errors.</tt><tt class="descname">IncompatibleOperand</tt><big>(</big><em>message=None</em><big>)</big><a class="headerlink" href="#Errors.IncompatibleOperand" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception raised when the other operand in a DescriptorValue binary 
operator does not have the required operator.</p>
</dd></dl>

<dl class="exception">
<dt id="Errors.InputError">
<em class="property">exception </em><tt class="descclassname">Errors.</tt><tt class="descname">InputError</tt><big>(</big><em>message=None</em><big>)</big><a class="headerlink" href="#Errors.InputError" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception raised for instances when an input value is invalid. This
includes whether it is None or empty</p>
</dd></dl>

<dl class="exception">
<dt id="Errors.InvalidValueError">
<em class="property">exception </em><tt class="descclassname">Errors.</tt><tt class="descname">InvalidValueError</tt><big>(</big><em>message=None</em><big>)</big><a class="headerlink" href="#Errors.InvalidValueError" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception raised for instances when the keyword required for calculation
within a descriptor function is found but the value of the keyword has an
invalid value (as determined by the validation code within the descriptor
function)</p>
</dd></dl>

<dl class="exception">
<dt id="Errors.MatchShapeError">
<em class="property">exception </em><tt class="descclassname">Errors.</tt><tt class="descname">MatchShapeError</tt><big>(</big><em>message=None</em><big>)</big><a class="headerlink" href="#Errors.MatchShapeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception raised for instances when two arrays do not match in shape</p>
</dd></dl>

<dl class="exception">
<dt id="Errors.OutputError">
<em class="property">exception </em><tt class="descclassname">Errors.</tt><tt class="descname">OutputError</tt><big>(</big><em>message=None</em><big>)</big><a class="headerlink" href="#Errors.OutputError" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception raised for instances when an output value is None or empty</p>
</dd></dl>

<dl class="exception">
<dt id="Errors.PrimInspectError">
<em class="property">exception </em><tt class="descclassname">Errors.</tt><tt class="descname">PrimInspectError</tt><big>(</big><em>message=None</em><big>)</big><a class="headerlink" href="#Errors.PrimInspectError" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception raised for general errors inside PrimInspect.py.</p>
</dd></dl>

<dl class="exception">
<dt id="Errors.PrimitiveError">
<em class="property">exception </em><tt class="descclassname">Errors.</tt><tt class="descname">PrimitiveError</tt><big>(</big><em>message=None</em><big>)</big><a class="headerlink" href="#Errors.PrimitiveError" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception raised for general errors inside of a primitive.</p>
</dd></dl>

<dl class="exception">
<dt id="Errors.ReduceError">
<em class="property">exception </em><tt class="descclassname">Errors.</tt><tt class="descname">ReduceError</tt><big>(</big><em>message=None</em><big>)</big><a class="headerlink" href="#Errors.ReduceError" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception raised for general errors in reduce.py</p>
</dd></dl>

<dl class="exception">
<dt id="Errors.ScienceError">
<em class="property">exception </em><tt class="descclassname">Errors.</tt><tt class="descname">ScienceError</tt><big>(</big><em>message=None</em><big>)</big><a class="headerlink" href="#Errors.ScienceError" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception raised for general errors inside of a user level &#8216;science&#8217;
function.</p>
</dd></dl>

<dl class="exception">
<dt id="Errors.TableKeyError">
<em class="property">exception </em><tt class="descclassname">Errors.</tt><tt class="descname">TableKeyError</tt><big>(</big><em>message=None</em><big>)</big><a class="headerlink" href="#Errors.TableKeyError" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception raised for instances when a key cannot be matched in a lookup
table</p>
</dd></dl>

<dl class="exception">
<dt id="Errors.TableValueError">
<em class="property">exception </em><tt class="descclassname">Errors.</tt><tt class="descname">TableValueError</tt><big>(</big><em>message=None</em><big>)</big><a class="headerlink" href="#Errors.TableValueError" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception raised for instances when a value cannot be found in a lookup
table</p>
</dd></dl>

<dl class="exception">
<dt id="Errors.ToolboxError">
<em class="property">exception </em><tt class="descclassname">Errors.</tt><tt class="descname">ToolboxError</tt><big>(</big><em>message=None</em><big>)</big><a class="headerlink" href="#Errors.ToolboxError" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception raised for general errors inside of a &#8216;toolbox&#8217; function.</p>
</dd></dl>

<dl class="exception">
<dt id="Errors.UndefinedKeyError">
<em class="property">exception </em><tt class="descclassname">Errors.</tt><tt class="descname">UndefinedKeyError</tt><big>(</big><em>message=None</em><big>)</big><a class="headerlink" href="#Errors.UndefinedKeyError" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception raised for errors when a PHU keyword has a value that is 
pyfits.core.Undefined</p>
</dd></dl>

<dl class="exception">
<dt id="Errors.gemutilError">
<em class="property">exception </em><tt class="descclassname">Errors.</tt><tt class="descname">gemutilError</tt><big>(</big><em>message=None</em><big>)</big><a class="headerlink" href="#Errors.gemutilError" title="Permalink to this definition">¶</a></dt>
<dd><p>General exception raised for Errors in adutils/gemutil.py</p>
</dd></dl>

</div>
<div class="section" id="module-IDFactory">
<span id="idfactory"></span><h2><tt class="docutils literal"><span class="pre">Idfactory</span></tt><a class="headerlink" href="#module-IDFactory" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="IDFactory.generate_astro_data_id">
<tt class="descclassname">IDFactory.</tt><tt class="descname">generate_astro_data_id</tt><big>(</big><em>dataset</em>, <em>version='1_0'</em><big>)</big><a class="headerlink" href="#IDFactory.generate_astro_data_id" title="Permalink to this definition">¶</a></dt>
<dd><p>An id to be used to identify AstroData types. This is used for:</p>
<ol class="arabic simple">
<li>Calibrations:</li>
</ol>
<p>Let&#8217;s say a recipe performs</p>
<p>getProcessedBias</p>
<p>prepare
biasCorrect</p>
<p>Because of the prepare step, the calibration key determined at getProcessedBias will not 
match biasCorrect because (N2009..., bias) will not match (gN2009..., bias). By using an astro_id,
you can avoid this issue as you will have (DATALAB, bias). So, any steps inbetween getProcessedBias and
biasCorrect will have no impact.</p>
<ol class="arabic simple" start="2">
<li>Fringe:</li>
</ol>
<p>Fringe uses this as a FringeID, which is based off the first input of the list.</p>
<p>&#64;param dataset: Input AstroData instance or fits filename.
&#64;type dataset: AstroData instances or str</p>
<p>&#64;param version: The version from which to run.
&#64;type version: string</p>
<p>&#64;return: An astrodata id.
&#64;rtype: string</p>
</dd></dl>

<dl class="function">
<dt id="IDFactory.generate_display_id">
<tt class="descclassname">IDFactory.</tt><tt class="descname">generate_display_id</tt><big>(</big><em>dataset</em>, <em>version</em><big>)</big><a class="headerlink" href="#IDFactory.generate_display_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an ID from which all similar stackable data will have in common.</p>
<p>&#64;param dataset: Input AstroData or fits filename
&#64;type dataset: list of AstroData instance</p>
<p>&#64;param version: The version from which to run.
&#64;type version: string</p>
<p>&#64;return: A display id.
&#64;rtype: string</p>
</dd></dl>

<dl class="function">
<dt id="IDFactory.generate_fringe_list_id">
<tt class="descclassname">IDFactory.</tt><tt class="descname">generate_fringe_list_id</tt><big>(</big><em>dataset</em>, <em>version='1_0'</em><big>)</big><a class="headerlink" href="#IDFactory.generate_fringe_list_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an id from which all similar stackable data will have in common.</p>
<p>&#64;param dataset: Input AstroData instance or fits filename.
&#64;type dataset: AstroData instances or str</p>
<p>&#64;param version: The version from which to run.
&#64;type version: string</p>
<p>&#64;return: A stackable id.
&#64;rtype: string</p>
</dd></dl>

<dl class="function">
<dt id="IDFactory.generate_stackable_id">
<tt class="descclassname">IDFactory.</tt><tt class="descname">generate_stackable_id</tt><big>(</big><em>dataset</em>, <em>version='1_0'</em><big>)</big><a class="headerlink" href="#IDFactory.generate_stackable_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an ID from which all similar stackable data will have in common.</p>
<p>&#64;param dataset: Input AstroData instance or fits filename.
&#64;type dataset: AstroData instances or str</p>
<p>&#64;param version: The version from which to run.
&#64;type version: string</p>
<p>&#64;return: A stackable id.
&#64;rtype: string</p>
</dd></dl>

</div>
<div class="section" id="module-LocalCalibrationService">
<span id="local-calibration-service"></span><h2><tt class="docutils literal"><span class="pre">Local</span> <span class="pre">Calibration</span> <span class="pre">service</span></tt><a class="headerlink" href="#module-LocalCalibrationService" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="LocalCalibrationService.CalibrationService">
<em class="property">class </em><tt class="descclassname">LocalCalibrationService.</tt><tt class="descname">CalibrationService</tt><big>(</big><em>cal_directory_uris=['.'], mode='local_disk'</em><big>)</big><a class="headerlink" href="#LocalCalibrationService.CalibrationService" title="Permalink to this definition">¶</a></dt>
<dd><p>Theoretically, if this is implemented, the search algorithms and retrieval will be here.</p>
<dl class="method">
<dt id="LocalCalibrationService.CalibrationService.compare_property">
<tt class="descname">compare_property</tt><big>(</big><em>prop</em>, <em>desc</em>, <em>ad</em><big>)</big><a class="headerlink" href="#LocalCalibrationService.CalibrationService.compare_property" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares a property (in xml calibration sense), to the headers of a calibration fits file.</p>
<p>&#64;param property: An xml calibration property of the form {Compare: (HeaderExt, type, Value)}
&#64;type property: dict</p>
<p>&#64;param headers: The list of headers. This should be [PHU, EXT1, EXT2, EXT3, ...etc]
&#64;type headers: list</p>
<p>&#64;return: The difference of the values if non-string, or True or False if string.
&#64;type: int, float, or None</p>
</dd></dl>

<dl class="method">
<dt id="LocalCalibrationService.CalibrationService.convertGemToUnixTime">
<tt class="descname">convertGemToUnixTime</tt><big>(</big><em>date</em>, <em>format='%Y-%m-%dT%H:%M:%S'</em><big>)</big><a class="headerlink" href="#LocalCalibrationService.CalibrationService.convertGemToUnixTime" title="Permalink to this definition">¶</a></dt>
<dd><p>This should convert a gemini time (in fits header) to a unix float time.</p>
</dd></dl>

<dl class="method">
<dt id="LocalCalibrationService.CalibrationService.get_compare_info">
<tt class="descname">get_compare_info</tt><big>(</big><em>prop</em><big>)</big><a class="headerlink" href="#LocalCalibrationService.CalibrationService.get_compare_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpacks the calibration request dict and tuple.</p>
</dd></dl>

<dl class="method">
<dt id="LocalCalibrationService.CalibrationService.process_request">
<tt class="descname">process_request</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#LocalCalibrationService.CalibrationService.process_request" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="LocalCalibrationService.CalibrationService.run">
<tt class="descname">run</tt><big>(</big><big>)</big><a class="headerlink" href="#LocalCalibrationService.CalibrationService.run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="LocalCalibrationService.CalibrationService.search">
<tt class="descname">search</tt><big>(</big><em>cal_rq</em><big>)</big><a class="headerlink" href="#LocalCalibrationService.CalibrationService.search" title="Permalink to this definition">¶</a></dt>
<dd><p>Searches the various fits files collecting valid calibrations and eventually returning a
sorted list of based on the priorities.</p>
<p>&#64;param cal_rq: The Calibration Request. For this localized version, it contains only the most
critical information, but on the PRS, this would be a message.
&#64;type cal_rq: CalibrationRequest instance.</p>
<p>&#64;return: A sorted list of calibration pathnames.
&#64;rtype: list</p>
</dd></dl>

<dl class="method">
<dt id="LocalCalibrationService.CalibrationService.search_criteria">
<tt class="descname">search_criteria</tt><big>(</big><em>criteria</em>, <em>desc</em>, <em>ad</em>, <em>err=400000.0</em><big>)</big><a class="headerlink" href="#LocalCalibrationService.CalibrationService.search_criteria" title="Permalink to this definition">¶</a></dt>
<dd><p>Will perform the &#8216;criteria&#8217; search  &#8211; matching values must be identical or within tolerable error.</p>
<p>&#64;param identifiers: The identifier section from the request.
&#64;type identifiers: dict</p>
<p>&#64;param headers: List with all the headers for the fits file currently being searched.
&#64;type headers: list</p>
<p>&#64;param err: Theoretically, this might be used as some sort of below err threshhold in order for 
it to be considered.
&#64;type err: float</p>
<p>&#64;return: True if all match, False otherwise.
&#64;rtype: boolean</p>
</dd></dl>

<dl class="method">
<dt id="LocalCalibrationService.CalibrationService.search_identifiers">
<tt class="descname">search_identifiers</tt><big>(</big><em>identifiers</em>, <em>desc</em>, <em>ad</em><big>)</big><a class="headerlink" href="#LocalCalibrationService.CalibrationService.search_identifiers" title="Permalink to this definition">¶</a></dt>
<dd><p>Will perform the &#8216;identifier&#8217; search  &#8211; matching values must be identical.</p>
<p>&#64;param identifiers: The identifier section from the request.
&#64;type identifiers: dict</p>
<p>&#64;param headers: List with all the headers for the fits file currently being searched.
&#64;type headers: list</p>
<p>&#64;return: True if all match, False otherwise.
&#64;rtype: boolean</p>
</dd></dl>

<dl class="method">
<dt id="LocalCalibrationService.CalibrationService.sort_priority">
<tt class="descname">sort_priority</tt><big>(</big><em>listoffits</em>, <em>priorities</em><big>)</big><a class="headerlink" href="#LocalCalibrationService.CalibrationService.sort_priority" title="Permalink to this definition">¶</a></dt>
<dd><p>Will sort the listoffits based on the priorities.       .</p>
<p>&#64;param listoffits: A list with a tuple containing the (calibration filename, Descriptor, Astrodata).
This seems a bit &#8216;perlish&#8217;, but it makes the most sense at the time of creating this comment.
&#64;type listoffits: list</p>
<p>&#64;param priorities: Priorities from xml calibration file.
&#64;type priorities: dict</p>
<p>&#64;return: The sorted urllist (just the list of calibration URLs).
&#64;rtype: list</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-Lookups">
<span id="lookups"></span><h2><tt class="docutils literal"><span class="pre">Lookups</span></tt><a class="headerlink" href="#module-Lookups" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="Lookups.get_lookup_table">
<tt class="descclassname">Lookups.</tt><tt class="descname">get_lookup_table</tt><big>(</big><em>modname</em>, <em>*lookup</em><big>)</big><a class="headerlink" href="#Lookups.get_lookup_table" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>get_lookup_table() is used to get lookup table style sets of variables</dt>
<dd>from a common facility, allowing the storage in common (global) space
so that multiple scripts can refer to one lookup table
without having to manage where this table is stored.  E.g. the Calculator
(see L{Descriptors}) for NIRI data requires a NIRI lookup table that
other parts of the package, unrelated to Descriptors, also need to 
access.  This facility saves these separate components from knowing
where the configuration is actually stored, or even that other
parts of the system are relying on it, and ensure that changes will
affect every part of the system.</dd>
<dt>&#64;param modname: namespace specifier for the table... in default case this</dt>
<dd>is the directory and file name of the module in which the lookup
table is stored, and the file is pure python.  However, the Lookups
module can redirect this, using the modname, for example, as a
key to find the lookup table in a database or elsewhere. Nothing like
the latter is done at this time, and what is loaded are pure python
files (e.g. a dict definition) from disk.</dd>
</dl>
<p>&#64;type modname: string
&#64;param lookup: name of the lookup table to load
&#64;type lookup: string</p>
</dd></dl>

</div>
<div class="section" id="module-ParamObject">
<span id="param-object"></span><h2><tt class="docutils literal"><span class="pre">Param</span> <span class="pre">object</span></tt><a class="headerlink" href="#module-ParamObject" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="ParamObject.PrimitiveParameter">
<em class="property">class </em><tt class="descclassname">ParamObject.</tt><tt class="descname">PrimitiveParameter</tt><big>(</big><em>name</em>, <em>overwrite=False</em>, <em>helps=''</em>, <em>value=None</em><big>)</big><a class="headerlink" href="#ParamObject.PrimitiveParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the object which contains all relevant variables where primitive parameter data is stored.</p>
</dd></dl>

</div>
<div class="section" id="module-RecipeManager">
<span id="recipe-manager"></span><h2><tt class="docutils literal"><span class="pre">Recipe</span> <span class="pre">manager</span></tt><a class="headerlink" href="#module-RecipeManager" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="RecipeManager.RecipeExcept">
<em class="property">class </em><tt class="descclassname">RecipeManager.</tt><tt class="descname">RecipeExcept</tt><big>(</big><em>msg='Exception Raised in Recipe System'</em>, <em>**argv</em><big>)</big><a class="headerlink" href="#RecipeManager.RecipeExcept" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the general exception the classes and functions in the
Structures.py module raise.</p>
</dd></dl>

<dl class="class">
<dt id="RecipeManager.ReductionContext">
<em class="property">class </em><tt class="descclassname">RecipeManager.</tt><tt class="descname">ReductionContext</tt><big>(</big><em>adcc_mode='start_early'</em><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext" title="Permalink to this definition">¶</a></dt>
<dd><p>The ReductionContext is used by primitives and recipies, implicitely in the
later case, to get input and report output. This allows primitives to be
controlled in many different running environments, from pipelines to command
line interactive reduction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Sort :</th><td class="field-body">__init__,__contains__,__getitem__,__str__,
_*,a*,b*,c*,d*,e*,f*,g*,h*,i*,j*,k*,l*,m*,n*,o*,p*,q*,r*,
s*,t*,u*,v*,w*,x*,y*,z*</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="RecipeManager.ReductionContext.add_cal">
<tt class="descname">add_cal</tt><big>(</big><em>data</em>, <em>caltyp</em>, <em>calname</em>, <em>timestamp=None</em><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.add_cal" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> (<em>str or AstroData instance</em>) &#8211; The path or AstroData for which the calibration will be applied to.</li>
<li><strong>caltyp</strong> (<em>str</em>) &#8211; The type of calibration. For example, &#8216;bias&#8217; and &#8216;flat&#8217;.</li>
<li><strong>calname</strong> (<em>str</em>) &#8211; The URI for the MEF calibration file.</li>
<li><strong>timestamp</strong> &#8211; Default= None. Timestamp for when calibration was added.
The format of time is</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>taken from datetime.datetime.
:type timestamp: str</p>
<p>Add a calibration to the calibration index with a key related to the
dataset&#8217;s &#8220;datalabel&#8221;, so it will apply, generally to later, processed
versions of the dataset, and thus allow retrieval of the same calibration.</p>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.add_input">
<tt class="descname">add_input</tt><big>(</big><em>filenames</em><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.add_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Add input to be processed the next batch around. If this is the first
input being added, it is also added to original_inputs.</p>
<p>&#64;param filenames: Inputs you want added.
&#64;type filenames: list, AstroData, str</p>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.add_rq">
<tt class="descname">add_rq</tt><big>(</big><em>rq</em><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.add_rq" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a request to be evaluated by the control loop.</p>
<p>&#64;param rq: The request.
&#64;type rq: ReductionObjectRequests instance</p>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.cal_filename">
<tt class="descname">cal_filename</tt><big>(</big><em>caltype</em><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.cal_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a local filename for a retrieved calibration</p>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.clear_rqs">
<tt class="descname">clear_rqs</tt><big>(</big><em>rtype=None</em><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.clear_rqs" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear all requests.</p>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.finalize_outputs">
<tt class="descname">finalize_outputs</tt><big>(</big><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.finalize_outputs" title="Permalink to this definition">¶</a></dt>
<dd><p>This function means there are no more outputs, generally called
in a control loop when a generator function primitive ends.  Standard
outputs become the new inputs. Calibrations and non-standard output
is not affected.</p>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.get_cal">
<tt class="descname">get_cal</tt><big>(</big><em>data</em>, <em>caltype</em><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.get_cal" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve calibration.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>string or AstroData instance</em>) &#8211; File for which calibration must be retrieved.</li>
<li><strong>caltype</strong> (<em>string</em>) &#8211; The type of calibration (ex.&#8217;bias&#8217;, &#8216;flat&#8217;).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The URI of the currently stored calibration or None.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">string or None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.get_input_from_parent">
<tt class="descname">get_input_from_parent</tt><big>(</big><em>parent</em><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.get_input_from_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Very inefficient.</p>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.get_inputs">
<tt class="descname">get_inputs</tt><big>(</big><em>style=None</em><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.get_inputs" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>style</strong> (<em>string</em>) &#8211; Controls the type of return value. Supported values are &#8220;AD&#8221;
and &#8220;FN&#8221; for <tt class="docutils literal"><span class="pre">AstroData</span></tt> and <tt class="docutils literal"><span class="pre">string</span></tt> filenames respectively.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a list of <tt class="docutils literal"><span class="pre">AstroData</span></tt> instances or <tt class="docutils literal"><span class="pre">string</span></tt> filenames</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal"><span class="pre">get_inputs(..)</span></tt> gets the current input datasets from the current stream. You cannot
choose the stream, use <tt class="docutils literal"><span class="pre">get_stream(..)</span></tt> for that.  To report modified
datasets back to the stream use <tt class="docutils literal"><span class="pre">report_output(..)</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.get_inputs_as_astro_data">
<tt class="descname">get_inputs_as_astro_data</tt><big>(</big><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.get_inputs_as_astro_data" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is equivalent to:</p>
<p>get_inputs(style=&#8221;AD&#8221;)</p>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.get_inputs_as_astrodata">
<tt class="descname">get_inputs_as_astrodata</tt><big>(</big><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.get_inputs_as_astrodata" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is equivalent to:</p>
<p>get_inputs(style=&#8221;AD&#8221;)</p>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.get_inputs_as_filenames">
<tt class="descname">get_inputs_as_filenames</tt><big>(</big><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.get_inputs_as_filenames" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is equivalent for:</p>
<p>get_inputs(style=&#8221;FN&#8221;)</p>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.get_list">
<tt class="descname">get_list</tt><big>(</big><em>id</em><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.get_list" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>id</strong> (<em>str</em>) &#8211; Lists are associated with arbitrary identifiers,
passed as strings.  See <tt class="docutils literal"><span class="pre">IDFactory</span></tt> for IDs built from
standard <tt class="docutils literal"><span class="pre">astrodata</span></tt> characteristics.</td>
</tr>
</tbody>
</table>
<p>The list functionality allows storing dataset names in a list
which is shared by all instances of reduce running in a given
directory.  The list is kept by an <tt class="docutils literal"><span class="pre">adcc</span></tt> instance in charge of that
sub-directory.  The <tt class="docutils literal"><span class="pre">get_list(..)</span></tt> function retrieves a list that has
already been requested via <tt class="docutils literal"><span class="pre">rq_stack_get(..)</span></tt> which initiates the
interprocess request.</p>
<p>This function does not block, and if the stack was not requested
prior to a yeild, prior to this call, then None or an out of date
version of this list will be retrieved.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note :</th><td class="field-body">&#8220;get_stack&#8221; calls get_list but takes a &#8220;purpose&#8221; to which it adds
a stackingID as a suffix to the list identifier.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.get_reference_image">
<tt class="descname">get_reference_image</tt><big>(</big><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.get_reference_image" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns the current reference image.  At the moment
this is simply the first dataset in the current inputs.  However,
use of this function allows us to evolve our concept of reference
image for more complicated cases where the choice of a &#8220;reference&#8221; image
may need to be different (e.g. require some data analysis to determine).</p>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.get_stream">
<tt class="descname">get_stream</tt><big>(</big><em>stream='main'</em>, <em>empty=False</em>, <em>style=None</em><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.get_stream" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>stream</strong> (<em>str</em>) &#8211; A string name for the stream in question.  
To use the standard stream do not set.</li>
<li><strong>empty</strong> (<em>bool</em>) &#8211; Controls if the stream is
emptied, defaults to &#8220;False&#8221;.</li>
<li><strong>style</strong> &#8211; controls the type of output. &#8220;AD&#8221; directs the function
to return a list
of AstroData instances. &#8220;FN&#8221; directs it to return a list of filenames.
If left blank or set to <tt class="docutils literal"><span class="pre">None</span></tt>, the AstroDataRecord structures used
by the Reduction Context will be returned.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">a list of <tt class="docutils literal"><span class="pre">AstroDataRecord</span></tt> objects, <tt class="docutils literal"><span class="pre">AstroData</span></tt> objects or filenames.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list</p>
</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal"><span class="pre">get_stream</span></tt> returns a list of AstroData instances in the specified stream.</p>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.list_append">
<tt class="descname">list_append</tt><big>(</big><em>id</em>, <em>files</em>, <em>cachefile=None</em><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.list_append" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>id</strong> (<em>string</em>) &#8211; A string that identifies to which list to append the filenames.</li>
<li><strong>files</strong> (<em>list of strings</em>) &#8211; A list of filenames to add to the list.</li>
<li><strong>cachefile</strong> (<em>string</em>) &#8211; Filename to use to store the list.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The caller is expected to supply <tt class="docutils literal"><span class="pre">cachefile</span></tt>, which in principle
a value of &#8220;None&#8221; could mean the &#8220;default cachefile&#8221; this is not
supported by the <tt class="docutils literal"><span class="pre">adcc</span></tt> as of yet. The desired behavior is for
reduce instances running in the same directory to cooperate, and those
running in separate directories be kept separate, and this is 
implemented by providing an argument for <tt class="docutils literal"><span class="pre">cachefile</span></tt> which is in a 
generated subdirectory (hidden) based on the startup directory
for the reduce process.</p>
<p>The adcc will negotiate all contention and race conditions regarding
multiple applications manipulating a list simultaneously in separate
process.</p>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.list_inputs_as_str">
<tt class="descname">list_inputs_as_str</tt><big>(</big><em>id</em><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.list_inputs_as_str" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>id</strong> (<em>str</em>) &#8211; The identifier of the list to return as a comma separated string w/ no whitespace</td>
</tr>
</tbody>
</table>
<p>This is used to provide the list of names as a single string.</p>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.parameter_collate">
<tt class="descname">parameter_collate</tt><big>(</big><em>astrotype</em>, <em>primset</em>, <em>primname</em><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.parameter_collate" title="Permalink to this definition">¶</a></dt>
<dd><p>This function looks at the default primset paramaters for primname
and sets the localparms member.</p>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.prepend_names">
<tt class="descname">prepend_names</tt><big>(</big><em>prepend</em>, <em>current_dir=True</em>, <em>filepaths=None</em><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.prepend_names" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>prepend</strong> (<em>string</em>) &#8211; The string to be put at the front of the file.</li>
<li><strong>current_dir</strong> (<em>boolean</em>) &#8211; Used if the filename (astrodata filename) is in the
current working directory.</li>
<li><strong>filepaths</strong> &#8211; If present, these file paths will be modified, otherwise
the current inputs are modified.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">List of new prepended paths.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list</p>
</td>
</tr>
</tbody>
</table>
<p>Prepends a prefix string to either the inputs or the given list of filenames.</p>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.report">
<tt class="descname">report</tt><big>(</big><em>report_history=False</em>, <em>internal_dict=False</em>, <em>context_vars=False</em>, <em>report_inputs=False</em>, <em>report_parameters=False</em>, <em>showall=False</em><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.report" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints out a report of the contents of the context object</p>
<p>&#64;return: The formatted message for all the current parameters.
&#64;rtype: str</p>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.report_output">
<tt class="descname">report_output</tt><big>(</big><em>inp</em>, <em>stream=None</em>, <em>load=True</em><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.report_output" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>inp</strong> (<em>str, AstroData instance, or list</em>) &#8211; The inputs to report (add to the given or current stream).
Input can be a string (filename), an AstroData instance, or a list of
strings and/or AstroData instances.  Each individual dataset is
wrapped in an AstroDataRecord and stored in the current stream.</li>
<li><strong>stream</strong> (<em>str</em>) &#8211; If not specified the default (&#8220;main&#8221;) stream is used.
When specified the named stream is created if necessary.</li>
<li><strong>load</strong> &#8211; A boolean (default: True) which specifies whether string
arguments (pathnames) should be loaded into AstroData instances
or if it should be kept as a filename, unloaded.  This argument
has no effect when &#8220;report&#8221;
<tt class="docutils literal"><span class="pre">AstroData</span></tt> instances already in memory.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This function, along with <tt class="docutils literal"><span class="pre">get_inputs(..)</span></tt> allows a primitive to
interact with the datastream in which it was invoked (or access
other streams).</p>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.restore_fringe_index">
<tt class="descname">restore_fringe_index</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.restore_fringe_index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.restore_stk_index">
<tt class="descname">restore_stk_index</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.restore_stk_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the stack list from</p>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.restore_stream">
<tt class="descname">restore_stream</tt><big>(</big><em>from_stream=None</em><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.restore_stream" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>from_stream</strong> (<em>str</em>) &#8211; This is the stream being reverted from. It does not
need to be passed in but can be used to ensure it is the same
stream the rc thinks it is  popping off.</td>
</tr>
</tbody>
</table>
<p>Revert to the last stream prior to previous switch_stream(..) call.</p>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.rm_cal">
<tt class="descname">rm_cal</tt><big>(</big><em>data</em>, <em>caltype</em><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.rm_cal" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a calibration. This is used in command line argument (rmcal). This may end up being used
for some sort of TTL thing for cals in the future.</p>
<p>&#64;param data: Images who desire their cals to be removed.
&#64;type data: str, list or AstroData instance.</p>
<p>&#64;param caltype: Calibration type (e.g. &#8216;bias&#8217;).
&#64;type caltype: str</p>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.rq_cal">
<tt class="descname">rq_cal</tt><big>(</big><em>caltype</em>, <em>inputs=None</em>, <em>source='all'</em><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.rq_cal" title="Permalink to this definition">¶</a></dt>
<dd><p>Create calibration requests based on raw inputs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>caltype</strong> (<em>str</em>) &#8211; The type of calibration. For example, &#8216;bias&#8217; and &#8216;flat&#8217;.</li>
<li><strong>inputs</strong> (<em>list of AstroData instances</em>) &#8211; The datasets for which to find calibrations, if not present
or <tt class="docutils literal"><span class="pre">None</span></tt> current &#8220;inputs&#8221; are used.</li>
<li><strong>source</strong> &#8211; Directs what calibration service to contact, for future
compatibility, currently only &#8220;all&#8221; is supported.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.rq_display">
<tt class="descname">rq_display</tt><big>(</big><em>display_id=None</em><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.rq_display" title="Permalink to this definition">¶</a></dt>
<dd><p>self, filename = None
if None use self.inputs</p>
<p>Create requests to display inputs.</p>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.rq_stack_get">
<tt class="descname">rq_stack_get</tt><big>(</big><em>purpose=''</em><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.rq_stack_get" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>purpose</strong> (<em>string</em>) &#8211; The purpose is a string prepended to the stackingID
used to identify the list (see <tt class="docutils literal"><span class="pre">get_list(..)</span></tt>).</td>
</tr>
</tbody>
</table>
<p>The stackingID (see IDFactory module) is used to identify the list.
The first input in the rc.inputs list is used as the reference image 
to generate  
the stackingID portion of the list identifier.</p>
<p>The stackingID function in IDFactory is meant to produce identical
stacking identifiers for different images which can/should be stacked 
together, e.g. based
on program ID and/or other details.  Again, see IDFactory for the
particular algorithm in use.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note :</th><td class="field-body">a versioning system is latent within the code, and is added
to the id to allow adaptation in the future if identifer construction
methods change.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.rq_stack_put">
<tt class="descname">rq_stack_put</tt><big>(</big><em>purpose=None</em><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.rq_stack_put" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>purpose</strong> (<em>str</em>) &#8211; The purpose argument is a string prefixed to the
generated stackingID.  This allows two images which would
produce identical stackingIDs to go in different lists,
i.e. such as a fringe frame which might be prepended with
&#8220;fringe&#8221; as the purpose.</td>
</tr>
</tbody>
</table>
<p>This function creates requests to update a stack list with the files
in the current rc.inputs list.  Each will go in a stack based on its
own stackingID (prepended with &#8220;purpose&#8221;).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note :</th><td class="field-body">this function places a message on an outbound message queue
which will not be sent until the next &#8220;yield&#8221;, allowing the
ReductionObject command clause to execute.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.rq_stack_update">
<tt class="descname">rq_stack_update</tt><big>(</big><em>purpose=None</em><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.rq_stack_update" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>purpose</strong> (<em>str</em>) &#8211; The purpose argument is a string prefixed to the
generated stackingID.  This allows two images which would
produce identical stackingIDs to go in different lists,
i.e. such as a fringe frame which might be prepended with
&#8220;fringe&#8221; as the purpose.</td>
</tr>
</tbody>
</table>
<p>This function creates requests to update a stack list with the files
in the current rc.inputs list.  Each will go in a stack based on its
own stackingID (prepended with &#8220;purpose&#8221;).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note :</th><td class="field-body">this function places a message on an outbound message queue
which will not be sent until the next &#8220;yield&#8221;, allowing the
ReductionObject command clause to execute.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.run">
<tt class="descname">run</tt><big>(</big><em>stepname</em><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.run" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>stepname</strong> &#8211; The primitive or recipe name to run. Note: this is</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>actually compiled as a recipe. Proxy recipe names may appear</dt>
<dd>in the logs.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
</tbody>
</table>
<p>The <tt class="docutils literal"><span class="pre">run(..)</span></tt> function allows a primitive to use the reduction
context to execute another recipe or primitive.</p>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.stack_append">
<tt class="descname">stack_append</tt><big>(</big><em>id</em>, <em>files</em>, <em>cachefile=None</em><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.stack_append" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>id</strong> (<em>string</em>) &#8211; A string that identifies to which list to append the filenames.</li>
<li><strong>files</strong> (<em>list of strings</em>) &#8211; A list of filenames to add to the list.</li>
<li><strong>cachefile</strong> (<em>string</em>) &#8211; Filename to use to store the list.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The caller is expected to supply <tt class="docutils literal"><span class="pre">cachefile</span></tt>, which in principle
a value of &#8220;None&#8221; could mean the &#8220;default cachefile&#8221; this is not
supported by the <tt class="docutils literal"><span class="pre">adcc</span></tt> as of yet. The desired behavior is for
reduce instances running in the same directory to cooperate, and those
running in separate directories be kept separate, and this is 
implemented by providing an argument for <tt class="docutils literal"><span class="pre">cachefile</span></tt> which is in a 
generated subdirectory (hidden) based on the startup directory
for the reduce process.</p>
<p>The adcc will negotiate all contention and race conditions regarding
multiple applications manipulating a list simultaneously in separate
process.</p>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.stack_inputs_as_str">
<tt class="descname">stack_inputs_as_str</tt><big>(</big><em>id</em><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.stack_inputs_as_str" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>id</strong> (<em>str</em>) &#8211; The identifier of the list to return as a comma separated string w/ no whitespace</td>
</tr>
</tbody>
</table>
<p>This is used to provide the list of names as a single string.</p>
</dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.suffix_names">
<tt class="descname">suffix_names</tt><big>(</big><em>suffix</em>, <em>current_dir=True</em><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.suffix_names" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="RecipeManager.ReductionContext.switch_stream">
<tt class="descname">switch_stream</tt><big>(</big><em>switch_to=None</em><big>)</big><a class="headerlink" href="#RecipeManager.ReductionContext.switch_stream" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>switch_to</strong> (<em>str</em>) &#8211; The string name of the stream to switch to. The 
named stream must already exist.</td>
</tr>
<tr class="field-even field"><th class="field-name">Note :</th><td class="field-body">This function is used by the infrastructure (in an application
such as reduce and in the ReductionContext) to switch the stream
being used. Reported output then goes to the specified stream.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="RecipeManager.close_if_name">
<tt class="descclassname">RecipeManager.</tt><tt class="descname">close_if_name</tt><big>(</big><em>dataset</em>, <em>b_needs_closing</em><big>)</big><a class="headerlink" href="#RecipeManager.close_if_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility function to handle accepting datasets as AstroData
instances or string filenames. Works in conjunction with open_if_name.</p>
</dd></dl>

<dl class="function">
<dt id="RecipeManager.open_if_name">
<tt class="descclassname">RecipeManager.</tt><tt class="descname">open_if_name</tt><big>(</big><em>dataset</em><big>)</big><a class="headerlink" href="#RecipeManager.open_if_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility function to handle accepting datasets as AstroData
instances or string filenames. Works in conjunction with close_if_name.
The way it works, open_if_name opens returns an GeminiData isntance</p>
</dd></dl>

<dl class="data">
<dt id="RecipeManager.primitivesIndexREMask">
<tt class="descclassname">RecipeManager.</tt><tt class="descname">primitivesIndexREMask</tt><em class="property"> = 'primitivesIndex\\.(?P&lt;modname&gt;.*?)\\.py$'</em><a class="headerlink" href="#RecipeManager.primitivesIndexREMask" title="Permalink to this definition">¶</a></dt>
<dd><p>recipeIndexREMask used to identify which files by filename
are those with tables relating type names to structure types</p>
</dd></dl>

</div>
<div class="section" id="recipes-primitives">
<h2><tt class="docutils literal"><span class="pre">Recipes_PRIMITIVES</span></tt><a class="headerlink" href="#recipes-primitives" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-ReductionContextRecords">
<span id="reduction-context-records"></span><h2><tt class="docutils literal"><span class="pre">Reduction</span> <span class="pre">context</span> <span class="pre">records</span></tt><a class="headerlink" href="#module-ReductionContextRecords" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="ReductionContextRecords.AstroDataRecord">
<em class="property">class </em><tt class="descclassname">ReductionContextRecords.</tt><tt class="descname">AstroDataRecord</tt><big>(</big><em>filename</em>, <em>display_id=None</em>, <em>timestamp=None</em>, <em>parent=None</em>, <em>load=True</em><big>)</big><a class="headerlink" href="#ReductionContextRecords.AstroDataRecord" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains any metadata related to output/input within the ReductionContext.
This is used specifically in the ReductionContext records inputs and outputs.</p>
</dd></dl>

<dl class="class">
<dt id="ReductionContextRecords.CalibrationRecord">
<em class="property">class </em><tt class="descclassname">ReductionContextRecords.</tt><tt class="descname">CalibrationRecord</tt><big>(</big><em>sci_filename</em>, <em>filename</em>, <em>caltype</em>, <em>timestamp=None</em>, <em>source='all'</em><big>)</big><a class="headerlink" href="#ReductionContextRecords.CalibrationRecord" title="Permalink to this definition">¶</a></dt>
<dd><p>Record for storing all relevant members related to calibration data.
This is used specifically by the ReductionContext in its calibrations
member.</p>
</dd></dl>

<dl class="class">
<dt id="ReductionContextRecords.FringeRecord">
<em class="property">class </em><tt class="descclassname">ReductionContextRecords.</tt><tt class="descname">FringeRecord</tt><big>(</big><em>fringeid</em>, <em>listid</em>, <em>filelist</em>, <em>timestamp=None</em><big>)</big><a class="headerlink" href="#ReductionContextRecords.FringeRecord" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains the cache information for a set of fringeable data.</p>
</dd></dl>

<dl class="class">
<dt id="ReductionContextRecords.ReductionContextRecord">
<em class="property">class </em><tt class="descclassname">ReductionContextRecords.</tt><tt class="descname">ReductionContextRecord</tt><big>(</big><em>timestamp</em><big>)</big><a class="headerlink" href="#ReductionContextRecords.ReductionContextRecord" title="Permalink to this definition">¶</a></dt>
<dd><p>The parent record. Contains all members global to all records. (i.e. timestamp)</p>
</dd></dl>

<dl class="class">
<dt id="ReductionContextRecords.StackableRecord">
<em class="property">class </em><tt class="descclassname">ReductionContextRecords.</tt><tt class="descname">StackableRecord</tt><big>(</big><em>stkid</em>, <em>filelist</em>, <em>timestamp=None</em><big>)</big><a class="headerlink" href="#ReductionContextRecords.StackableRecord" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains the local cache information for a particular set of stackable data.
Used in the ReductionContext records stackeep.</p>
</dd></dl>

</div>
<div class="section" id="module-ReductionObjectRequests">
<span id="reduction-object-requests"></span><h2><tt class="docutils literal"><span class="pre">Reduction</span> <span class="pre">Object</span> <span class="pre">Requests</span></tt><a class="headerlink" href="#module-ReductionObjectRequests" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="ReductionObjectRequests.CalibrationRequest">
<em class="property">class </em><tt class="descclassname">ReductionObjectRequests.</tt><tt class="descname">CalibrationRequest</tt><big>(</big><em>filename=None</em>, <em>identifiers={}</em>, <em>criteria={}</em>, <em>priorities={}</em>, <em>caltype=None</em>, <em>source='all'</em>, <em>ad=None</em><big>)</big><a class="headerlink" href="#ReductionObjectRequests.CalibrationRequest" title="Permalink to this definition">¶</a></dt>
<dd><p>The structure that stores the calibration parameters from the xml 
calibration file.
It is used by the control loop to be added to the request queue.</p>
</dd></dl>

<dl class="class">
<dt id="ReductionObjectRequests.DisplayRequest">
<em class="property">class </em><tt class="descclassname">ReductionObjectRequests.</tt><tt class="descname">DisplayRequest</tt><big>(</big><em>dis_id=None</em>, <em>dis_list=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#ReductionObjectRequests.DisplayRequest" title="Permalink to this definition">¶</a></dt>
<dd><p>The request to display a list of fits files.</p>
</dd></dl>

<dl class="class">
<dt id="ReductionObjectRequests.GetStackableRequest">
<em class="property">class </em><tt class="descclassname">ReductionObjectRequests.</tt><tt class="descname">GetStackableRequest</tt><big>(</big><em>stk_id=None</em><big>)</big><a class="headerlink" href="#ReductionObjectRequests.GetStackableRequest" title="Permalink to this definition">¶</a></dt>
<dd><p>The request to get the stackable list. (More of a PRS issue as updating
the stack already does this.)</p>
</dd></dl>

<dl class="class">
<dt id="ReductionObjectRequests.ImageQualityRequest">
<em class="property">class </em><tt class="descclassname">ReductionObjectRequests.</tt><tt class="descname">ImageQualityRequest</tt><big>(</big><em>ad</em>, <em>ell_mean</em>, <em>ell_sigma</em>, <em>fwhm_mean</em>, <em>fwhm_sigma</em><big>)</big><a class="headerlink" href="#ReductionObjectRequests.ImageQualityRequest" title="Permalink to this definition">¶</a></dt>
<dd><p>A request to publish image quality metrics to the message bus or in the
case of stand-alone mode, display overlays, etc. (Demo)</p>
</dd></dl>

<dl class="class">
<dt id="ReductionObjectRequests.ReductionObjectRequest">
<em class="property">class </em><tt class="descclassname">ReductionObjectRequests.</tt><tt class="descname">ReductionObjectRequest</tt><a class="headerlink" href="#ReductionObjectRequests.ReductionObjectRequest" title="Permalink to this definition">¶</a></dt>
<dd><p>The parent of all Requests which contains members prevalent to all requests
(i.e. timestamp).</p>
</dd></dl>

<dl class="class">
<dt id="ReductionObjectRequests.UpdateStackableRequest">
<em class="property">class </em><tt class="descclassname">ReductionObjectRequests.</tt><tt class="descname">UpdateStackableRequest</tt><big>(</big><em>stk_id=None</em>, <em>stk_list=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#ReductionObjectRequests.UpdateStackableRequest" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains all relevant information to request updating the stackable index.</p>
</dd></dl>

</div>
<div class="section" id="module-ReductionObjects">
<span id="reduction-object"></span><h2><tt class="docutils literal"><span class="pre">Reduction</span> <span class="pre">Object</span></tt><a class="headerlink" href="#module-ReductionObjects" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="ReductionObjects.ReductionExcept">
<em class="property">class </em><tt class="descclassname">ReductionObjects.</tt><tt class="descname">ReductionExcept</tt><big>(</big><em>msg='Exception Raised by ReductionObject'</em><big>)</big><a class="headerlink" href="#ReductionObjects.ReductionExcept" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the general exception the classes and functions in the
Structures.py module raise.</p>
</dd></dl>

</div>
<div class="section" id="module-StackKeeper">
<span id="stackkeeper"></span><h2><tt class="docutils literal"><span class="pre">Stackkeeper</span></tt><a class="headerlink" href="#module-StackKeeper" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="StackKeeper.FringeKeeper">
<em class="property">class </em><tt class="descclassname">StackKeeper.</tt><tt class="descname">FringeKeeper</tt><a class="headerlink" href="#StackKeeper.FringeKeeper" title="Permalink to this definition">¶</a></dt>
<dd><p>A data structure for accessing stackable lists.</p>
<dl class="method">
<dt id="StackKeeper.FringeKeeper.add">
<tt class="descname">add</tt><big>(</big><em>list_id</em>, <em>astro_id</em>, <em>addtostack</em><big>)</big><a class="headerlink" href="#StackKeeper.FringeKeeper.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a list of stackables for a given id. If the id does not exist, make a new stackable list.</p>
<p>&#64;param id: An id based off that derived from IDFactory.getStackableID. 
&#64;type id: str</p>
<p>&#64;param addtostack: A list of files for stacking or a StackableRecord instance.
&#64;type addtostack: list or StackableRecord</p>
</dd></dl>

<dl class="method">
<dt id="StackKeeper.FringeKeeper.get">
<tt class="descname">get</tt><big>(</big><em>id</em><big>)</big><a class="headerlink" href="#StackKeeper.FringeKeeper.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the stackable list for a given id.</p>
<p>&#64;param id: An id based off that derived from IDFactory.getStackableID.
&#64;type id: str</p>
<p>&#64;return: List of files for stacking.
&#64;rtype: list of str</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="StackKeeper.SKExcept">
<em class="property">class </em><tt class="descclassname">StackKeeper.</tt><tt class="descname">SKExcept</tt><big>(</big><em>msg='Exception Raised in StackKeeper'</em>, <em>**argv</em><big>)</big><a class="headerlink" href="#StackKeeper.SKExcept" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the general exception the classes and functions in the
StackKeeper.py module raise.</p>
</dd></dl>

<dl class="class">
<dt id="StackKeeper.StackKeeper">
<em class="property">class </em><tt class="descclassname">StackKeeper.</tt><tt class="descname">StackKeeper</tt><big>(</big><em>local=False</em><big>)</big><a class="headerlink" href="#StackKeeper.StackKeeper" title="Permalink to this definition">¶</a></dt>
<dd><p>A data structure for accessing stackable lists.
It keeps a dictionary indexed by the cachefile name, which
contain a dict keyed by stack id, with a list of filenames as the value.</p>
<dl class="method">
<dt id="StackKeeper.StackKeeper.add">
<tt class="descname">add</tt><big>(</big><em>id</em>, <em>addtostack</em>, <em>cachefile=None</em><big>)</big><a class="headerlink" href="#StackKeeper.StackKeeper.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a list of stackables for a given id. If the id does not exist, make a new stackable list.</p>
<p>&#64;param id: An id based off that derived from IDFactory.getStackableID. 
&#64;type id: str</p>
<p>&#64;param addtostack: A list of files for stacking or a StackableRecord instance.
&#64;type addtostack: list or StackableRecord</p>
</dd></dl>

<dl class="method">
<dt id="StackKeeper.StackKeeper.get">
<tt class="descname">get</tt><big>(</big><em>id</em>, <em>cachefile=None</em><big>)</big><a class="headerlink" href="#StackKeeper.StackKeeper.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the stackable list for a given id.</p>
<p>&#64;param id: An id based off that derived from IDFactory.getStackableID.
&#64;type id: str</p>
<p>&#64;return: List of files for stacking.
&#64;rtype: list of str</p>
</dd></dl>

<dl class="method">
<dt id="StackKeeper.StackKeeper.load">
<tt class="descname">load</tt><big>(</big><em>cachefile=None</em><big>)</big><a class="headerlink" href="#StackKeeper.StackKeeper.load" title="Permalink to this definition">¶</a></dt>
<dd><p>This member loads the persistent stack for the given cachefile
name. NOTE: the contents of the cachefile will stomp any in-memory
copy of the cachefile. Process and thread safety 
(say if the list should
be made a union) must take place in the calling function.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-Structures">
<span id="structures"></span><h2><tt class="docutils literal"><span class="pre">Structures</span></tt><a class="headerlink" href="#module-Structures" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Structures.ExtID">
<em class="property">class </em><tt class="descclassname">Structures.</tt><tt class="descname">ExtID</tt><a class="headerlink" href="#Structures.ExtID" title="Permalink to this definition">¶</a></dt>
<dd><p>The ExtID class acts as the leaf node in Structure instance hierarchies
which capture the over all structure of the data. It&#8217;s role as leaf node
is to recognize specific extensions being looked for. An ExtID class will 
have some extension requirements (i.e. on the extension header) it understand
innately (e.g. &#8220;EXTNAME&#8221; should be &#8220;SCI&#8221;) but will have some of the
recognition requirements given to it (e.g. told to find &#8220;EXTVER&#8221; == 2)
as a result of requirements from higher in the structure tree.
&#64;ivar head_reqs: a dictionary which contains extension header keys as keys,
and identifying values within the map values.
&#64;type head_reqs: dictionary</p>
<dl class="method">
<dt id="Structures.ExtID.find">
<tt class="descname">find</tt><big>(</big><em>dataset</em>, <em>hduignore=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#Structures.ExtID.find" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will try to find the extension matching
its requirements in the given dataset.
&#64;param dataset: The data set in which to seek the extension
this ExtID seeks.
&#64;type dataset: AstroData instance</p>
</dd></dl>

<dl class="method">
<dt id="Structures.ExtID.get_extensions">
<tt class="descname">get_extensions</tt><big>(</big><big>)</big><a class="headerlink" href="#Structures.ExtID.get_extensions" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns the extension identified by this node. 
C{get_extensions()} Should be called only after &#8220;find&#8221; has been
called, and is part of the structure projection process.
&#64;return: the extension previously found in call to C{find(..)}
&#64;rtype: an HDU instance</p>
</dd></dl>

<dl class="method">
<dt id="Structures.ExtID.project">
<tt class="descname">project</tt><big>(</big><em>dataset</em><big>)</big><a class="headerlink" href="#Structures.ExtID.project" title="Permalink to this definition">¶</a></dt>
<dd><p>The Structure Class actually manage projection, as it&#8217;s a recursive
call ExtID only needs to terminate this call (by not recursing further
as it is always a leaf node).  This function therefore currently has
C{pass} as its body.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Structures.Part">
<em class="property">class </em><tt class="descclassname">Structures.</tt><tt class="descname">Part</tt><big>(</big><em>structClass=None</em>, <em>arrayBy=None</em>, <em>name=None</em>, <em>otherReqs={}</em>, <em>required=True</em><big>)</big><a class="headerlink" href="#Structures.Part" title="Permalink to this definition">¶</a></dt>
<dd><p>The Part class is an element of the Stucture and ExtID classes
pattern seeking system.  The Structure classes can be thought of etching
the structure found in a hierarchy of Part instances.  A Structure
and ExtID hierarchy is a template, and the Part Hierarchy is the 
material instance of the structure relationships. The Part hierarchy 
refers to Structure instances. To project the structure we recurse 
the Part instance hierarchy.</p>
<dl class="attribute">
<dt id="Structures.Part.array_by">
<tt class="descname">array_by</tt><em class="property"> = None</em><a class="headerlink" href="#Structures.Part.array_by" title="Permalink to this definition">¶</a></dt>
<dd><p>A string name of the header variable use to array this part.</p>
</dd></dl>

<dl class="attribute">
<dt id="Structures.Part.other_reqs">
<tt class="descname">other_reqs</tt><em class="property"> = None</em><a class="headerlink" href="#Structures.Part.other_reqs" title="Permalink to this definition">¶</a></dt>
<dd><p>Either None or a dictionary of header requirements inherited from
up the hierarchy</p>
</dd></dl>

<dl class="attribute">
<dt id="Structures.Part.required">
<tt class="descname">required</tt><em class="property"> = True</em><a class="headerlink" href="#Structures.Part.required" title="Permalink to this definition">¶</a></dt>
<dd><p>A boolean indicating if this part is required or not</p>
</dd></dl>

<dl class="attribute">
<dt id="Structures.Part.struct_class">
<tt class="descname">struct_class</tt><em class="property"> = None</em><a class="headerlink" href="#Structures.Part.struct_class" title="Permalink to this definition">¶</a></dt>
<dd><p>The string name of the struct_class at this point in the structure.</p>
</dd></dl>

<dl class="attribute">
<dt id="Structures.Part.struct_inst">
<tt class="descname">struct_inst</tt><em class="property"> = None</em><a class="headerlink" href="#Structures.Part.struct_inst" title="Permalink to this definition">¶</a></dt>
<dd><p>The instance of the Structure or ExtID instance at this point in
the hierarchy.</p>
</dd></dl>

<dl class="attribute">
<dt id="Structures.Part.struct_name">
<tt class="descname">struct_name</tt><em class="property"> = None</em><a class="headerlink" href="#Structures.Part.struct_name" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the name this part will have as a member variable of the
AstroData instance
into which it is projected.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Structures.PartList">
<em class="property">class </em><tt class="descclassname">Structures.</tt><tt class="descname">PartList</tt><big>(</big><em>structClass=None</em>, <em>arrayBy=None</em>, <em>name=None</em>, <em>otherReqs={}</em>, <em>required=True</em><big>)</big><a class="headerlink" href="#Structures.PartList" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is for a part that is an array.</p>
</dd></dl>

<dl class="class">
<dt id="Structures.ProjectionExcept">
<em class="property">class </em><tt class="descclassname">Structures.</tt><tt class="descname">ProjectionExcept</tt><big>(</big><em>msg='Exception Raised in Structure Projection system'</em><big>)</big><a class="headerlink" href="#Structures.ProjectionExcept" title="Permalink to this definition">¶</a></dt>
<dd><p>This exception is raised to communicate (potentially) fatal errors
when applying structure to an AstroData instance. For example, when 
a structure is applying a member already present in the AstroData
instance (due to another projection or any other reason).</p>
<p>&#64;note: By &#8220;projection&#8221; in this context I am talking about the members
defined in the structure description which are then added to the AstroData
instance at run time.  Multiple structure can apply to a single set of data
and probably will, but they must not project the same members at the same level.</p>
</dd></dl>

<dl class="class">
<dt id="Structures.Structure">
<em class="property">class </em><tt class="descclassname">Structures.</tt><tt class="descname">Structure</tt><a class="headerlink" href="#Structures.Structure" title="Permalink to this definition">¶</a></dt>
<dd><p>The Structure Class encapsulates the nodes of hierarchy
in the data structures we want to project.  This class manages
the structure discovery process. Structures are defined as a 
tree of Structure Instances which terminate in L{ExtID} instances.</p>
<dl class="method">
<dt id="Structures.Structure.collect">
<tt class="descname">collect</tt><big>(</big><em>dataset</em><big>)</big><a class="headerlink" href="#Structures.Structure.collect" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will collect parts defined by a structure onto a given AstrData object,
that is, it will add the correct members to the AstroData instance.
In short, this function attaches an AstroData instance, or, 
for array members, a list of AstroData instances, as a member of the
given dataset which contains the extensions in that section of the dataset.</p>
<p>NOTE: the structure should have been previously &#8220;found&#8221; 
(e.g. via &#8216;structureInstance.find(dataset)&#8217;).
&#64;param dataset: the AstroData instance to which to apply the structure members
&#64;type dataset: AstroData instance</p>
</dd></dl>

<dl class="method">
<dt id="Structures.Structure.find">
<tt class="descname">find</tt><big>(</big><em>dataset</em>, <em>hduignore=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#Structures.Structure.find" title="Permalink to this definition">¶</a></dt>
<dd><p>This function attempts to find the structure given in the dataset given.
&#64;param dataset: the data in which to seek the structure defined in
this structure instance (based also on the structure of the structure
members).
&#64;type dataset: AstroData instance</p>
</dd></dl>

<dl class="method">
<dt id="Structures.Structure.project">
<tt class="descname">project</tt><big>(</big><em>dataset</em><big>)</big><a class="headerlink" href="#Structures.Structure.project" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will project a structure onto a given AstrData object,
that is, it will add the correct members to the AstroData instance.
In short, this function attaches an AstroData instance, or, 
for array members, a list of AstroData instances, as a member of the
given dataset which contains the extensions in that section of the dataset.</p>
<p>NOTE: the structure should have been previously &#8220;found&#8221; 
(e.g. via &#8216;structureInstance.find(dataset)&#8217;).
&#64;param dataset: the AstroData instance to which to apply the structure members
&#64;type dataset: AstroData instance</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Structures.StructureExcept">
<em class="property">class </em><tt class="descclassname">Structures.</tt><tt class="descname">StructureExcept</tt><big>(</big><em>msg='Exception Raised in Structure Projection system'</em><big>)</big><a class="headerlink" href="#Structures.StructureExcept" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the general exception the classes and functions in the
Structures.py module raise.</p>
</dd></dl>

<dl class="function">
<dt id="Structures.apply_structure_by_type">
<tt class="descclassname">Structures.</tt><tt class="descname">apply_structure_by_type</tt><big>(</big><em>dataset=None</em>, <em>stype=None</em><big>)</big><a class="headerlink" href="#Structures.apply_structure_by_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply all structures to dataset based on which types apply to
the given dataset
&#64;param dataset: dataset to apply structure to
&#64;type dataset: AstroData instance
&#64;return: The number of structures applied
&#64;rtype: int</p>
</dd></dl>

<dl class="function">
<dt id="Structures.get_structured_slice">
<tt class="descclassname">Structures.</tt><tt class="descname">get_structured_slice</tt><big>(</big><em>dataset=None</em>, <em>stype=None</em>, <em>structure=None</em><big>)</big><a class="headerlink" href="#Structures.get_structured_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply all structures to dataset based on which types apply to
the given dataset
&#64;param dataset: dataset to apply structure to
&#64;type dataset: AstroData instance
&#64;return: The number of structures applied
&#64;rtype: int</p>
</dd></dl>

<dl class="data">
<dt id="Structures.structureIndexREMask">
<tt class="descclassname">Structures.</tt><tt class="descname">structureIndexREMask</tt><em class="property"> = 'structIndex\\.(?P&lt;modname&gt;.*?)\\.py$'</em><a class="headerlink" href="#Structures.structureIndexREMask" title="Permalink to this definition">¶</a></dt>
<dd><p>structureIndexREMask used to identify which files by filename
are those with tables relating type names to structure types</p>
</dd></dl>

</div>
<div class="section" id="module-gdpgutil">
<span id="gdputil"></span><h2><tt class="docutils literal"><span class="pre">gdputil</span></tt><a class="headerlink" href="#module-gdpgutil" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="gdpgutil.GDPGUtilExcept">
<em class="property">class </em><tt class="descclassname">gdpgutil.</tt><tt class="descname">GDPGUtilExcept</tt><big>(</big><em>msg='Exception Raised in Recipe System'</em><big>)</big><a class="headerlink" href="#gdpgutil.GDPGUtilExcept" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the general exception the classes and functions in the
Structures.py module raise.</p>
</dd></dl>

<dl class="function">
<dt id="gdpgutil.check_data_set">
<tt class="descclassname">gdpgutil.</tt><tt class="descname">check_data_set</tt><big>(</big><em>filenames</em><big>)</big><a class="headerlink" href="#gdpgutil.check_data_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list or individual AstroData, filenames, and then verifies and
returns list of AstroData instances. Will crash if bad arguments.</p>
<p>&#64;param filenames: Parameters you want to verify. 
&#64;type filenames: list, AstroData, str</p>
<p>&#64;return: List of verified AstroData instances.
&#64;rtype: list</p>
</dd></dl>

<dl class="function">
<dt id="gdpgutil.close_if_name">
<tt class="descclassname">gdpgutil.</tt><tt class="descname">close_if_name</tt><big>(</big><em>dataset</em>, <em>b_needs_closing</em><big>)</big><a class="headerlink" href="#gdpgutil.close_if_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility function to handle accepting datasets as AstroData
instances or string filenames. Works in conjunction with open_if_name.</p>
</dd></dl>

<dl class="function">
<dt id="gdpgutil.cluster_types">
<tt class="descclassname">gdpgutil.</tt><tt class="descname">cluster_types</tt><big>(</big><em>datalist</em><big>)</big><a class="headerlink" href="#gdpgutil.cluster_types" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Given a list or singleton of filenames, or AstroData, generate an index of AstroData based on </dt>
<dd><p class="first">types (e.g. So each file can run under the same recipe).</p>
<p class="last">Example Output:</p>
</dd>
<dt>{(&#8216;GEMINI_NORTH&#8217;, &#8216;GEMINI&#8217;, &#8216;GMOS_N&#8217;, &#8216;GMOS&#8217;, &#8216;GMOS_BIAS&#8217;, &#8216;PREPARED&#8217;): [&lt;AstroData object&gt;,</dt>
<dd><blockquote class="first">
<div>&lt;AstroData object&gt;],</div></blockquote>
<p>(&#8216;GEMINI_NORTH&#8217;, &#8216;GEMINI&#8217;, &#8216;GMOS_N&#8217;, &#8216;GMOS_FLAT&#8217;, &#8216;GMOS&#8217;, &#8216;PREPARED&#8217;): [&lt;AstroData object&gt;],
(&#8216;GEMINI_NORTH&#8217;, &#8216;GEMINI&#8217;, &#8216;GMOS_N&#8217;, &#8216;GMOS_IMAGE&#8217;, &#8216;GMOS&#8217;, &#8216;UNPREPARED&#8217;, &#8216;GMOS_RAW&#8217;): [&lt;AstroData object&gt;]}</p>
<blockquote class="last">
<div><p>&#64;param datalist: The list of data to be clustered.
&#64;type datalist: list, str, AstroData</p>
<p>&#64;return: Index of AstroDatas keyed by types.
&#64;rtype: dict</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="gdpgutil.open_if_name">
<tt class="descclassname">gdpgutil.</tt><tt class="descname">open_if_name</tt><big>(</big><em>dataset</em><big>)</big><a class="headerlink" href="#gdpgutil.open_if_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility function to handle accepting datasets as AstroData
instances or string filenames. Works in conjunction with close_if_name.
The way it works, open_if_name opens returns an GeminiData isntance</p>
</dd></dl>

<dl class="function">
<dt id="gdpgutil.pick_config">
<tt class="descclassname">gdpgutil.</tt><tt class="descname">pick_config</tt><big>(</big><em>dataset</em>, <em>index</em>, <em>style='unique'</em><big>)</big><a class="headerlink" href="#gdpgutil.pick_config" title="Permalink to this definition">¶</a></dt>
<dd><p>possible styles: &#8220;unique&#8221; only one leaf node can be returned, anything else
is seen as a conflict... &#8220;leaves&#8221; which gets all leaf node assignments ... &#8220;all&#8221;
means all assignments from all types that apply to the dataset.  Default style
is unique.</p>
</dd></dl>

</div>
<div class="section" id="module-tkMonitor">
<span id="tkmonitor"></span><h2><tt class="docutils literal"><span class="pre">Tkmonitor</span></tt><a class="headerlink" href="#module-tkMonitor" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tkMonitor.GUIExcept">
<em class="property">class </em><tt class="descclassname">tkMonitor.</tt><tt class="descname">GUIExcept</tt><big>(</big><em>msg='Exception Raised in Recipe System'</em><big>)</big><a class="headerlink" href="#tkMonitor.GUIExcept" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the general exception the classes and functions in the
Structures.py module raise.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><tt class="docutils literal"><span class="pre">AstroData</span></tt> &#8211; References</a><ul>
<li><a class="reference internal" href="#module-Calculator"><tt class="docutils literal"><span class="pre">Calculator</span></tt></a></li>
<li><a class="reference internal" href="#module-CalibrationDefinitionLibrary"><tt class="docutils literal"><span class="pre">CalibrationDefinitionLibrary</span></tt></a></li>
<li><a class="reference internal" href="#module-ConfigSpace"><tt class="docutils literal"><span class="pre">config</span> <span class="pre">space</span></tt></a></li>
<li><a class="reference internal" href="#module-DataSpider"><tt class="docutils literal"><span class="pre">data</span> <span class="pre">spider</span></tt></a></li>
<li><a class="reference internal" href="#module-Descriptors"><tt class="docutils literal"><span class="pre">Descriptor</span></tt></a></li>
<li><a class="reference internal" href="#module-Errors"><tt class="docutils literal"><span class="pre">Errors</span></tt></a></li>
<li><a class="reference internal" href="#module-IDFactory"><tt class="docutils literal"><span class="pre">Idfactory</span></tt></a></li>
<li><a class="reference internal" href="#module-LocalCalibrationService"><tt class="docutils literal"><span class="pre">Local</span> <span class="pre">Calibration</span> <span class="pre">service</span></tt></a></li>
<li><a class="reference internal" href="#module-Lookups"><tt class="docutils literal"><span class="pre">Lookups</span></tt></a></li>
<li><a class="reference internal" href="#module-ParamObject"><tt class="docutils literal"><span class="pre">Param</span> <span class="pre">object</span></tt></a></li>
<li><a class="reference internal" href="#module-RecipeManager"><tt class="docutils literal"><span class="pre">Recipe</span> <span class="pre">manager</span></tt></a></li>
<li><a class="reference internal" href="#recipes-primitives"><tt class="docutils literal"><span class="pre">Recipes_PRIMITIVES</span></tt></a></li>
<li><a class="reference internal" href="#module-ReductionContextRecords"><tt class="docutils literal"><span class="pre">Reduction</span> <span class="pre">context</span> <span class="pre">records</span></tt></a></li>
<li><a class="reference internal" href="#module-ReductionObjectRequests"><tt class="docutils literal"><span class="pre">Reduction</span> <span class="pre">Object</span> <span class="pre">Requests</span></tt></a></li>
<li><a class="reference internal" href="#module-ReductionObjects"><tt class="docutils literal"><span class="pre">Reduction</span> <span class="pre">Object</span></tt></a></li>
<li><a class="reference internal" href="#module-StackKeeper"><tt class="docutils literal"><span class="pre">Stackkeeper</span></tt></a></li>
<li><a class="reference internal" href="#module-Structures"><tt class="docutils literal"><span class="pre">Structures</span></tt></a></li>
<li><a class="reference internal" href="#module-gdpgutil"><tt class="docutils literal"><span class="pre">gdputil</span></tt></a></li>
<li><a class="reference internal" href="#module-tkMonitor"><tt class="docutils literal"><span class="pre">Tkmonitor</span></tt></a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/ref.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">ADConfig 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010, NZ.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>