

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Welcome to ADConfig’s documentation! &mdash; ADConfig 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="ADConfig 0.1 documentation" href="index.html" />
    <link rel="prev" title="Indices and tables" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="index.html" title="Indices and tables"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">ADConfig 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-AstroData">
<span id="welcome-to-adconfig-s-documentation"></span><span id="adconfig"></span><h1>Welcome to ADConfig&#8217;s documentation!<a class="headerlink" href="#module-AstroData" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="AstroData.AstroData">
<em class="property">class </em><tt class="descclassname">AstroData.</tt><tt class="descname">AstroData</tt><big>(</big><em>dataset=None</em>, <em>mode='readonly'</em>, <em>phu=None</em>, <em>header=None</em>, <em>data=None</em>, <em>store=None</em>, <em>storeClobber=False</em>, <em>exts=None</em>, <em>extInsts=None</em><big>)</big><a class="headerlink" href="#AstroData.AstroData" title="Permalink to this definition">¶</a></dt>
<dd><p>The AstroData class abstracts datasets stored in MEF files
and provides uniform interfaces for working on datasets from different
instruments and modes.  Configuration packages are used to describe
the specific data characteristics, layout, and to store type-specific
implementations.</p>
<p>MEFs can be generalized as lists of header-data units (HDU), with key-value 
pairs populating headers, and pixel values populating the data array.
AstroData interprets a MEF as a single complex entity.  The individual
&#8220;extensions&#8221; within the MEF are available using Python list (&#8220;[]&#8221;) syntax; 
they are wrapped in AstroData objects (see 
<tt class="xref py py-meth docutils literal"><span class="pre">AstroData.__getitem__()</span></tt>). 
AstroData uses <tt class="docutils literal"><span class="pre">pyfits</span></tt> for MEF I/O and <tt class="docutils literal"><span class="pre">numpy</span></tt> for pixel manipulations.</p>
<p>While the <tt class="docutils literal"><span class="pre">pyfits</span></tt> and <tt class="docutils literal"><span class="pre">numpy</span></tt> objects are available to the programmer, 
<tt class="docutils literal"><span class="pre">AstroData</span></tt> provides analogous methods for most <tt class="docutils literal"><span class="pre">pyfits</span></tt> functionalities 
which allows it to maintain the dataset  as a cohesive whole. The programmer 
does however use the <tt class="docutils literal"><span class="pre">numpy.ndarrays</span></tt> directly for pixel manipulation.
Simple AstroData arithmetic is also provided by the <tt class="docutils literal"><span class="pre">astrodata.adutils.arith</span></tt> 
module which implement AstroData methods for addition, subtraction, multiplication 
and division.</p>
<p>In order to identify types of dataset and provide type-specific behavior,
<tt class="docutils literal"><span class="pre">AstroData</span></tt> relies on configuration packages either in the <tt class="docutils literal"><span class="pre">PYTHONPATH</span></tt> environment
variable or the <tt class="docutils literal"><span class="pre">Astrodata</span></tt> package environment variables, <tt class="docutils literal"><span class="pre">ADCONFIGPATH</span></tt> and
<tt class="docutils literal"><span class="pre">RECIPEPATH</span></tt>. A configuration package (eg. <tt class="docutils literal"><span class="pre">astrodata_Gemini</span></tt>) contains definitions for
all instruments and modes. A configuration package contains type
definitions, meta-data functions, information lookup tables, and any other code
or information needed to handle specific types of dataset.</p>
<p>This allows <tt class="docutils literal"><span class="pre">AstroData</span></tt> to manage access to the dataset for convenience and
consistency. For example, <tt class="docutils literal"><span class="pre">AstroData</span></tt> is able:</p>
<ul class="simple">
<li>to allow reduction scripts to have easy access to dataset classification 
information in a consistent way across all instruments and modes;</li>
<li>to provide consistent interfaces for obtaining common meta-data across all
instruments and modes;</li>
<li>to relate internal extensions, e.g. discriminate between science and 
variance arrays and associate them properly;</li>
<li>to help propagate header-data units important to the given instrument mode,
but unknown to general purpose transformations.</li>
</ul>
<p>In general, the purpose of <tt class="docutils literal"><span class="pre">AstroData</span></tt> is to provide smart dataset-oriented interfaces
that adapt to dataset type. The primary interfaces are for file
handling, dataset-type checking, and managing meta-data, but <tt class="docutils literal"><span class="pre">AstroData</span></tt> also
integrates other functionalities.</p>
<dl class="method">
<dt id="AstroData.AstroData.add">
<tt class="descname">add</tt><big>(</big><em>input_b</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.add" title="Permalink to this definition">¶</a></dt>
<dd><p>The add function uses numpy.add to add input_b to an AstroData object
(input_a), where input_b could be either another AstroData object, a
dictionary, list, float or integer, or a DescriptorValue (DV) object.</p>
<p>If input_b is an AstroData object, the add function will add each science
extension in the input AstroData object (input_a) with the corresponding
science extension in input_b and update the variance and data quality
extensions accordingly.</p>
<p>If input_b is a dictionary, float, integer or a DescriptorValue object, the
corresponding single value is added to each science extension in the input
AstroData object (input_a).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>input_a</strong> (<a class="reference internal" href="ref.html#module-AstroData" title="AstroData"><em>AstroData</em></a>) &#8211; input AstroData object to be operated on by input_b</li>
<li><strong>input_b</strong> (<em>AstroData, dictionary, list, float, integer, DescriptorValue</em>) &#8211; input value to operate on the input AstroData object
(input_a). This value can be an AstroData object, a
dictionary, where the key is either the (EXTNAME, EXTVER)
tuple or an EXTVER integer for each science extension and
the value is a float or integer, a list of floats or
integers, where the values in the list correspond to the
science extensions in numerical order, a single float or
integer, or a DescriptorValue object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.append">
<tt class="descname">append</tt><big>(</big><em>moredata=None</em>, <em>data=None</em>, <em>header=None</em>, <em>auto_number=False</em>, <em>do_deepcopy=False</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.append" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>moredata</strong> (<em>pyfits.HDU, pyfits.HDUList, or AstroData</em>) &#8211; either an AstroData instance, an HDUList instance, 
or an HDU instance to add to this AstroData object.
When present, data and header arguments will be ignored.</li>
<li><strong>data</strong> (<em>numpy.ndarray</em>) &#8211; <tt class="docutils literal"><span class="pre">data</span></tt> and <tt class="docutils literal"><span class="pre">header</span></tt> are used to construct a new HDU which is then 
added to the <tt class="docutils literal"><span class="pre">HDUList</span></tt> associated to the <tt class="docutils literal"><span class="pre">AstroData</span></tt> instance. The <tt class="docutils literal"><span class="pre">data</span></tt> 
argument should be set
to a valid <tt class="docutils literal"><span class="pre">numpy</span></tt> array. If <tt class="docutils literal"><span class="pre">modedata</span></tt> is not specified, <tt class="docutils literal"><span class="pre">data</span></tt> and <tt class="docutils literal"><span class="pre">header</span></tt>
must both be set.</li>
<li><strong>header</strong> (<em>pyfits.Header</em>) &#8211; <tt class="docutils literal"><span class="pre">data</span></tt> and <tt class="docutils literal"><span class="pre">header</span></tt> are used
to construct a new HDU which is then added to the <tt class="docutils literal"><span class="pre">HDUList</span></tt> associated to 
<tt class="docutils literal"><span class="pre">AstroData</span></tt> instance. The <tt class="docutils literal"><span class="pre">header</span></tt> argument should be set to a
valid <tt class="docutils literal"><span class="pre">pyfits.Header</span></tt> object. If <tt class="docutils literal"><span class="pre">moredata</span></tt> is not specified, <tt class="docutils literal"><span class="pre">data</span></tt> and
<tt class="docutils literal"><span class="pre">header</span></tt> must both be set.</li>
<li><strong>auto_number</strong> (<em>boolean</em>) &#8211; auto-increment the extension version, <tt class="docutils literal"><span class="pre">EXTVER</span></tt>, to fit file convention</li>
<li><strong>extname</strong> (<em>string</em>) &#8211; extension name as set in keyword <tt class="docutils literal"><span class="pre">EXTNAME</span></tt> (eg. &#8216;SCI&#8217;, &#8216;VAR&#8217;, &#8216;DQ&#8217;)
This is used only when <tt class="docutils literal"><span class="pre">header</span></tt> and <tt class="docutils literal"><span class="pre">data</span></tt> are used and <tt class="docutils literal"><span class="pre">moredata</span></tt> is
empty.</li>
<li><strong>extver</strong> (<em>int</em>) &#8211; extension version as set in keyword <tt class="docutils literal"><span class="pre">EXTVER</span></tt>.
This is used only when <tt class="docutils literal"><span class="pre">header</span></tt> and <tt class="docutils literal"><span class="pre">data</span></tt> are used and <tt class="docutils literal"><span class="pre">moredata</span></tt> is
empty.</li>
<li><strong>do_deepcopy</strong> (<em>boolean</em>) &#8211; deepcopy the input before appending.  Might be useful
when auto_number is True and the input comes from another AD object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This function appends header-data units (HDUs) to the AstroData
instance.</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#AstroData.AstroData.close" title="Permalink to this definition">¶</a></dt>
<dd><p>The close(..) function will close the <tt class="docutils literal"><span class="pre">HDUList</span></tt> associated with this
<tt class="docutils literal"><span class="pre">AstroData</span></tt> instance.</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.count_exts">
<tt class="descname">count_exts</tt><big>(</big><em>extname=None</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.count_exts" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>extname</strong> (<em>string</em>) &#8211; the name of the extension, equivalent to the
value associated with the &#8220;EXTNAME&#8221; key in the extension 
header.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">number of extensions of that name</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
<p>The count_exts(..) function counts the extensions of a given name
(as stored in the HDUs &#8220;EXTNAME&#8221; header).</p>
</dd></dl>

<dl class="attribute">
<dt id="AstroData.AstroData.data">
<tt class="descname">data</tt><a class="headerlink" href="#AstroData.AstroData.data" title="Permalink to this definition">¶</a></dt>
<dd><p>The data property can only be used for single-HDU AstroData
instances, such as those returned during iteration. It is a property
attribute which uses <em>get_data(..)</em> and <em>set_data(..)</em> to access the
data members with &#8220;=&#8221; syntax. To set the data member, use <em>ad.data =
newdata</em>, where <em>newdata</em> must be a numpy array. To get the data
member, use <em>npdata = ad.data</em>.</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.discover_status">
<tt class="descname">discover_status</tt><big>(</big><big>)</big><a class="headerlink" href="#AstroData.AstroData.discover_status" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns the set of processing types applicable to 
this dataset.
:returns: a list of classification name strings
:rtype: list of strings</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.discover_types">
<tt class="descname">discover_types</tt><big>(</big><em>all=False</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.discover_types" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>all</strong> &#8211; a flag which  controls how the classes are returned... if
True, then the function will return a dictionary of three lists,
&#8216;all&#8217;, &#8216;status&#8217;, and &#8216;typology&#8217;.  If False, the return value is a
list which is in fact the &#8216;all&#8217; list, containing all the status and
typology related types together.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a list of DataClassification objects, or a dictionary of lists
if the C{all} flag is set.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list | dict</td>
</tr>
</tbody>
</table>
<p>This function provides a list of classifications of both processing
status and typology which apply to the data encapsulated by this
instance,  identified by their string names.</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.discover_typology">
<tt class="descname">discover_typology</tt><big>(</big><big>)</big><a class="headerlink" href="#AstroData.AstroData.discover_typology" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns a list of classification names
for typology related classifications, as apply to this
dataset.
:return: DataClassification objects in a list
:rtype: list</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.div">
<tt class="descname">div</tt><big>(</big><em>denominator</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.div" title="Permalink to this definition">¶</a></dt>
<dd><p>The div function uses numpy.divide to divide an AstroData object (input_a)
by input_b, where input_b could be either another AstroData object, a
dictionary, list, float or integer, or a DescriptorValue (DV) object.</p>
<p>If input_b is an AstroData object, the div function will divide each
science extension in the input AstroData object (input_a) with the
corresponding science extension in input_b and update the variance and data
quality extensions accordingly.</p>
<p>If input_b is a dictionary, float, integer or a DescriptorValue object,
each science extension in the input AstroData object (input_a) is divided
by the corresponding single value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>input_a</strong> (<a class="reference internal" href="ref.html#module-AstroData" title="AstroData"><em>AstroData</em></a>) &#8211; input AstroData object to be operated on by input_b</li>
<li><strong>input_b</strong> (<em>AstroData, dictionary, list, float, integer, DescriptorValue</em>) &#8211; input value to operate on the input AstroData object
(input_a). This value can be an AstroData object, a
dictionary, where the key is either the (EXTNAME, EXTVER)
tuple or an EXTVER integer for each science extension and
the value is a float or integer, a list of floats or
integers, where the values in the list correspond to the
science extensions in numerical order, a single float or
integer, or a DescriptorValue object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.ext_get_key_value">
<tt class="descname">ext_get_key_value</tt><big>(</big><em>extension</em>, <em>key</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.ext_get_key_value" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>extension</strong> (<em>int or (EXTNAME, EXTVER) tuple</em>) &#8211; identifies which extension, either an integer index 
or (EXTNAME, EXTVER) tuple</li>
<li><strong>key</strong> (<em>string</em>) &#8211; name of header entry to retrieve</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">string</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the value associated with the key, or None if not present</p>
</td>
</tr>
</tbody>
</table>
<p>This function returns the value from the given extension&#8217;s
header, with &#8220;0&#8221; being the first data extension.  To get
values from the PHU use phu_get_key_value(..).</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.ext_set_key_value">
<tt class="descname">ext_set_key_value</tt><big>(</big><em>extension=None</em>, <em>keyword=None</em>, <em>value=None</em>, <em>comment=None</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.ext_set_key_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Add or update a keyword in the header of an extension of the AstroData
object with a specific value and, optionally, a comment. To add or
update a keyword in the PHU of the AstroData object, use
phu_set_key_value().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>extension</strong> (<em>int or (EXTNAME, EXTVER) tuple</em>) &#8211; Name of the extension to add or update. The index [0]
refers to the first extension in the AstroData
object.</li>
<li><strong>keyword</strong> (<em>string</em>) &#8211; Name of the keyword to add or update in the extension</li>
<li><strong>value</strong> (<em>int, float or string</em>) &#8211; Value of the keyword to add or update in the extension</li>
<li><strong>comment</strong> (<em>string</em>) &#8211; Comment of the keyword to add or update in the
extension</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="AstroData.AstroData.filename">
<tt class="descname">filename</tt><a class="headerlink" href="#AstroData.AstroData.filename" title="Permalink to this definition">¶</a></dt>
<dd><p>The filename member is monitored so that the mode can be changed from readonly when the filename is changed.</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.get_classification_library">
<tt class="descname">get_classification_library</tt><big>(</big><big>)</big><a class="headerlink" href="#AstroData.AstroData.get_classification_library" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will return a handle to the ClassificationLibrary.  
NOTE: the ClassificationLibrary is a singleton, this call will either
return the currently extant instance or, if not extant,
will create the classification library (using the default context).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A reference to the system classification library</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">L{ClassificationLibrary}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.get_data">
<tt class="descname">get_data</tt><big>(</big><big>)</big><a class="headerlink" href="#AstroData.AstroData.get_data" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">data array associated with the single extension</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">pyfits.ndarray</td>
</tr>
</tbody>
</table>
<p>The <tt class="docutils literal"><span class="pre">get_data(..)</span></tt> member is the function behind the property-style
&#8220;data&#8221; member and returns appropriate HDU&#8217;s data member(s) specifically
for the case in which the <tt class="docutils literal"><span class="pre">AstroData</span></tt> instance has ONE HDU (in addition to
the PHU). This allows a single-extension <tt class="docutils literal"><span class="pre">AstroData</span></tt>, such as <tt class="docutils literal"><span class="pre">AstroData</span></tt>
generates through iteration,  to be used as though it simply is just the
one extension, e.g. allowing <tt class="docutils literal"><span class="pre">ad.data</span></tt> to be used in place of the more
esoteric and ultimately more dangerous <tt class="docutils literal"><span class="pre">ad[0].data</span></tt>. One
is dealing with single extension <tt class="docutils literal"><span class="pre">AstroData</span></tt> instances when iterating over
the <tt class="docutils literal"><span class="pre">AstroData</span></tt> extensions and when picking out an extension by integer
or tuple indexing, e.g.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">ad</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">[</span><span class="n">SCI</span><span class="p">]:</span>
    <span class="c"># ad is a single-HDU index</span>
    <span class="n">ad</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">newdata</span>

<span class="c"># assuming the named extension exists,</span>
<span class="c"># sd will be a single-HDU AstroData</span>
<span class="n">sd</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[(</span><span class="s">&quot;SCI&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.get_hdu">
<tt class="descname">get_hdu</tt><big>(</big><em>extid</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.get_hdu" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>extid</strong> (<em>int | tuple</em>) &#8211; specifies the extention (pyfits.HDU) to return.</td>
</tr>
</tbody>
</table>
<p>:returns:the extension specified
:rtype:pyfits.HDU</p>
<p>This function returns the HDU identified by the C{extid} argument. This
argument can be an integer or (EXTNAME, EXTVER) tuple.</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.get_hdulist">
<tt class="descname">get_hdulist</tt><big>(</big><big>)</big><a class="headerlink" href="#AstroData.AstroData.get_hdulist" title="Permalink to this definition">¶</a></dt>
<dd><p>This function retrieves the HDUList. NOTE: The HDUList should also be
&#8216;released&#8217; by calling L{release_hdulist}, as access is reference
counted. This function is also aliased to L{get_hdulist(..)&lt;get_hdulist&gt;}.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The AstroData&#8217;s HDUList as returned by pyfits.open()</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">pyfits.HDUList</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.get_header">
<tt class="descname">get_header</tt><big>(</big><em>extension=None</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.get_header" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">header</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">pyfits.Header</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Raises Errors.SingleHDUMemberExcept:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">Will raise an exception if more
than one extension exists. 
(note: The PHU is not considered an extension in this case)</td>
</tr>
</tbody>
</table>
<p>The <tt class="docutils literal"><span class="pre">get_header(..)</span></tt> function returns the header member for Single-HDU
<tt class="docutils literal"><span class="pre">AstroData</span></tt> instances (which are those that have only one extension plus
PHU). This case  can be assured when iterating over extensions using
<tt class="docutils literal"><span class="pre">AstroData</span></tt>, e.g.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">ad</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">[</span><span class="n">SCI</span><span class="p">]:</span> 
    <span class="o">...</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.get_headers">
<tt class="descname">get_headers</tt><big>(</big><big>)</big><a class="headerlink" href="#AstroData.AstroData.get_headers" title="Permalink to this definition">¶</a></dt>
<dd><p>Function returns header member(s) for all extension (except PHU).
:return: list of pyfits.Header instances
:rtype: pyfits.Header</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.get_int_ext">
<tt class="descname">get_int_ext</tt><big>(</big><em>extension</em>, <em>hduref=False</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.get_int_ext" title="Permalink to this definition">¶</a></dt>
<dd><p>getInxExt takes an extension index, either an integer
or (EXTNAME, EXTVER) tuple, and returns the index location
of the extension.  If hduref is set to True, then the index
returned is relative to the HDUList (0=PHU, 1=First non-PHU extension).
If hduref == False (the default) then the index returned is relative to 
the AstroData numbering convention, where index=0 is the first non-PHU
extension in the MEF file.</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.get_key_value">
<tt class="descname">get_key_value</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.get_key_value" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>key</strong> (<em>string</em>) &#8211; name of header value to set</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the specified value</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">string</td>
</tr>
</tbody>
</table>
<p>The get_key_value(..) function is used to get the value associated
with a given key in the data-header unit of a single-HDU
AstroData instance (such as returned by iteration). The value argument
will be converted to string, so it must have a string operator member
function or be passed in as string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note :</th><td class="field-body"><p class="first">Single extension AstroData objects are those with only a single
header-data unit besides the PHU.  They may exist if a single
extension file is loaded, but in general are produced by indexing or
iteration instructions, i.e.:</p>
<blockquote>
<div><p>sead = ad[(&#8220;SCI&#8221;,1)]</p>
<dl class="docutils">
<dt>for sead in ad[&#8220;SCI&#8221;]:</dt>
<dd><p class="first last">...</p>
</dd>
</dl>
</div></blockquote>
<p class="last">The variable &#8220;sead&#8221; above is ensured to hold a single extension
AstroData object, and can be used more convieniently.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.get_status">
<tt class="descname">get_status</tt><big>(</big><em>prune=False</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.get_status" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns the set of type names (strings) which apply to
this dataset and which come from the status section of the AstroData
Type library. &#8216;Status&#8217; classifications are those which tend to change
during the reduction of a dataset based on the amount of processing,
e.g. RAW vs PREPARED.  Strictly, a &#8216;status&#8217; type 
is any type defined in or below the status part of the 
<tt class="docutils literal"><span class="pre">classification</span></tt> directory within the 
configuration package. For example, in the Gemini type configuration 
this means any type 
definition files in or below the 
&#8216;astrodata_Gemini/ADCONFIG/classification/status&#8217; directory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a list of string classification names</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list of strings</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.get_types">
<tt class="descname">get_types</tt><big>(</big><em>prune=False</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.get_types" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>prune</strong> (<em>bool</em>) &#8211; flag which controls &#8216;pruning&#8217; the returned type list 
so that only the leaf node type for a given set of related types
is returned.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a list of classification names that apply to this data</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list of strings</td>
</tr>
</tbody>
</table>
<p>The get_types(..) function returns a list of type names, where type 
names are as always, strings. It is possible to &#8216;prune&#8217; the list so
that only leaf nodes are returned, which is useful when leaf
nodes take precedence such
as for descriptors.</p>
<p>Note: types are divided into two categories, one intended for types
which represent processing status (i.e. RAW vs PREPARED), and another
which contains a more traditional &#8216;typology&#8217; consisting of a 
hierarchical tree of dataset types. This latter tree maps roughly to
instrument-modes, with instrument types branching from the general
observatory type, (e.g. &#8216;GEMINI&#8217;).</p>
<p>To retrieve only status types, use get_status(..); to retreive just
typological types use get_typology(..).  Note that the system does not
enforce what checks are actually performed by types in each category,
that is, one could miscategorize a type when authoring a configuration
package. Both classifications use the same DataClassification objects
to classify datasets. It is up to  those implementing the
type-specific configuration package to ensure types related to status
appear in the correct part of the configuration space.</p>
<p>Currently the distinction betwen status and typology is not used by the
system (e.g. in type-specific default recipe assignments) and is
provided as a service for higher level code, e.g. primitives and
scripts which make use of the distinction.</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.get_typology">
<tt class="descname">get_typology</tt><big>(</big><em>prune=False</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.get_typology" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns the set of type names (strings) which apply to
this dataset and which come from the typology section of the AstroData
Type library. &#8216;Typology&#8217; classifications are those which tend to remain
with the data in spite of reduction status, e.g. those related to the
instrument-mode of the dataset or of the datasets used to produce
it. Strictly these consist of any type defined in or below
the correct configuration directory, for example, in Gemini&#8217;s configuration
package, it would be anything in the
&#8220;astrodata_Gemini/ADCONFIG/classification/types&#8221;  directory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a list of classification name strings</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list of strings</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="AstroData.AstroData.header">
<tt class="descname">header</tt><a class="headerlink" href="#AstroData.AstroData.header" title="Permalink to this definition">¶</a></dt>
<dd><p>The header property can only be used for single-HDU AstroData
instances, such as those returned during iteration. It is a
property attribute which uses <em>get_header(..)</em> and
<em>set_header(..)</em> to access the header member with the &#8220;=&#8221; syntax.
To set the header member, use <em>ad.header = newheader</em>, where
<em>newheader</em> must be a pyfits.Header object. To get the header
member, use <em>hduheader = ad.header</em>.</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.info">
<tt class="descname">info</tt><big>(</big><em>oid=False</em>, <em>table=False</em>, <em>help=False</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.info" title="Permalink to this definition">¶</a></dt>
<dd><p>The info(..) function prints to the shell information regarding
the phu and the extensions found in an AstroData object.  It is a 
high-level wrappers for <tt class="docutils literal"><span class="pre">infostr(..)</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.infostr">
<tt class="descname">infostr</tt><big>(</big><em>as_html=False</em>, <em>oid=False</em>, <em>table=False</em>, <em>help=False</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.infostr" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>as_html</strong> (<em>bool</em>) &#8211; return as HTML formatted string</li>
<li><strong>oid</strong> (<em>bool</em>) &#8211; include object id</li>
<li><strong>help</strong> (<em>bool</em>) &#8211; include sub-data reference information</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The infostr(..) function is used to get a string ready for display
either as plain text or HTML.  It provides AstroData-relative
information.</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.insert">
<tt class="descname">insert</tt><big>(</big><em>index</em>, <em>moredata=None</em>, <em>data=None</em>, <em>header=None</em>, <em>auto_number=False</em>, <em>extname=None</em>, <em>extver=False</em>, <em>do_deepcopy=False</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.insert" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>index</strong> (<em>integer or (EXTNAME,EXTVER) tuple</em>) &#8211; the extension index, either an int or (EXTNAME, EXTVER)
pair before which the extension is to be inserted. Note, the 
first data extension is [0], you cannot insert before the PHU.
Index always refers to Astrodata Numbering system, 0 = HDU</li>
<li><strong>moredata</strong> (<em>pyfits.HDU, pyfits.HDUList, or AstroData</em>) &#8211; Either an AstroData instance, an HDUList instance, or
an HDU instance. When present, data and header will be ignored.</li>
<li><strong>data</strong> (<em>numpy.ndarray</em>) &#8211; <tt class="docutils literal"><span class="pre">data</span></tt> and <tt class="docutils literal"><span class="pre">header</span></tt> are used to construct a new HDU which is then 
added to the <tt class="docutils literal"><span class="pre">HDUList</span></tt> associated to the <tt class="docutils literal"><span class="pre">AstroData</span></tt> instance. The <tt class="docutils literal"><span class="pre">data</span></tt> 
argument should be set
to a valid <tt class="docutils literal"><span class="pre">numpy</span></tt> array. If <tt class="docutils literal"><span class="pre">modedata</span></tt> is not specified, <tt class="docutils literal"><span class="pre">data</span></tt> and <tt class="docutils literal"><span class="pre">header</span></tt>
must both be set.</li>
<li><strong>header</strong> (<em>pyfits.Header</em>) &#8211; <tt class="docutils literal"><span class="pre">data</span></tt> and <tt class="docutils literal"><span class="pre">header</span></tt> are used
to construct a new HDU which is then added to the <tt class="docutils literal"><span class="pre">HDUList</span></tt> associated to 
<tt class="docutils literal"><span class="pre">AstroData</span></tt> instance. The <tt class="docutils literal"><span class="pre">header</span></tt> argument should be set to a
valid <tt class="docutils literal"><span class="pre">pyfits.Header</span></tt> object. If <tt class="docutils literal"><span class="pre">moredata</span></tt> is not specified, <tt class="docutils literal"><span class="pre">data</span></tt> and
<tt class="docutils literal"><span class="pre">header</span></tt> must both be set.</li>
<li><strong>auto_number</strong> (<em>boolean</em>) &#8211; auto-increment the extension version, <tt class="docutils literal"><span class="pre">EXTVER</span></tt>, to fit file convention</li>
<li><strong>do_deepcopy</strong> (<em>boolean</em>) &#8211; deepcopy the input before appending.  Might be useful
when auto_number is True and the input comes from another AD object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This function inserts header-data units (HDUs) to the AstroData
instance.</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.is_type">
<tt class="descname">is_type</tt><big>(</big><em>*typenames</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.is_type" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>typenames</strong> (<em>string or list of strings</em>) &#8211; specifies the type name to check.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal"><span class="pre">True</span></tt> if the given types all apply to this dataset,
<tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Bool</td>
</tr>
</tbody>
</table>
<p>This function checks the <tt class="docutils literal"><span class="pre">AstroData</span></tt> object to see if it is the
given type(s) and returns True if so.  If a list of types is given
as inputs, all the types must match the <tt class="docutils literal"><span class="pre">AstroData</span></tt> object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note :</th><td class="field-body"><tt class="docutils literal"><span class="pre">AstroData.check_type(..)</span></tt> is an alias for 
<tt class="docutils literal"><span class="pre">AstroData.is_type(..)</span></tt>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.ishdu">
<tt class="descname">ishdu</tt><big>(</big><em>md=None</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.ishdu" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks to see if md (moredata) is acutally an hdu.
:returns: True or False
:rtype: boolean</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.moredata_work">
<tt class="descname">moredata_work</tt><big>(</big><em>append=False</em>, <em>insert=False</em>, <em>autonum=False</em>, <em>md=None</em>, <em>hduindx=None</em>, <em>hdul=None</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.moredata_work" title="Permalink to this definition">¶</a></dt>
<dd><p>create a master table out of the host and update the EXTVER 
for the guest as it is being updated in the table</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.mult">
<tt class="descname">mult</tt><big>(</big><em>input_b</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.mult" title="Permalink to this definition">¶</a></dt>
<dd><p>The mult function uses numpy.multiply to multiply an AstroData object
(input_a) by input_b, where input_b could be either another AstroData
object, a dictionary, list, float or integer, or a DescriptorValue (DV)
object.</p>
<p>If input_b is an AstroData object, the mult function will multiply each
science extension in the input AstroData object (input_a) with the
corresponding science extension in input_b and update the variance and data
quality extensions accordingly.</p>
<p>If input_b is a dictionary, float, integer or a DescriptorValue object,
each science extension in the input AstroData object (input_a) is
multiplied by the corresponding single value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>input_a</strong> (<a class="reference internal" href="ref.html#module-AstroData" title="AstroData"><em>AstroData</em></a>) &#8211; input AstroData object to be operated on by input_b</li>
<li><strong>input_b</strong> (<em>AstroData, dictionary, list, float, integer, DescriptorValue</em>) &#8211; input value to operate on the input AstroData object
(input_a). This value can be an AstroData object, a
dictionary, where the key is either the (EXTNAME, EXTVER)
tuple or an EXTVER integer for each science extension and
the value is a float or integer, a list of floats or
integers, where the values in the list correspond to the
science extensions in numerical order, a single float or
integer, or a DescriptorValue object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.next">
<tt class="descname">next</tt><big>(</big><big>)</big><a class="headerlink" href="#AstroData.AstroData.next" title="Permalink to this definition">¶</a></dt>
<dd><p>This function exists so that AstroData can be used as an iterator.
This function returns the objects &#8220;ext&#8221; in the following line:</p>
<p>for ext in gemdatainstance:</p>
<p>If this AstroData instance is associated with a subset of the data in
the MEF to which it refers, then this iterator goes through that subset
in order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a single extension AstroData instance representing the
&#8216;current&#8217; extension in the AstroData iteration loop.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">AstroData</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.onehdu_work">
<tt class="descname">onehdu_work</tt><big>(</big><em>append=False</em>, <em>insert=False</em>, <em>replace=False</em>, <em>extver=None</em>, <em>extname=None</em>, <em>header=None</em>, <em>data=None</em>, <em>autonum=False</em>, <em>hduindx=None</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.onehdu_work" title="Permalink to this definition">¶</a></dt>
<dd><p>does extension work for one HDU</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.open">
<tt class="descname">open</tt><big>(</big><em>source</em>, <em>mode='readonly'</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.open" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>source</strong> (<em>string | AstroData | pyfits.HDUList</em>) &#8211; source contains some reference for the dataset to 
be opened and associated with this instance. Generally
it would be a filename, but can also be
an AstroData instance or a pyfits.HDUList instance.</li>
<li><strong>mode</strong> (<em>string</em>) &#8211; IO access mode, same as the pyfits open mode, &#8216;readonly,
&#8216;update&#8217;, or &#8216;append&#8217;.  The mode is passed to pyfits so
if it is an illegal mode name, pyfits will be the
subsystem reporting the error.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This function wraps a source dataset, which can be in memory as another
AstroData or pyfits HDUList, or on disk, given as the string filename.</p>
<p>Please note that generally one does not use &#8216;open&#8217; directly, but passes
the filename to the AstroData constructor. The constructor uses
open(..) however.  Most users should use the constructor, which may 
perform extra operations.</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.phu_get_key_value">
<tt class="descname">phu_get_key_value</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.phu_get_key_value" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>key</strong> (<em>string</em>) &#8211; name of header value to retrieve</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">string</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the key&#8217;s value as string or None if not present.</td>
</tr>
</tbody>
</table>
<p>The phu_get_key_value(..) function returns the value associated with the
given key within the primary header unit
of the dataset. The value is returned as a string (storage format)
and must be converted as necessary by the caller.</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.phu_set_key_value">
<tt class="descname">phu_set_key_value</tt><big>(</big><em>keyword=None</em>, <em>value=None</em>, <em>comment=None</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.phu_set_key_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Add or update a keyword in the PHU of the AstroData object with a
specific value and, optionally, a comment</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>keyword</strong> (<em>string</em>) &#8211; Name of the keyword to add or update in the PHU</li>
<li><strong>value</strong> (<em>int, float or string</em>) &#8211; Value of the keyword to add or update in the PHU</li>
<li><strong>comment</strong> (<em>string</em>) &#8211; Comment of the keyword to add or update in the PHU</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.re_phukeys">
<tt class="descname">re_phukeys</tt><big>(</big><em>rekey</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.re_phukeys" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rekey</strong> (<em>string</em>) &#8211; A regular expression</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a list of keys from the PHU that matched C{rekey}</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
</tbody>
</table>
<p>The re_phukeys(..) function returns all keys in this dataset&#8217;s PHU 
which match the given  regular expression.</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.release_hdulist">
<tt class="descname">release_hdulist</tt><big>(</big><big>)</big><a class="headerlink" href="#AstroData.AstroData.release_hdulist" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will release a reference to the HDUList... don&#8217;t call 
unless you have called L{get_hdulist} at some prior point. 
(Note, release_hdulist is aliased to L{release_hdulist(..)&lt;release_hdulist&gt;})</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.remove">
<tt class="descname">remove</tt><big>(</big><em>index</em>, <em>hdui=False</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.remove" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>index</strong> (<em>integer or (EXTNAME,EXTVER) tuple</em>) &#8211; the extension index, either an int or (EXTNAME, EXTVER)
pair before which the extension is to be inserted. Note, the 
first data extension is [0], you cannot insert before the PHU.
Index always refers to Astrodata Numbering system, 0 = HDU</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.rename_ext">
<tt class="descname">rename_ext</tt><big>(</big><em>name</em>, <em>ver=None</em>, <em>force=True</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.rename_ext" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>string</em>) &#8211; New &#8216;EXTNAME&#8217; for the given extension.</li>
<li><strong>ver</strong> (<em>int</em>) &#8211; New &#8216;EXTVER&#8217; for the given extension</li>
<li><strong>force</strong> (<em>boolean</em>) &#8211; ???  Default=True</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Note: This member only works on single extension <tt class="docutils literal"><span class="pre">AstroData</span></tt> instances.</p>
<p>The <tt class="docutils literal"><span class="pre">rename_ext(..)</span></tt> function is used in order to rename an HDU with a new
EXTNAME and EXTVER identifier.  Merely changing the EXTNAME and 
EXTEVER values in the extensions <tt class="docutils literal"><span class="pre">pyfits.Header</span></tt> are not sufficient.
Though the values change in the <tt class="docutils literal"><span class="pre">pyfits.Header</span></tt> object, there are special
HDU class members which are not updated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Warning :</th><td class="field-body">This function manipulates private (or somewhat private)  HDU
members, specifically &#8216;name&#8217; and &#8216;_extver&#8217;. STSCI has been
informed of the issue and
has made a special HDU function for performing the renaming. 
When generally available, this new function will be used instead of
manipulating the  HDU&#8217;s properties directly, and this function will 
call the new <tt class="docutils literal"><span class="pre">pyfits.HDUList(..)</span></tt> function.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.setExtname">
<tt class="descname">setExtname</tt><big>(</big><em>name</em>, <em>ver=None</em>, <em>force=True</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.setExtname" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>string</em>) &#8211; New &#8216;EXTNAME&#8217; for the given extension.</li>
<li><strong>ver</strong> (<em>int</em>) &#8211; New &#8216;EXTVER&#8217; for the given extension</li>
<li><strong>force</strong> (<em>boolean</em>) &#8211; ???  Default=True</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Note: This member only works on single extension <tt class="docutils literal"><span class="pre">AstroData</span></tt> instances.</p>
<p>The <tt class="docutils literal"><span class="pre">rename_ext(..)</span></tt> function is used in order to rename an HDU with a new
EXTNAME and EXTVER identifier.  Merely changing the EXTNAME and 
EXTEVER values in the extensions <tt class="docutils literal"><span class="pre">pyfits.Header</span></tt> are not sufficient.
Though the values change in the <tt class="docutils literal"><span class="pre">pyfits.Header</span></tt> object, there are special
HDU class members which are not updated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Warning :</th><td class="field-body">This function manipulates private (or somewhat private)  HDU
members, specifically &#8216;name&#8217; and &#8216;_extver&#8217;. STSCI has been
informed of the issue and
has made a special HDU function for performing the renaming. 
When generally available, this new function will be used instead of
manipulating the  HDU&#8217;s properties directly, and this function will 
call the new <tt class="docutils literal"><span class="pre">pyfits.HDUList(..)</span></tt> function.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.set_data">
<tt class="descname">set_data</tt><big>(</big><em>newdata</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.set_data" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>newdata</strong> (<em>numpy.ndarray</em>) &#8211; new data objects</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Raises Errors.SingleHDUMemberExcept:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">if AstroData instance has more 
than one extension (not including PHU).</td>
</tr>
</tbody>
</table>
<p>This function sets the data member of a data section of an <tt class="docutils literal"><span class="pre">AstroData</span></tt>
object, specifically for the case in which the <tt class="docutils literal"><span class="pre">AstroData</span></tt> instance has
ONE header-data unit (in addition to PHU).  This case is assured when
iterating over the <tt class="docutils literal"><span class="pre">AstroData</span></tt> extensions, as in:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">ad</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">[</span><span class="n">SCI</span><span class="p">]:</span>
    <span class="o">...</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.set_header">
<tt class="descname">set_header</tt><big>(</big><em>header</em>, <em>extension=None</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.set_header" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>header</strong> (<em>pyfits.Header</em>) &#8211; pyfits Header to set for given extension</li>
<li><strong>extension</strong> (<em>int or tuple, pyfits compatible extension index</em>) &#8211; Extension index to retrieve header, if None
or not present then this must be a single extension AstroData
instance, which contains just the PHU and a single data extension,
and the data extension&#8217;s header is returned.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Raises Errors.SingleHDUMemberExcept:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first last">Will raise an exception if more 
than one extension exists.</p>
</td>
</tr>
</tbody>
</table>
<p>The <tt class="docutils literal"><span class="pre">set_header(..)</span></tt> function sets the extension header member for single
extension (which are those that have only one extension plus PHU). This
case  is assured when iterating over extensions using <tt class="docutils literal"><span class="pre">AstroData</span></tt>, e.g.:</p>
<blockquote>
<div><dl class="docutils">
<dt>for ad in dataset[SCI]: </dt>
<dd>...</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.set_key_value">
<tt class="descname">set_key_value</tt><big>(</big><em>key</em>, <em>value</em>, <em>comment=None</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.set_key_value" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>key</strong> (<em>string</em>) &#8211; name of data header value to set</li>
<li><strong>value</strong> (<em>int, float, string</em>) &#8211; value to apply to header</li>
<li><strong>comment</strong> (<em>string</em>) &#8211; value to be put in the comment part of the header key</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The set_key_value(..) function is used to set the value (and optionally
the comment) associated
with a given key in the data-header of a single-HDU AstroData instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note :</th><td class="field-body"><p class="first">Single extension AstroData objects are those with only a single
header-data unit besides the PHU.  They may exist if a single
extension file is loaded, but in general are produced by indexing or
iteration instructions, i.e.:</p>
<blockquote>
<div><p>sead = ad[(&#8220;SCI&#8221;,1)]</p>
<dl class="docutils">
<dt>for sead in ad[&#8220;SCI&#8221;]:</dt>
<dd><p class="first last">...</p>
</dd>
</dl>
</div></blockquote>
<p class="last">The variable &#8220;sead&#8221; above is ensured to hold a single extension
AstroData object, and can be used more convieniently.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.store_original_name">
<tt class="descname">store_original_name</tt><big>(</big><big>)</big><a class="headerlink" href="#AstroData.AstroData.store_original_name" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will add the key &#8216;ORIGNAME&#8217; to PHU of an astrodata object 
containing the filename when object was instantiated (without any 
directory info, ie. the basename).</p>
<p>If key has all ready been added (ie. has undergone processing where
store_original_name was performed before), then the value original 
filename is just returned.  If the key is there, but does not match
the original filename of the object, then the original name is 
returned, NOT the value in the PHU. The value in the PHU can always be
found using ad.phu_get_key_value(&#8216;ORIGNAME&#8217;).</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.sub">
<tt class="descname">sub</tt><big>(</big><em>input_b</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.sub" title="Permalink to this definition">¶</a></dt>
<dd><p>The sub function uses numpy.subtract to subtract input_b from an AstroData
object (input_a), where input_b could be either another AstroData object, a
dictionary, list, float or integer, or a DescriptorValue (DV) object.</p>
<p>If input_b is an AstroData object, the sub function will subtract each
science extension from input_b from the corresponding science extension in
the input AstroData object (input_a) and update the variance and data
quality extensions accordingly.</p>
<p>If input_b is a dictionary, float, integer or a DescriptorValue object, the
corresponding single value is subtracted from each science extension in the
input AstroData object (input_a).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>input_a</strong> (<a class="reference internal" href="ref.html#module-AstroData" title="AstroData"><em>AstroData</em></a>) &#8211; input AstroData object to be operated on by input_b</li>
<li><strong>input_b</strong> (<em>AstroData, dictionary, list, float, integer, DescriptorValue</em>) &#8211; input value to operate on the input AstroData object
(input_a). This value can be an AstroData object, a
dictionary, where the key is either the (EXTNAME, EXTVER)
tuple or an EXTVER integer for each science extension and
the value is a float or integer, a list of floats or
integers, where the values in the list correspond to the
science extensions in numerical order, a single float or
integer, or a DescriptorValue object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.translate_int_ext">
<tt class="descname">translate_int_ext</tt><big>(</big><em>integer</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.translate_int_ext" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used internally to support AstroData
instances associated with a subset of the full MEF file
associated with this instance. This function, if this instance
is not associated with the entire MEF, will return whatever
is in the extensions list at that index, otherwise, it returns
the integer passed in. In the first case it can be a tuple which
is returned if tuples were used to specify the subset of 
extensions from the MEF which are associated with this instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">int | tuple</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the pyfits-index, relative to the containing HDUList</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.verify_header">
<tt class="descname">verify_header</tt><big>(</big><em>extname=None</em>, <em>extver=None</em>, <em>header=None</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.verify_header" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>extname</strong> (<em>integer</em>) &#8211; extension name (ex, &#8216;SCI&#8217;, &#8216;VAR&#8217;, &#8216;DQ&#8217;)</li>
<li><strong>extver</strong> &#8211; extension version</li>
<li><strong>header</strong> (<em>pyfits.core.Header</em>) &#8211; a valid pyfits.Header object</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This is a helper function for insert, append and replace that compares
the extname argument with the extname in the header. If the key does
not exist it adds it, if its different, it changes it to match the 
argument
:returns header: a validated pyfits.Header object
:rtype: pyfits.core.Header</p>
</dd></dl>

<dl class="method">
<dt id="AstroData.AstroData.write">
<tt class="descname">write</tt><big>(</big><em>filename=None</em>, <em>clobber=False</em>, <em>rename=None</em>, <em>prefix=None</em>, <em>suffix=None</em><big>)</big><a class="headerlink" href="#AstroData.AstroData.write" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> (<em>string</em>) &#8211; name of the file to write to. Optional if the instance
already has a filename defined, which might not be the case for new AstroData
instances created in memory.</li>
<li><strong>clobber</strong> (<em>bool</em>) &#8211; This flag drives if AstroData will overwrite an existing
file.</li>
<li><strong>rename</strong> (<em>bool</em>) &#8211; This flag allows you to write the AstroData instance to
a new filename, but leave the &#8216;current&#8217; name in tact in memory.</li>
<li><strong>prefix</strong> &#8211; Add a prefix to <tt class="docutils literal"><span class="pre">filename</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>type prefix: string
:param suffix: Add a suffix to <tt class="docutils literal"><span class="pre">filename</span></tt>.
type suffix: string</p>
<p>The write function acts similarly to the <tt class="docutils literal"><span class="pre">pyfits</span> <span class="pre">HDUList.writeto(..)</span></tt>
function if a filename is given, or like <tt class="docutils literal"><span class="pre">pyfits.HDUList.update(..)</span></tt> if 
no name is given, using whatever the current name is set to. When a name
is given, this becomes the new name of the <tt class="docutils literal"><span class="pre">AstroData</span></tt> object and
will be used on subsequent calls to  write for which a filename is not
provided. If the <tt class="docutils literal"><span class="pre">clobber</span></tt> flag is <tt class="docutils literal"><span class="pre">False</span></tt> (the default) then <tt class="docutils literal"><span class="pre">write(..)</span></tt>
throws an exception if the file already exists.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="AstroData.correlate">
<tt class="descclassname">AstroData.</tt><tt class="descname">correlate</tt><big>(</big><em>*iary</em><big>)</big><a class="headerlink" href="#AstroData.correlate" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>iary</strong> (<em>list of AstroData instance</em>) &#8211; A list of AstroData instances for which a correlation dictionary
will be constructed.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a list of tuples containing correlated extensions from the arguments.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list of tuples</td>
</tr>
</tbody>
</table>
<p>The <tt class="docutils literal"><span class="pre">correlate(..)</span></tt> function is a module-level helper function which returns
a list of tuples of Single Extension <tt class="docutils literal"><span class="pre">AstroData</span></tt> instances which associate
extensions from each listed AstroData object, to identically named
extensions among the rest of the input array. The <tt class="docutils literal"><span class="pre">correlate(..)</span></tt> function
accepts a variable number of arguments, all of which should be <tt class="docutils literal"><span class="pre">AstroData</span></tt>
instances.</p>
<p>The function returns a structured dictionary of dictionaries of lists of
<tt class="docutils literal"><span class="pre">AstroData</span></tt> objects. For example, given three inputs, <em>ad</em>, <em>bd</em> and <em>cd</em>, all
with three &#8220;SCI&#8221;, &#8220;VAR&#8221; and &#8220;DQ&#8221; extensions. Given <em>adlist = [ad, bd,
cd]</em>, then <em>corstruct = correlate(adlist)</em> will return to <em>corstruct</em> a
dictionary first keyed by the EXTNAME, then keyed by tuple. The contents
(e.g. of <em>corstruct[&#8220;SCI&#8221;][1]</em>) are just a list of AstroData instances each
containing a header-data unit from <em>ad</em>, <em>bd</em>, and <em>cd</em> respectively.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Info :</th><td class="field-body">to appear in the list, all the given arguments must have an extension
with the given (EXTNAME,EXTVER) for that tuple.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="AstroData.prep_output">
<tt class="descclassname">AstroData.</tt><tt class="descname">prep_output</tt><big>(</big><em>input_ary=None</em>, <em>name=None</em>, <em>clobber=False</em><big>)</big><a class="headerlink" href="#AstroData.prep_output" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>input_ary</strong> (<em>list of AstroData Instances</em>) &#8211; The input array from which propagated content (such as
the  source PHU) will be taken. Note: the zero-th element in the list
is  used as the reference dataset for PHU or other items which require
a particular reference.</li>
<li><strong>name</strong> &#8211; File name to use for returned AstroData, optional.</li>
<li><strong>clobber</strong> (<em>bool</em>) &#8211; By default <tt class="docutils literal"><span class="pre">prep_output(..)</span></tt> checks to see if a file of the
given name already exists, and will raise an exception if found.
Set <em>clobber</em> to <em>True</em> to override this behavior and potentially
overwrite the extant file.  The dataset on disk will not be overwritten
as a direct result of prep_output, which only prepares the object
in memory, but will occur when the AstroData object returned is 
written (i.e. <tt class="docutils literal"><span class="pre">ad.write(..)</span></tt>)).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">an <tt class="docutils literal"><span class="pre">AstroData</span></tt> instance initialized with appropriate
header-data units such as the PHU, Standard Gemini headers
and with type-specific associated  data-header units such as
binary table Mask Definition tables (MDF).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">AstroData</p>
</td>
</tr>
</tbody>
</table>
<p>..info: File will not have been written to disk by <tt class="docutils literal"><span class="pre">prep_output(..)</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">prep_output(..)</span></tt> function creates a new <tt class="docutils literal"><span class="pre">AstroData</span></tt> object ready for
appending output information (e.g. <tt class="docutils literal"><span class="pre">ad.append(..)</span></tt>).  While you can also
create an empty <tt class="docutils literal"><span class="pre">AstroData</span></tt> object by giving no arguments to the <tt class="docutils literal"><span class="pre">AstroData</span></tt>
constructor  (i.e. <tt class="docutils literal"><span class="pre">ad</span> <span class="pre">=</span> <span class="pre">AstroData()</span></tt>), <tt class="docutils literal"><span class="pre">prep_output(..)</span></tt> exists for the
common case where a new dataset object is intended as the output of
some processing on a list of source datasets, and some information
from the source inputs must be propagated.</p>
<p>The <tt class="docutils literal"><span class="pre">prep_output(..)</span></tt> function makes use of this knowledge to ensure the
file meets standards in what is considered a complete output file given
such a combination.  In the future this function can make use of dataset
history and structure definitions in the ADCONFIG configuration space. As
<tt class="docutils literal"><span class="pre">prep_output</span></tt> improves, scripts and primitives that use it
will benefit in a forward compatible way, in that their output datasets will
benefit from more automatic propagation, validations, and data flow control,
such as the emergence of history database propagation.</p>
<p>Presently, it already provides the following:</p>
<ul class="simple">
<li>Ensures that all standard headers are in place in the new file, using the
configuration .</li>
<li>Copy the PHU of the reference image (<tt class="docutils literal"><span class="pre">input_ary[0]</span></tt>).</li>
<li>Propagate associated information such as the MDF in the case of a MOS 
observation, configurable by the Astrodata Structures system.</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="AstroData.re_header_keys">
<tt class="descclassname">AstroData.</tt><tt class="descname">re_header_keys</tt><big>(</big><em>rekey</em>, <em>header</em><big>)</big><a class="headerlink" href="#AstroData.re_header_keys" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>rekey</strong> (<em>string</em>) &#8211; a regular expression to match keys in header</li>
<li><strong>header</strong> (<em>pyfits.Header</em>) &#8211; a <tt class="docutils literal"><span class="pre">pyfits.Header</span></tt> object as returned by <tt class="docutils literal"><span class="pre">ad[(&quot;SCI&quot;,1)].header</span></tt></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">a list of matching keys</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list of strings</p>
</td>
</tr>
</tbody>
</table>
<p>This utility function returns a list of keys from 
the input header that match the regular expression.</p>
</dd></dl>

<p>#   ref</p>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Indices and tables</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/adconfig.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="index.html" title="Indices and tables"
             >previous</a> |</li>
        <li><a href="index.html">ADConfig 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010, NZ.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>