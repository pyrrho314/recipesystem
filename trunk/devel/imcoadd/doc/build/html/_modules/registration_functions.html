

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>registration_functions &mdash; imcoadd v0.1 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="imcoadd v0.1 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">imcoadd v0.1 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for registration_functions</h1><div class="highlight"><pre>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pywcs</span>

<span class="kn">from</span> <span class="nn">astrodata.adutils</span> <span class="kn">import</span> <span class="n">gemLog</span>
<span class="kn">from</span> <span class="nn">astrodata.AstroData</span> <span class="kn">import</span> <span class="n">AstroData</span>
<span class="kn">from</span> <span class="nn">astrodata.Errors</span> <span class="kn">import</span> <span class="n">ScienceError</span>
<span class="kn">from</span> <span class="nn">gempy</span> <span class="kn">import</span> <span class="n">managers</span> <span class="k">as</span> <span class="n">man</span>
<span class="kn">from</span> <span class="nn">correlateWithReferenceCatalogs</span> <span class="kn">import</span> <span class="n">match_cxy</span>

<span class="c"># correct_wcs_to_reference_image and align_to_reference_image functions</span>
<span class="c"># will go into geminiScience</span>

<div class="viewcode-block" id="correct_wcs_to_reference_image"><a class="viewcode-back" href="../modules.html#registration_functions.correct_wcs_to_reference_image">[docs]</a><span class="k">def</span> <span class="nf">correct_wcs_to_reference_image</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> 
                                   <span class="n">method</span><span class="o">=</span><span class="s">&#39;sources&#39;</span><span class="p">,</span> <span class="n">fallback</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> 
                                   <span class="n">cull_sources</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                   <span class="n">rotate</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> 
                                   <span class="n">output_names</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s">&#39;_reg&#39;</span><span class="p">,):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function registers images to a reference image by correcting</span>
<span class="sd">    the relative error in their world coordinate systems.  The function</span>
<span class="sd">    uses points of reference common to the reference image and the</span>
<span class="sd">    input images to fit the input WCS to the reference one.  The fit</span>
<span class="sd">    is done by a least-squares minimization of the difference between</span>
<span class="sd">    the reference points in the input image pixel coordinate system.</span>
<span class="sd">    This function is intended to be followed by the align_to_reference_image</span>
<span class="sd">    function, which applies the relative transformation encoded in the</span>
<span class="sd">    WCS to transform input images into the reference image pixel</span>
<span class="sd">    coordinate system.</span>

<span class="sd">    The primary registration method is intended to be by direct mapping</span>
<span class="sd">    of sources in the image frame to correlated sources in the reference</span>
<span class="sd">    frame. This method fails when there are no correlated sources in the</span>
<span class="sd">    field, or when the WCSs are very far off to begin with.  As a back-up</span>
<span class="sd">    method, the user can try correcting the WCS by the shifts indicated </span>
<span class="sd">    in the POFFSET and QOFFSET header keywords (option fallback=&#39;header&#39;), </span>
<span class="sd">    or by hand-selecting common points of reference in an IRAF display</span>
<span class="sd">    (option fallback=&#39;user&#39;).  By default, only the direct method is</span>
<span class="sd">    attempted, as it is expected that the relative WCS will generally be</span>
<span class="sd">    more correct than either indirect method.  If the user prefers not to</span>
<span class="sd">    attempt direct mapping at all, they may set method to either &#39;user&#39;</span>
<span class="sd">    or &#39;header&#39;.</span>

<span class="sd">    In order to use the direct mapping method, sources must have been</span>
<span class="sd">    detected in the frame and attached to the AstroData instance in an </span>
<span class="sd">    OBJCAT extension.  This can be accomplished via the detectSources</span>
<span class="sd">    primitive.  Running time is optimal, and sometimes the solution is </span>
<span class="sd">    more robust, when there are not too many sources in the OBJCAT.  Try</span>
<span class="sd">    running detectSources with threshold=20.  The solution may also be</span>
<span class="sd">    more robust if sub-optimal sources are rejected from the set of </span>
<span class="sd">    correlated sources (use option cull_sources=True).  This option may</span>
<span class="sd">    substantially increase the running time if there are many sources in</span>
<span class="sd">    the OBJCAT.</span>

<span class="sd">    It is expected that the relative difference between the WCSs of </span>
<span class="sd">    images to be combined should be quite small, so it may not be necessary</span>
<span class="sd">    to allow rotation and scaling degrees of freedom when fitting the image</span>
<span class="sd">    WCS to the reference WCS.  However, if it is desired, the options </span>
<span class="sd">    rotate and scale can be used to allow these degrees of freedom.  Note</span>
<span class="sd">    that these options refer to rotation/scaling of the WCS itself, not the</span>
<span class="sd">    images.  Significant rotation and scaling of the images themselves </span>
<span class="sd">    will generally already be encoded in the WCS, and will be corrected for</span>
<span class="sd">    when the images are aligned.</span>

<span class="sd">    The WCS keywords in the headers of the output images are updated</span>
<span class="sd">    to contain the optimal registration solution.</span>

<span class="sd">    Log messages will go to a &#39;main&#39; type logger object, if it exists.</span>
<span class="sd">    or a null logger (ie. no log file, no messages to screen) if it does </span>
<span class="sd">    not.</span>

<span class="sd">    :param input: images to register. Reference image is assumed to be</span>
<span class="sd">                  the first one in the list.  All images must have</span>
<span class="sd">                  only one SCI extension.</span>
<span class="sd">    :type input: AstroData objects, either a single instance or a list</span>

<span class="sd">    :param method: method to use to generate reference points. Options</span>
<span class="sd">                   are &#39;sources&#39; to directly map sources from the input image</span>
<span class="sd">                   to the reference image, &#39;user&#39; to select reference</span>
<span class="sd">                   points by cursor from an IRAF display, or &#39;header&#39; to</span>
<span class="sd">                   generate reference points from the POFFSET and QOFFSET</span>
<span class="sd">                   keywords in the image headers.</span>
<span class="sd">    :type method: string, either &#39;sources&#39;, &#39;user&#39;, or &#39;header&#39;</span>

<span class="sd">    :param fallback: back-up method for generating reference points.</span>
<span class="sd">                     if the primary method fails.  The &#39;sources&#39; option</span>
<span class="sd">                     cannot be used as the fallback.</span>
<span class="sd">    :type fallback: string, either &#39;user&#39; or &#39;header&#39;.  </span>

<span class="sd">    :param cull_sources: flag to indicate whether sub-optimal sources should</span>
<span class="sd">                   be rejected before attempting a direct mapping. If True,</span>
<span class="sd">                   sources that are saturated, not well-fit by a Gaussian,</span>
<span class="sd">                   too broad, or too elliptical will be eliminated from</span>
<span class="sd">                   the list of reference points.</span>
<span class="sd">    :type cull_sources: bool</span>
<span class="sd">    </span>
<span class="sd">    :param rotate: flag to indicate whether the input image WCSs should</span>
<span class="sd">                   be allowed to rotate with respect to the reference image</span>
<span class="sd">                   WCS</span>
<span class="sd">    :type rotate: bool</span>

<span class="sd">    :param scale: flag to indicate whether the input image WCSs should</span>
<span class="sd">                  be allowed to scale with respect to the reference image</span>
<span class="sd">                  WCS.  The same scale factor is applied to all dimensions.</span>
<span class="sd">    :type scale: bool</span>

<span class="sd">    :param output_names: filenames of output images</span>
<span class="sd">    :type output_names: string, either a single instance or a list of strings</span>
<span class="sd">                    of the same length as input.</span>

<span class="sd">    :param suffix: string to add on the end of the input filenames to </span>
<span class="sd">                   generate output filenames</span>
<span class="sd">    :type suffix: string</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="c"># Instantiate ScienceFunctionManager object</span>
    <span class="n">sfm</span> <span class="o">=</span> <span class="n">man</span><span class="o">.</span><span class="n">ScienceFunctionManager</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">output_names</span><span class="p">,</span> <span class="n">suffix</span><span class="p">,</span>
                                     <span class="n">funcName</span><span class="o">=</span><span class="s">&#39;correct_wcs_to_reference_image&#39;</span><span class="p">)</span>

    <span class="c"># Perform start up checks of the inputs, prep/check of outnames, and get log</span>
    <span class="nb">input</span><span class="p">,</span> <span class="n">output_names</span><span class="p">,</span> <span class="n">log</span> <span class="o">=</span> <span class="n">sfm</span><span class="o">.</span><span class="n">startUp</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ScienceError</span><span class="p">(</span><span class="s">&#39;At least two image must be provided.&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fallback</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;Both method and fallback are None; not &#39;</span> <span class="o">+</span>
                        <span class="s">&#39;attempting WCS correction.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">input</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">fallback</span>

    <span class="n">n_test</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ad</span> <span class="ow">in</span> <span class="nb">input</span><span class="p">:</span>

        <span class="c"># make sure all other images have one science extension</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ad</span><span class="p">[</span><span class="s">&#39;SCI&#39;</span><span class="p">])</span><span class="o">!=</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ScienceError</span><span class="p">(</span><span class="s">&#39;Input images must have only one SCI extension.&#39;</span><span class="p">)</span>

        <span class="c"># get number of objects from OBJCAT</span>
        <span class="n">num_cat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ad</span><span class="p">[</span><span class="s">&#39;OBJCAT&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">num_cat</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">n_obj</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">num_cat</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ScienceError</span><span class="p">(</span><span class="s">&#39;Input image must have only one OBJCAT &#39;</span> <span class="o">+</span>
                               <span class="s">&#39;extension.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_obj</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ad</span><span class="p">[</span><span class="s">&#39;OBJCAT&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

        <span class="n">n_test</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_obj</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">n_test</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">method</span><span class="o">==</span><span class="s">&#39;sources&#39;</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;No objects found in reference image.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fallback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;Only attempting indirect WCS alignment, &#39;</span> <span class="o">+</span>
                        <span class="s">&#39;via &#39;</span> <span class="o">+</span> <span class="n">fallback</span> <span class="o">+</span> <span class="s">&#39; mapping&#39;</span><span class="p">)</span>  
            <span class="n">method</span><span class="o">=</span><span class="n">fallback</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;WCS can only be corrected indirectly &#39;</span> <span class="o">+</span>
                        <span class="s">&#39;and fallback method is set to None.  Not &#39;</span> <span class="o">+</span>
                        <span class="s">&#39;attempting WCS correction.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">input</span>


    <span class="c"># reference image is 1st one supplied</span>
    <span class="c"># (won&#39;t be modified except for TLM stamp)</span>
    <span class="n">reference</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="nb">input</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="c"># output list.  will add reference in later.</span>
    <span class="n">adOuts</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c"># if no OBJCAT/no sources in reference image, or user choice,</span>
    <span class="c"># use indirect alignment for all images at once</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="s">&#39;header&#39;</span><span class="p">:</span>
        <span class="n">reg_ad</span> <span class="o">=</span> <span class="n">headerAlign</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="nb">input</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">output_names</span><span class="p">)</span>
        <span class="n">adOuts</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">reg_ad</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span><span class="o">==</span><span class="s">&#39;user&#39;</span><span class="p">:</span>
        <span class="n">reg_ad</span> <span class="o">=</span> <span class="n">userAlign</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="nb">input</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">output_names</span><span class="p">,</span> 
                           <span class="n">rotate</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
        <span class="n">adOuts</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">reg_ad</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span><span class="o">!=</span><span class="s">&#39;sources&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ScienceError</span><span class="p">(</span><span class="s">&#39;Did not recognize method&#39;</span> <span class="o">+</span> <span class="n">method</span><span class="p">)</span>

    <span class="c"># otherwise try to do direct alignment for each image by correlating</span>
    <span class="c"># sources in the reference and input images</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="p">)):</span>
            
            <span class="n">ad</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">n_test</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;No objects found in &#39;</span><span class="o">+</span> <span class="n">ad</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">fallback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;Only attempting indirect WCS alignment, &#39;</span> <span class="o">+</span>
                                <span class="s">&#39;via &#39;</span> <span class="o">+</span> <span class="n">fallback</span> <span class="o">+</span> <span class="s">&#39; mapping&#39;</span><span class="p">)</span>  
                    <span class="k">if</span> <span class="n">fallback</span><span class="o">==</span><span class="s">&#39;header&#39;</span><span class="p">:</span>
                        <span class="n">adOut</span> <span class="o">=</span> <span class="n">headerAlign</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">ad</span><span class="p">,</span> <span class="n">output_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="n">fallback</span><span class="o">==</span><span class="s">&#39;user&#39;</span><span class="p">:</span>
                        <span class="n">adOut</span> <span class="o">=</span> <span class="n">userAlign</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">ad</span><span class="p">,</span> <span class="n">output_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                          <span class="n">rotate</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">ScienceError</span><span class="p">(</span><span class="s">&#39;Did not recognize fallback method&#39;</span> <span class="o">+</span>
                                           <span class="n">fallback</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&#39;WCS can only be corrected via indirectly &#39;</span> <span class="o">+</span>
                              <span class="s">&#39;and fallback=None. Not attempting WCS &#39;</span> <span class="o">+</span>
                              <span class="s">&#39;correction for &#39;</span> <span class="o">+</span> <span class="n">ad</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
                    <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="s">&#39;Number of objects in image </span><span class="si">%s</span><span class="s">: </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">n_test</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        
                <span class="n">log</span><span class="o">.</span><span class="n">status</span><span class="p">(</span><span class="s">&#39;Cross-correlating sources in </span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span>
                           <span class="p">(</span><span class="n">reference</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">ad</span><span class="o">.</span><span class="n">filename</span><span class="p">))</span>
                <span class="n">obj_list</span> <span class="o">=</span> <span class="n">correlateSources</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">ad</span><span class="p">,</span> 
                                            <span class="n">cull_sources</span><span class="o">=</span><span class="n">cull_sources</span><span class="p">)</span>

                <span class="n">n_corr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">n_corr</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;No correlated sources found.&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">fallback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;Only attempting indirect WCS alignment, &#39;</span> <span class="o">+</span>
                                    <span class="s">&#39;via &#39;</span> <span class="o">+</span> <span class="n">fallback</span> <span class="o">+</span> <span class="s">&#39; mapping&#39;</span><span class="p">)</span>

                        <span class="k">if</span> <span class="n">fallback</span><span class="o">==</span><span class="s">&#39;header&#39;</span><span class="p">:</span>
                            <span class="n">adOut</span> <span class="o">=</span> <span class="n">headerAlign</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">ad</span><span class="p">,</span> <span class="n">output_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="k">elif</span> <span class="n">fallback</span><span class="o">==</span><span class="s">&#39;user&#39;</span><span class="p">:</span>
                            <span class="n">adOut</span> <span class="o">=</span> <span class="n">userAlign</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">ad</span><span class="p">,</span> <span class="n">output_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                              <span class="n">rotate</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">ScienceError</span><span class="p">(</span><span class="s">&#39;Did not recognize fallback &#39;</span> <span class="o">+</span>
                                               <span class="s">&#39;method&#39;</span> <span class="o">+</span> <span class="n">fallback</span><span class="p">)</span>
                                              
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&#39;WCS can only be corrected via indirectly &#39;</span> <span class="o">+</span>
                                  <span class="s">&#39;and fallback=None. Not attempting WCS &#39;</span> <span class="o">+</span>
                                  <span class="s">&#39;correction for &#39;</span> <span class="o">+</span> <span class="n">ad</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
                        <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="s">&#39;Number of correlated sources: </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">n_corr</span><span class="p">)</span>

                    <span class="c"># Check the fit geometry depending on the number of objects</span>
                    <span class="k">if</span> <span class="n">n_corr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;Too few objects.  Setting rotate=False, &#39;</span> <span class="o">+</span>
                                    <span class="s">&#39;scale=False&#39;</span><span class="p">)</span>
                        <span class="n">rotate</span><span class="o">=</span><span class="bp">False</span>
                        <span class="n">scale</span><span class="o">=</span><span class="bp">False</span>

                    <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">Sources used to align frames:&#39;</span><span class="p">)</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="s">&#39;  </span><span class="si">%7s</span><span class="s"> </span><span class="si">%7s</span><span class="s"> </span><span class="si">%7s</span><span class="s"> </span><span class="si">%7s</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> 
                                 <span class="p">(</span><span class="s">&#39; Ref. x&#39;</span><span class="p">,</span><span class="s">&#39;Ref. y&#39;</span><span class="p">,</span>
                                  <span class="s">&#39;Img. x&#39;</span><span class="p">,</span><span class="s">&#39;Img. y&#39;</span><span class="p">,</span>
                                  <span class="s">&#39;  &#39;</span><span class="o">+</span><span class="s">&#39;-&#39;</span><span class="o">*</span><span class="mi">31</span><span class="p">))</span>
                    <span class="n">output_obj</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">obj_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">obj_list</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">output_obj</span><span class="p">:</span>
                        <span class="n">obj_string</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;  </span><span class="si">%7.2f</span><span class="s"> </span><span class="si">%7.2f</span><span class="s"> </span><span class="si">%7.2f</span><span class="s"> </span><span class="si">%7.2f</span><span class="s">&#39;</span> <span class="o">%</span> 
                                      <span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">obj</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">obj</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">obj</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="n">obj_string</span><span class="p">)</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)</span>

                    <span class="n">adOut</span> <span class="o">=</span> <span class="n">alignWCS</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">ad</span><span class="p">,</span> <span class="p">[</span><span class="n">obj_list</span><span class="p">],</span> 
                                     <span class="p">[</span><span class="n">output_names</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">output_names</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span>
                                     <span class="n">rotate</span><span class="o">=</span><span class="n">rotate</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>

            <span class="n">adOuts</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">adOut</span><span class="p">)</span>

    <span class="n">reference</span><span class="o">.</span><span class="n">filename</span><span class="o">=</span><span class="n">output_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">adOuts</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">reference</span><span class="p">)</span>

    <span class="n">sfm</span><span class="o">.</span><span class="n">markHistory</span><span class="p">(</span><span class="n">adOutputs</span><span class="o">=</span><span class="n">adOuts</span><span class="p">,</span> <span class="n">historyMarkKey</span><span class="o">=</span><span class="s">&#39;IMCOADD&#39;</span><span class="p">)</span>
    <span class="n">log</span><span class="o">.</span><span class="n">status</span><span class="p">(</span><span class="s">&#39;**FINISHED** the correct_wcs_to_reference_image function&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">adOuts</span>


</div>
<div class="viewcode-block" id="align_to_reference_image"><a class="viewcode-back" href="../modules.html#registration_functions.align_to_reference_image">[docs]</a><span class="k">def</span> <span class="nf">align_to_reference_image</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">interpolator</span><span class="o">=</span><span class="s">&#39;linear&#39;</span><span class="p">,</span>
                             <span class="n">output_names</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s">&#39;_trn&#39;</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function applies the transformation encoded in the input images</span>
<span class="sd">    WCSs to align them with a reference image, in reference image pixel</span>
<span class="sd">    coordinates.  The reference image is taken to be the first image in</span>
<span class="sd">    the input list.</span>

<span class="sd">    By default, the transformation into the reference frame is done via</span>
<span class="sd">    interpolation.  The interpolator parameter specifies the interpolation </span>
<span class="sd">    method.  The options are nearest-neighbor, bilinear, or nth-order </span>
<span class="sd">    spline, with n = 2, 3, 4, or 5.  If interpolator is None, </span>
<span class="sd">    no interpolation is done: the input image is shifted by an integer</span>
<span class="sd">    number of pixels, such that the center of the frame matches up as</span>
<span class="sd">    well as possible.  The variance plane, if present, is transformed in</span>
<span class="sd">    the same way as the science data.  </span>

<span class="sd">    The data quality plane, if present, must be handled a little</span>
<span class="sd">    differently.  DQ flags are set bit-wise, such that each pixel is the </span>
<span class="sd">    sum of any of the following values: 0=good pixel,</span>
<span class="sd">    1=bad pixel (from bad pixel mask), 2=nonlinear, 4=saturated, etc.</span>
<span class="sd">    To transform the DQ plane without losing flag information, it is</span>
<span class="sd">    unpacked into separate masks, each of which is transformed in the same</span>
<span class="sd">    way as the science data.  A pixel is flagged if it had greater than</span>
<span class="sd">    1% influence from a bad pixel.  The transformed masks are then added</span>
<span class="sd">    back together to generate the transformed DQ plane.</span>

<span class="sd">    In order not to lose any data, the output image arrays (including the</span>
<span class="sd">    reference image&#39;s) are expanded with respect to the input image arrays.</span>
<span class="sd">    The science and variance data arrays are padded with zeros; the DQ</span>
<span class="sd">    plane is padded with ones.  </span>

<span class="sd">    The WCS keywords in the headers of the output images are updated</span>
<span class="sd">    to reflect the transformation.</span>

<span class="sd">    :param input: list of images to align.  First image is taken to be</span>
<span class="sd">                  the reference image.</span>
<span class="sd">    :type input: list of AstroData objects</span>

<span class="sd">    :param interpolator: type of interpolation desired</span>
<span class="sd">    :type interpolator: string, possible values are None, &#39;nearest&#39;, &#39;linear&#39;,</span>
<span class="sd">                        &#39;spline2&#39;, &#39;spline3&#39;, &#39;spline4&#39;, or &#39;spline5&#39;</span>

<span class="sd">    :param output_names: filenames of output images</span>
<span class="sd">    :type output_names: string, either a single instance or a list of strings</span>
<span class="sd">                        of the same length as input.</span>

<span class="sd">    :param suffix: string to add on the end of the input filenames to </span>
<span class="sd">                   generate output filenames</span>
<span class="sd">    :type suffix: string</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="c"># Instantiate ScienceFunctionManager object</span>
    <span class="n">sfm</span> <span class="o">=</span> <span class="n">man</span><span class="o">.</span><span class="n">ScienceFunctionManager</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">output_names</span><span class="p">,</span> <span class="n">suffix</span><span class="p">,</span>
                                     <span class="n">funcName</span><span class="o">=</span><span class="s">&#39;align_to_reference_image&#39;</span><span class="p">)</span>

    <span class="c"># Perform start up checks of the inputs, prep/check of outnames, and get log</span>
    <span class="nb">input</span><span class="p">,</span> <span class="n">output_names</span><span class="p">,</span> <span class="n">log</span> <span class="o">=</span> <span class="n">sfm</span><span class="o">.</span><span class="n">startUp</span><span class="p">()</span>


    <span class="c"># make sure all images have one science extension</span>
    <span class="k">for</span> <span class="n">ad</span> <span class="ow">in</span> <span class="nb">input</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ad</span><span class="p">[</span><span class="s">&#39;SCI&#39;</span><span class="p">])</span><span class="o">!=</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ScienceError</span><span class="p">(</span><span class="s">&#39;Input images must have only one SCI extension.&#39;</span><span class="p">)</span>

    <span class="c"># check for at least two input images (1st one is reference)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ScienceError</span><span class="p">(</span><span class="s">&#39;At least two input images must be supplied.&#39;</span><span class="p">)</span>

    <span class="c"># load ndimage package if there will be interpolation</span>
    <span class="k">if</span> <span class="n">interpolator</span><span class="o">==</span><span class="s">&quot;None&quot;</span><span class="p">:</span>
        <span class="n">interpolator</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">interpolator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">affine_transform</span>

    <span class="c"># get reference WCS</span>
    <span class="n">reference</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="nb">input</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">reference</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">output_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ref_wcs</span> <span class="o">=</span> <span class="n">pywcs</span><span class="o">.</span><span class="n">WCS</span><span class="p">(</span><span class="n">reference</span><span class="p">[</span><span class="s">&#39;SCI&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>
    <span class="n">ref_shape</span> <span class="o">=</span> <span class="n">reference</span><span class="p">[</span><span class="s">&#39;SCI&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">ref_corners</span> <span class="o">=</span> <span class="n">getCorners</span><span class="p">(</span><span class="n">ref_shape</span><span class="p">)</span>
    <span class="n">naxis</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_shape</span><span class="p">)</span>

    <span class="c"># first pass: get output image shape required to fit all data in output</span>
    <span class="c"># by transforming corner coordinates of images</span>
    <span class="n">all_corners</span> <span class="o">=</span> <span class="p">[</span><span class="n">ref_corners</span><span class="p">]</span>
    <span class="n">xy_img_corners</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">shifts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="p">)):</span>

        <span class="n">ad</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="n">img_wcs</span> <span class="o">=</span> <span class="n">pywcs</span><span class="o">.</span><span class="n">WCS</span><span class="p">(</span><span class="n">ad</span><span class="p">[</span><span class="s">&#39;SCI&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>

        <span class="n">img_shape</span> <span class="o">=</span> <span class="n">ad</span><span class="p">[</span><span class="s">&#39;SCI&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">img_corners</span> <span class="o">=</span> <span class="n">getCorners</span><span class="p">(</span><span class="n">img_shape</span><span class="p">)</span>

        <span class="n">xy_corners</span> <span class="o">=</span> <span class="p">[(</span><span class="n">corner</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">corner</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">corner</span> <span class="ow">in</span> <span class="n">img_corners</span><span class="p">]</span>
        <span class="n">xy_img_corners</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xy_corners</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">interpolator</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># find shift by transforming center position of field</span>
            <span class="c"># (so that center matches best)</span>
            <span class="n">x1y1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">img_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span><span class="n">img_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span><span class="p">])</span>
            <span class="n">x2y2</span> <span class="o">=</span> <span class="n">img_wcs</span><span class="o">.</span><span class="n">wcs_sky2pix</span><span class="p">(</span><span class="n">ref_wcs</span><span class="o">.</span><span class="n">wcs_pix2sky</span><span class="p">([</span><span class="n">x1y1</span><span class="p">],</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c"># round shift to nearest integer and flip x and y</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">x2y2</span><span class="o">-</span><span class="n">x1y1</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>

            <span class="c"># shift corners of image</span>
            <span class="n">img_corners</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">offset</span><span class="o">+</span><span class="n">corner</span><span class="p">)</span> 
                           <span class="k">for</span> <span class="n">corner</span> <span class="ow">in</span> <span class="n">img_corners</span><span class="p">]</span>
            <span class="n">shifts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># transform corners of image via WCS           </span>
            <span class="n">xy_corners</span> <span class="o">=</span> <span class="n">img_wcs</span><span class="o">.</span><span class="n">wcs_sky2pix</span><span class="p">(</span><span class="n">ref_wcs</span><span class="o">.</span><span class="n">wcs_pix2sky</span><span class="p">(</span>
                                               <span class="n">xy_corners</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">img_corners</span> <span class="o">=</span> <span class="p">[(</span><span class="n">corner</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">corner</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">corner</span> <span class="ow">in</span> <span class="n">xy_corners</span><span class="p">]</span>

        <span class="n">all_corners</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img_corners</span><span class="p">)</span>


    <span class="n">cenoff</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">out_shape</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">naxis</span><span class="p">):</span>
        <span class="c"># get output shape from corner values</span>
        <span class="n">cvals</span> <span class="o">=</span> <span class="p">[</span><span class="n">corner</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="n">all_corners</span> <span class="k">for</span> <span class="n">corner</span> <span class="ow">in</span> <span class="n">ic</span><span class="p">]</span>
        <span class="n">out_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">cvals</span><span class="p">)</span><span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="n">cvals</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

        <span class="c"># if just shifting, need to set centering shift for reference</span>
        <span class="c"># image from offsets already calculated</span>
        <span class="k">if</span> <span class="n">interpolator</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">svals</span> <span class="o">=</span> <span class="p">[</span><span class="n">shift</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="k">for</span> <span class="n">shift</span> <span class="ow">in</span> <span class="n">shifts</span><span class="p">]</span>
            <span class="c"># include a 0 shift for the reference image</span>
            <span class="c"># (in case it&#39;s already centered)</span>
            <span class="n">svals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
            <span class="n">cenoff</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">svals</span><span class="p">)))</span>

    <span class="n">out_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">out_shape</span><span class="p">)</span>

    <span class="c"># if not shifting, get offset required to center reference image</span>
    <span class="c"># from the size of the image</span>
    <span class="k">if</span> <span class="n">interpolator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">incen</span>  <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">axlen</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">axlen</span> <span class="ow">in</span> <span class="n">ref_shape</span><span class="p">]</span>
        <span class="n">outcen</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">axlen</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">axlen</span> <span class="ow">in</span> <span class="n">out_shape</span><span class="p">]</span>
        <span class="n">cenoff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">incen</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">outcen</span><span class="p">)</span>

    <span class="n">adOuts</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c"># shift the reference image to keep it in the center of the new array</span>
    <span class="c"># (do the same for VAR and DQ)</span>
    <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="s">&#39;Growing reference image to keep all data; &#39;</span> <span class="o">+</span>
                 <span class="s">&#39;centering data, and updating WCS to account for shift&#39;</span><span class="p">)</span>
    <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="s">&#39;New output shape: &#39;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">out_shape</span><span class="p">))</span>

    <span class="n">ref_corners</span> <span class="o">=</span> <span class="p">[(</span><span class="n">corner</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">cenoff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">corner</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">cenoff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c"># x,y</span>
                   <span class="k">for</span> <span class="n">corner</span> <span class="ow">in</span> <span class="n">ref_corners</span><span class="p">]</span>
    <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="s">&#39;Setting AREA keywords in header to denote original &#39;</span> <span class="o">+</span>
                 <span class="s">&#39;data area.&#39;</span><span class="p">)</span>
    <span class="n">area_keys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="s">&#39;AREATYPE = &quot;P4&quot;     / Polygon with 4 vertices&#39;</span><span class="p">)</span>
    <span class="n">area_keys</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s">&#39;AREATYPE&#39;</span><span class="p">,</span><span class="s">&#39;P4&#39;</span><span class="p">,</span><span class="s">&#39;Polygon with 4 vertices&#39;</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ref_corners</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ref_corners</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
            <span class="n">key_name</span> <span class="o">=</span> <span class="s">&#39;AREA</span><span class="si">%i</span><span class="s">_</span><span class="si">%i</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">key_value</span> <span class="o">=</span> <span class="n">ref_corners</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">axis</span><span class="p">]</span>
            <span class="n">key_comment</span> <span class="o">=</span> <span class="s">&#39;Vertex </span><span class="si">%i</span><span class="s">, dimension </span><span class="si">%i</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">area_keys</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">key_name</span><span class="p">,</span><span class="n">key_value</span><span class="p">,</span><span class="n">key_comment</span><span class="p">))</span>
            <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%-8s</span><span class="s"> = </span><span class="si">%7.2f</span><span class="s">  / </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> 
                         <span class="p">(</span><span class="n">key_name</span><span class="p">,</span> <span class="n">key_value</span><span class="p">,</span><span class="n">key_comment</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="n">reference</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ext</span><span class="o">.</span><span class="n">extname</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;SCI&#39;</span><span class="p">,</span><span class="s">&#39;VAR&#39;</span><span class="p">,</span><span class="s">&#39;DQ&#39;</span><span class="p">]:</span>
            <span class="k">continue</span>

        <span class="n">ref_data</span> <span class="o">=</span> <span class="n">ext</span><span class="o">.</span><span class="n">data</span>

        <span class="n">trans_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">out_shape</span><span class="p">)</span>

        <span class="c"># pad the DQ plane with 1 instead of 0</span>
        <span class="k">if</span> <span class="n">ext</span><span class="o">.</span><span class="n">extname</span><span class="p">()</span><span class="o">==</span><span class="s">&#39;DQ&#39;</span><span class="p">:</span>
            <span class="n">trans_data</span> <span class="o">+=</span> <span class="mf">1.0</span>

        <span class="n">trans_data</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="n">cenoff</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span><span class="nb">int</span><span class="p">(</span><span class="n">ref_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">cenoff</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                   <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="n">cenoff</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span><span class="nb">int</span><span class="p">(</span><span class="n">ref_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">cenoff</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">ref_data</span>

        <span class="n">ext</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">trans_data</span>

        <span class="c"># update the WCS in the reference image to account for the shift</span>
        <span class="n">ext</span><span class="o">.</span><span class="n">setKeyValue</span><span class="p">(</span><span class="s">&#39;CRPIX1&#39;</span><span class="p">,</span> <span class="n">ref_wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">crpix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">cenoff</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ext</span><span class="o">.</span><span class="n">setKeyValue</span><span class="p">(</span><span class="s">&#39;CRPIX2&#39;</span><span class="p">,</span> <span class="n">ref_wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">crpix</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">cenoff</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c"># set area keywords</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">area_keys</span><span class="p">:</span>
            <span class="n">ext</span><span class="o">.</span><span class="n">setKeyValue</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">key</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>


    <span class="c"># update the WCS in the PHU as well</span>
    <span class="n">reference</span><span class="o">.</span><span class="n">phuSetKeyValue</span><span class="p">(</span><span class="s">&#39;CRPIX1&#39;</span><span class="p">,</span> <span class="n">ref_wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">crpix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">cenoff</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">reference</span><span class="o">.</span><span class="n">phuSetKeyValue</span><span class="p">(</span><span class="s">&#39;CRPIX2&#39;</span><span class="p">,</span> <span class="n">ref_wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">crpix</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">cenoff</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">out_wcs</span> <span class="o">=</span> <span class="n">pywcs</span><span class="o">.</span><span class="n">WCS</span><span class="p">(</span><span class="n">reference</span><span class="p">[</span><span class="s">&#39;SCI&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>

    <span class="n">adOuts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span>


    <span class="c"># now transform the data</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="p">)):</span>

        <span class="n">log</span><span class="o">.</span><span class="n">status</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">Starting alignment for &#39;</span><span class="o">+</span> <span class="nb">input</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>

        <span class="n">ad</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="nb">input</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">ad</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">output_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="n">sciext</span> <span class="o">=</span> <span class="n">ad</span><span class="p">[</span><span class="s">&#39;SCI&#39;</span><span class="p">]</span>
        <span class="n">img_wcs</span> <span class="o">=</span> <span class="n">pywcs</span><span class="o">.</span><span class="n">WCS</span><span class="p">(</span><span class="n">sciext</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>
        <span class="n">img_shape</span> <span class="o">=</span> <span class="n">sciext</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">if</span> <span class="n">interpolator</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>

            <span class="c"># recalculate shift from new reference wcs</span>
            <span class="n">x1y1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">img_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span><span class="n">img_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span><span class="p">])</span>
            <span class="n">x2y2</span> <span class="o">=</span> <span class="n">img_wcs</span><span class="o">.</span><span class="n">wcs_sky2pix</span><span class="p">(</span><span class="n">out_wcs</span><span class="o">.</span><span class="n">wcs_pix2sky</span><span class="p">([</span><span class="n">x1y1</span><span class="p">],</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="n">shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">x2y2</span><span class="o">-</span><span class="n">x1y1</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">shift</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">):</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;Shift was calculated to be &gt;0; interpolator=None &#39;</span><span class="o">+</span>
                            <span class="s">&#39;may not be appropriate for this data.&#39;</span><span class="p">)</span>
                <span class="n">shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">shift</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">shift</span><span class="p">)</span>

            <span class="c"># update PHU WCS keywords</span>
            <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="s">&#39;Offsets: &#39;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">shift</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span>
            <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="s">&#39;Updating WCS to track shift in data&#39;</span><span class="p">)</span>
            <span class="n">ad</span><span class="o">.</span><span class="n">phuSetKeyValue</span><span class="p">(</span><span class="s">&#39;CRPIX1&#39;</span><span class="p">,</span> <span class="n">img_wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">crpix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">shift</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">ad</span><span class="o">.</span><span class="n">phuSetKeyValue</span><span class="p">(</span><span class="s">&#39;CRPIX2&#39;</span><span class="p">,</span> <span class="n">img_wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">crpix</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">shift</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c"># get transformation matrix from composite of wcs&#39;s</span>
            <span class="c"># matrix = in_sky2pix*out_pix2sky (converts output to input)</span>
            <span class="n">xy_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">img_wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">cd</span><span class="p">),</span><span class="n">out_wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">cd</span><span class="p">)</span>

            <span class="c"># switch x and y for compatibility with numpy ordering</span>
            <span class="n">flip_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">flip_xy</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">xy_matrix</span><span class="p">,</span><span class="n">flip_xy</span><span class="p">))</span>

            <span class="c"># offsets: shift origin of transformation to the reference pixel</span>
            <span class="c"># by subtracting the transformation of the output reference</span>
            <span class="c"># pixel and adding the input reference pixel back in</span>
            <span class="n">refcrpix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">out_wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">crpix</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">imgcrpix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">img_wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">crpix</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">imgcrpix</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span><span class="n">refcrpix</span><span class="p">)</span>

            <span class="c"># then add in the shift of origin due to dithering offset.</span>
            <span class="c"># This is the transform of the reference CRPIX position,</span>
            <span class="c"># minus the original position</span>
            <span class="n">trans_crpix</span> <span class="o">=</span> <span class="n">img_wcs</span><span class="o">.</span><span class="n">wcs_sky2pix</span><span class="p">(</span><span class="n">out_wcs</span><span class="o">.</span><span class="n">wcs_pix2sky</span><span class="p">(</span>
                                                <span class="p">[</span><span class="n">out_wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">crpix</span><span class="p">],</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">trans_crpix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">trans_crpix</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">trans_crpix</span><span class="o">-</span><span class="n">imgcrpix</span>

            <span class="c"># Since the transformation really is into the reference</span>
            <span class="c"># WCS coordinate system as near as possible, just set image</span>
            <span class="c"># WCS equal to reference WCS</span>
            <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="s">&#39;Offsets: &#39;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span>
            <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="s">&#39;Transformation matrix:</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">matrix</span><span class="p">))</span>
            <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="s">&#39;Updating WCS to match reference WCS&#39;</span><span class="p">)</span>
            <span class="n">ad</span><span class="o">.</span><span class="n">phuSetKeyValue</span><span class="p">(</span><span class="s">&#39;CRPIX1&#39;</span><span class="p">,</span> <span class="n">out_wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">crpix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">ad</span><span class="o">.</span><span class="n">phuSetKeyValue</span><span class="p">(</span><span class="s">&#39;CRPIX2&#39;</span><span class="p">,</span> <span class="n">out_wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">crpix</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">ad</span><span class="o">.</span><span class="n">phuSetKeyValue</span><span class="p">(</span><span class="s">&#39;CRVAL1&#39;</span><span class="p">,</span> <span class="n">out_wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">crval</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">ad</span><span class="o">.</span><span class="n">phuSetKeyValue</span><span class="p">(</span><span class="s">&#39;CRVAL2&#39;</span><span class="p">,</span> <span class="n">out_wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">crval</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">ad</span><span class="o">.</span><span class="n">phuSetKeyValue</span><span class="p">(</span><span class="s">&#39;CD1_1&#39;</span><span class="p">,</span> <span class="n">out_wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">cd</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">ad</span><span class="o">.</span><span class="n">phuSetKeyValue</span><span class="p">(</span><span class="s">&#39;CD1_2&#39;</span><span class="p">,</span> <span class="n">out_wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">cd</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">ad</span><span class="o">.</span><span class="n">phuSetKeyValue</span><span class="p">(</span><span class="s">&#39;CD2_1&#39;</span><span class="p">,</span> <span class="n">out_wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">cd</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">ad</span><span class="o">.</span><span class="n">phuSetKeyValue</span><span class="p">(</span><span class="s">&#39;CD2_2&#39;</span><span class="p">,</span> <span class="n">out_wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">cd</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
            

        <span class="c"># transform corners to find new location of original data</span>
        <span class="n">data_corners</span> <span class="o">=</span> <span class="n">out_wcs</span><span class="o">.</span><span class="n">wcs_sky2pix</span><span class="p">(</span><span class="n">img_wcs</span><span class="o">.</span><span class="n">wcs_pix2sky</span><span class="p">(</span>
                                             <span class="n">xy_img_corners</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="mi">0</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="s">&#39;Setting AREA keywords in header to denote original &#39;</span> <span class="o">+</span>
                     <span class="s">&#39;data area.&#39;</span><span class="p">)</span>
        <span class="n">area_keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="s">&#39;AREATYPE = &quot;P4&quot;     / Polygon with 4 vertices&#39;</span><span class="p">)</span>
        <span class="n">area_keys</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s">&#39;AREATYPE&#39;</span><span class="p">,</span><span class="s">&#39;P4&#39;</span><span class="p">,</span><span class="s">&#39;Polygon with 4 vertices&#39;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_corners</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_corners</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                <span class="n">key_name</span> <span class="o">=</span> <span class="s">&#39;AREA</span><span class="si">%i</span><span class="s">_</span><span class="si">%i</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">key_value</span> <span class="o">=</span> <span class="n">data_corners</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">axis</span><span class="p">]</span>
                <span class="n">key_comment</span> <span class="o">=</span> <span class="s">&#39;Vertex </span><span class="si">%i</span><span class="s">, dimension </span><span class="si">%i</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">area_keys</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">key_name</span><span class="p">,</span><span class="n">key_value</span><span class="p">,</span><span class="n">key_comment</span><span class="p">))</span>
                <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%-8s</span><span class="s"> = </span><span class="si">%7.2f</span><span class="s">  / </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> 
                             <span class="p">(</span><span class="n">key_name</span><span class="p">,</span> <span class="n">key_value</span><span class="p">,</span><span class="n">key_comment</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="n">ad</span><span class="p">:</span>
            <span class="n">extname</span> <span class="o">=</span> <span class="n">ext</span><span class="o">.</span><span class="n">extname</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">extname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;SCI&#39;</span><span class="p">,</span><span class="s">&#39;VAR&#39;</span><span class="p">,</span><span class="s">&#39;DQ&#39;</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="n">log</span><span class="o">.</span><span class="n">status</span><span class="p">(</span><span class="s">&#39;Transforming &#39;</span><span class="o">+</span><span class="n">ad</span><span class="o">.</span><span class="n">filename</span><span class="o">+</span><span class="s">&#39;[&#39;</span><span class="o">+</span><span class="n">extname</span><span class="o">+</span><span class="s">&#39;]&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">extname</span><span class="o">==</span><span class="s">&#39;DQ&#39;</span><span class="p">:</span>
                <span class="n">is_dq</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">is_dq</span> <span class="o">=</span> <span class="bp">False</span>

            <span class="n">img_data</span> <span class="o">=</span> <span class="n">ext</span><span class="o">.</span><span class="n">data</span>


            <span class="k">if</span> <span class="n">interpolator</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c"># just shift the data by an integer number of pixels</span>
                <span class="c"># (useful for noisy data)</span>

                <span class="n">trans_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">out_shape</span><span class="p">)</span>

                <span class="c"># pad the DQ plane with 1 instead of 0</span>
                <span class="k">if</span> <span class="n">is_dq</span><span class="p">:</span>
                    <span class="n">trans_data</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="n">trans_data</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="n">shift</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span><span class="nb">int</span><span class="p">(</span><span class="n">img_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">shift</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                           <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="n">shift</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span><span class="nb">int</span><span class="p">(</span><span class="n">img_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">shift</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">img_data</span>


                <span class="c"># update the wcs to track the transformation</span>
                <span class="n">ext</span><span class="o">.</span><span class="n">setKeyValue</span><span class="p">(</span><span class="s">&#39;CRPIX1&#39;</span><span class="p">,</span> <span class="n">img_wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">crpix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">shift</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">ext</span><span class="o">.</span><span class="n">setKeyValue</span><span class="p">(</span><span class="s">&#39;CRPIX2&#39;</span><span class="p">,</span> <span class="n">img_wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">crpix</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">shift</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c"># use ndimage to interpolate values</span>

                <span class="c"># Interpolation method is determined by interpolator parameter</span>
                <span class="k">if</span> <span class="n">interpolator</span><span class="o">==</span><span class="s">&#39;nearest&#39;</span><span class="p">:</span>
                    <span class="n">order</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">elif</span> <span class="n">interpolator</span><span class="o">==</span><span class="s">&#39;linear&#39;</span><span class="p">:</span>
                    <span class="n">order</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">interpolator</span><span class="o">==</span><span class="s">&#39;spline2&#39;</span><span class="p">:</span>
                    <span class="n">order</span> <span class="o">=</span> <span class="mi">2</span>
                <span class="k">elif</span> <span class="n">interpolator</span><span class="o">==</span><span class="s">&#39;spline3&#39;</span><span class="p">:</span>
                    <span class="n">order</span> <span class="o">=</span> <span class="mi">3</span>
                <span class="k">elif</span> <span class="n">interpolator</span><span class="o">==</span><span class="s">&#39;spline4&#39;</span><span class="p">:</span>
                    <span class="n">order</span> <span class="o">=</span> <span class="mi">4</span>
                <span class="k">elif</span> <span class="n">interpolator</span><span class="o">==</span><span class="s">&#39;spline5&#39;</span><span class="p">:</span>
                    <span class="n">order</span> <span class="o">=</span> <span class="mi">5</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ScienceError</span><span class="p">(</span><span class="s">&#39;Interpolation method &#39;</span><span class="o">+</span><span class="n">interpolator</span><span class="o">+</span>
                                       <span class="s">&#39; not recognized.&#39;</span><span class="p">)</span>


                <span class="k">if</span> <span class="n">is_dq</span><span class="p">:</span>

                    <span class="c"># DQ flags are set bit-wise</span>
                    <span class="c"># bit 1: bad pixel (1)</span>
                    <span class="c"># bit 2: nonlinear (2)</span>
                    <span class="c"># bit 3: saturated (4)</span>
                    <span class="c"># A pixel can be 0 (good, no flags), or the sum of</span>
                    <span class="c"># any of the above flags (or any others I don&#39;t know about)</span>

                    <span class="c"># unpack the DQ data into separate masks</span>
                    <span class="n">unp</span> <span class="o">=</span> <span class="p">(</span><span class="n">img_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">img_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">8</span><span class="p">)</span>
                    <span class="n">unpack_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unpackbits</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">img_data</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">unp</span><span class="p">)</span>
                    
                    <span class="c"># transform each mask</span>
                    <span class="n">trans_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">out_shape</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">):</span>
                        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">unpack_data</span><span class="p">[:,:,</span><span class="n">j</span><span class="p">])</span>

                        <span class="c"># skip the transformation if there are no flags set</span>
                        <span class="c"># (but always do the bad pixel mask because it is </span>
                        <span class="c"># needed to mask the part of the array that was</span>
                        <span class="c"># padded out to match the reference image)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">and</span> <span class="n">j</span><span class="o">!=</span><span class="mi">7</span><span class="p">:</span>
                            <span class="c"># first bit is j=7 because unpack is backwards </span>
                            <span class="k">continue</span>

                        <span class="c"># if bad pix bit, pad with 1.  Otherwise, pad with 0</span>
                        <span class="k">if</span> <span class="n">j</span><span class="o">==</span><span class="mi">7</span><span class="p">:</span>
                            <span class="n">cval</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">cval</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">trans_mask</span> <span class="o">=</span> <span class="n">affine_transform</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span>
                                                      <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                                      <span class="n">output_shape</span><span class="o">=</span><span class="n">out_shape</span><span class="p">,</span>
                                                      <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">cval</span><span class="p">)</span>

                        <span class="c"># flag any pixels with &gt;1% influence from bad pixel</span>
                        <span class="n">trans_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">trans_mask</span><span class="p">)</span><span class="o">&gt;</span><span class="mf">0.01</span><span class="p">,</span>
                                              <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="mi">7</span><span class="o">-</span><span class="n">j</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>

                        <span class="c"># add the flags into the overall mask</span>
                        <span class="n">trans_data</span> <span class="o">+=</span> <span class="n">trans_mask</span>

                <span class="k">else</span><span class="p">:</span> 

                    <span class="c"># transform science and variance data in the same way</span>

                    <span class="n">cval</span> <span class="o">=</span> <span class="mf">0.0</span>
                    <span class="n">trans_data</span> <span class="o">=</span> <span class="n">affine_transform</span><span class="p">(</span><span class="n">img_data</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span>
                                                  <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                                  <span class="n">output_shape</span><span class="o">=</span><span class="n">out_shape</span><span class="p">,</span>
                                                  <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">cval</span><span class="p">)</span>

                    <span class="c"># if there was any scaling in the transformation, the</span>
                    <span class="c"># pixel size will have changed, and the output should be</span>
                    <span class="c"># scaled by the ratio of input pixel size to output pixel</span>
                    <span class="c"># size to conserve the total flux in a feature.  This </span>
                    <span class="c"># factor is the determinant of the transformation matrix.</span>
                    <span class="n">factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
                    
                    <span class="k">if</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">factor</span><span class="p">)</span><span class="o">&gt;</span><span class="mf">1e-6</span><span class="p">:</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="s">&#39;Multiplying by </span><span class="si">%f</span><span class="s"> to conserve flux&#39;</span> <span class="o">%</span>
                                     <span class="n">factor</span><span class="p">)</span>
                        <span class="n">trans_data</span> <span class="o">*=</span> <span class="n">factor</span>
        

                <span class="c"># update the wcs</span>
                <span class="n">ext</span><span class="o">.</span><span class="n">setKeyValue</span><span class="p">(</span><span class="s">&#39;CRPIX1&#39;</span><span class="p">,</span> <span class="n">out_wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">crpix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">ext</span><span class="o">.</span><span class="n">setKeyValue</span><span class="p">(</span><span class="s">&#39;CRPIX2&#39;</span><span class="p">,</span> <span class="n">out_wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">crpix</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">ext</span><span class="o">.</span><span class="n">setKeyValue</span><span class="p">(</span><span class="s">&#39;CRVAL1&#39;</span><span class="p">,</span> <span class="n">out_wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">crval</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">ext</span><span class="o">.</span><span class="n">setKeyValue</span><span class="p">(</span><span class="s">&#39;CRVAL2&#39;</span><span class="p">,</span> <span class="n">out_wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">crval</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">ext</span><span class="o">.</span><span class="n">setKeyValue</span><span class="p">(</span><span class="s">&#39;CD1_1&#39;</span><span class="p">,</span> <span class="n">out_wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">cd</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">ext</span><span class="o">.</span><span class="n">setKeyValue</span><span class="p">(</span><span class="s">&#39;CD1_2&#39;</span><span class="p">,</span> <span class="n">out_wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">cd</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">ext</span><span class="o">.</span><span class="n">setKeyValue</span><span class="p">(</span><span class="s">&#39;CD2_1&#39;</span><span class="p">,</span> <span class="n">out_wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">cd</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">ext</span><span class="o">.</span><span class="n">setKeyValue</span><span class="p">(</span><span class="s">&#39;CD2_2&#39;</span><span class="p">,</span> <span class="n">out_wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">cd</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
           
                <span class="c"># set area keywords</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">area_keys</span><span class="p">:</span>
                    <span class="n">ext</span><span class="o">.</span><span class="n">setKeyValue</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">key</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

            <span class="n">ext</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">trans_data</span>

        <span class="n">adOuts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ad</span><span class="p">)</span>

    <span class="n">sfm</span><span class="o">.</span><span class="n">markHistory</span><span class="p">(</span><span class="n">adOutputs</span><span class="o">=</span><span class="n">adOuts</span><span class="p">,</span> <span class="n">historyMarkKey</span><span class="o">=</span><span class="s">&#39;IMCOADD&#39;</span><span class="p">)</span>
    <span class="n">log</span><span class="o">.</span><span class="n">status</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">**FINISHED** the align_to_reference_image function&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">adOuts</span>



<span class="c"># below functions will go into a toolbox</span>
</div>
<div class="viewcode-block" id="GaussFit"><a class="viewcode-back" href="../modules.html#registration_functions.GaussFit">[docs]</a><span class="k">class</span> <span class="nc">GaussFit</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class provides access to a Gaussian model, intended</span>
<span class="sd">    to be fit to a small stamp of data, via a  minimization of the </span>
<span class="sd">    differences between the model and the data.</span>

<span class="sd">    Example usage:</span>
<span class="sd">    pars = (bg, peak, x_ctr, y_ctr, x_width, y_width, theta)</span>
<span class="sd">    gf = GaussFit(stamp_data)</span>
<span class="sd">    new_pars, success = scipy.optimize.leastsq(gf.calcDiff, pars,</span>
<span class="sd">                                               maxfev=1000)</span>
<span class="sd">                                               #maxfev=1000, warning=False)</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stamp_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This instantiates the fitting object.</span>
<span class="sd">        </span>
<span class="sd">        :param stamp_data: array containing image data, preferably the</span>
<span class="sd">                           source to fit plus a little padding</span>
<span class="sd">        :type stamp_data: NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stamp</span> <span class="o">=</span> <span class="n">stamp_data</span>

<div class="viewcode-block" id="GaussFit.modelGauss2D"><a class="viewcode-back" href="../modules.html#registration_functions.GaussFit.modelGauss2D">[docs]</a>    <span class="k">def</span> <span class="nf">modelGauss2D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pars</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns a Gaussian source in an image array the</span>
<span class="sd">        same shape as the stamp_data.  The Gaussian is determined by</span>
<span class="sd">        the parameters in pars.</span>
<span class="sd">        </span>
<span class="sd">        :param pars: Gaussian parameters in this order: background, peak,</span>
<span class="sd">                     x-center, y-center, x-width, y-width, position angle</span>
<span class="sd">                     (in degrees)</span>
<span class="sd">        :type pars: 7-element tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bg</span><span class="p">,</span> <span class="n">peak</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">wx</span><span class="p">,</span> <span class="n">wy</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">pars</span>
        
        <span class="n">model_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">:</span> <span class="n">bg</span> <span class="o">+</span> <span class="n">peak</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span> <span class="p">(((</span><span class="n">x</span><span class="o">-</span><span class="n">cx</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
                                                 <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">cy</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>
                                                <span class="o">/</span><span class="n">wx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                                               <span class="o">+</span><span class="p">(((</span><span class="n">x</span><span class="o">-</span><span class="n">cx</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
                                                  <span class="o">-</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">cy</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>
                                                 <span class="o">/</span><span class="n">wy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                                              <span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">gauss_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfunction</span><span class="p">(</span><span class="n">model_fn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stamp</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gauss_array</span>
</div>
<div class="viewcode-block" id="GaussFit.calcDiff"><a class="viewcode-back" href="../modules.html#registration_functions.GaussFit.calcDiff">[docs]</a>    <span class="k">def</span> <span class="nf">calcDiff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pars</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns an array of the differences between</span>
<span class="sd">        the model stamp and the data stamp.  It is intended to be fed</span>
<span class="sd">        to an optimization algorithm, such as scipy.optimize.leastsq.</span>

<span class="sd">        :param pars: Gaussian parameters in this order: background, peak,</span>
<span class="sd">                     x-center, y-center, x-width, y-width, position angle</span>
<span class="sd">                     (in degrees)</span>
<span class="sd">        :type pars: 7-element tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modelGauss2D</span><span class="p">(</span><span class="n">pars</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stamp</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">-</span> <span class="n">model</span>
        <span class="k">return</span> <span class="n">diff</span>

</div></div>
<div class="viewcode-block" id="cullSources"><a class="viewcode-back" href="../modules.html#registration_functions.cullSources">[docs]</a><span class="k">def</span> <span class="nf">cullSources</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">img_obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function takes a list of identified sources in an image, fits</span>
<span class="sd">    a Gaussian to each one, and rejects it from the list if it is not</span>
<span class="sd">    sufficiently star-like.  The criteria for good sources are that they</span>
<span class="sd">    must be fittable by a Gaussian, not be too near the edge of the frame,</span>
<span class="sd">    have a peak value below saturation (as defined in the header of</span>
<span class="sd">    the image), have ellipticity less than 0.25, and have FWHM less than</span>
<span class="sd">    2.4 arcsec.  The return value is a list of the objects that meet these</span>
<span class="sd">    criteria, with their positions updated to the fit center.</span>

<span class="sd">    :param ad: input image</span>
<span class="sd">    :type ad: AstroData instance</span>

<span class="sd">    :param img_obj: list of [x,y] positions for sources detected in the</span>
<span class="sd">                    input image</span>
<span class="sd">    :type img_obj: list</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">import</span> <span class="nn">scipy.optimize</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ad</span><span class="p">[</span><span class="s">&#39;SCI&#39;</span><span class="p">])</span><span class="o">!=</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ScienceError</span><span class="p">(</span><span class="s">&#39;Reference image must have only one SCI extension.&#39;</span><span class="p">)</span>

    <span class="n">img_data</span> <span class="o">=</span> <span class="n">ad</span><span class="p">[</span><span class="s">&#39;SCI&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>

    <span class="c"># first guess at background is mean of whole image</span>
    <span class="n">default_bg</span> <span class="o">=</span> <span class="n">img_data</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

    <span class="c"># first guess at fwhm is .8 arcsec</span>
    <span class="n">default_fwhm</span> <span class="o">=</span> <span class="o">.</span><span class="mi">8</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">pixel_scale</span><span class="p">())</span>

    <span class="c"># stamp is 2 times this size on a side</span>
    <span class="n">aperture</span> <span class="o">=</span> <span class="n">default_fwhm</span> 

    <span class="c"># for rejecting saturated sources</span>
    <span class="n">saturation</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">saturation_level</span><span class="p">()</span> 

    <span class="n">good_source</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">objx</span><span class="p">,</span><span class="n">objy</span> <span class="ow">in</span> <span class="n">img_obj</span><span class="p">:</span>

        <span class="c"># array coords start with 0</span>
        <span class="n">objx</span><span class="o">-=</span><span class="mi">1</span>
        <span class="n">objy</span><span class="o">-=</span><span class="mi">1</span>

        <span class="n">xlow</span><span class="p">,</span> <span class="n">xhigh</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">objx</span><span class="o">-</span><span class="n">aperture</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">objx</span><span class="o">+</span><span class="n">aperture</span><span class="p">)),</span> 
        <span class="n">ylow</span><span class="p">,</span> <span class="n">yhigh</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">objy</span><span class="o">-</span><span class="n">aperture</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">objy</span><span class="o">+</span><span class="n">aperture</span><span class="p">)),</span> 

        <span class="k">if</span> <span class="p">(</span><span class="n">xlow</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">xhigh</span><span class="o">&lt;</span><span class="n">img_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> 
            <span class="n">ylow</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">yhigh</span><span class="o">&lt;</span><span class="n">img_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">stamp_data</span> <span class="o">=</span> <span class="n">img_data</span><span class="p">[</span><span class="n">ylow</span><span class="p">:</span><span class="n">yhigh</span><span class="p">,</span><span class="n">xlow</span><span class="p">:</span><span class="n">xhigh</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># source is too near the edge, skip it</span>
            <span class="k">continue</span>

        <span class="c"># starting values for Gaussian fit</span>
        <span class="n">bg</span> <span class="o">=</span> <span class="n">default_bg</span>
        <span class="n">peak</span> <span class="o">=</span> <span class="n">stamp_data</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">x_ctr</span> <span class="o">=</span> <span class="p">(</span><span class="n">stamp_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
        <span class="n">y_ctr</span> <span class="o">=</span> <span class="p">(</span><span class="n">stamp_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
        <span class="n">x_width</span> <span class="o">=</span> <span class="n">default_fwhm</span>
        <span class="n">y_width</span> <span class="o">=</span> <span class="n">default_fwhm</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="k">if</span> <span class="n">peak</span> <span class="o">&gt;=</span> <span class="n">saturation</span><span class="p">:</span>
            <span class="c"># source is too bright, skip it</span>
            <span class="k">continue</span>

        <span class="n">pars</span> <span class="o">=</span> <span class="p">(</span><span class="n">bg</span><span class="p">,</span> <span class="n">peak</span><span class="p">,</span> <span class="n">x_ctr</span><span class="p">,</span> <span class="n">y_ctr</span><span class="p">,</span> <span class="n">x_width</span><span class="p">,</span> <span class="n">y_width</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
    
        <span class="c"># instantiate fit object</span>
        <span class="n">gf</span> <span class="o">=</span> <span class="n">GaussFit</span><span class="p">(</span><span class="n">stamp_data</span><span class="p">)</span>

        <span class="c"># least squares fit of model to data</span>
        <span class="n">new_pars</span><span class="p">,</span> <span class="n">success</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">leastsq</span><span class="p">(</span><span class="n">gf</span><span class="o">.</span><span class="n">calcDiff</span><span class="p">,</span> <span class="n">pars</span><span class="p">,</span>
                                                   <span class="n">maxfev</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">success</span><span class="o">&gt;=</span><span class="mi">4</span><span class="p">:</span>
            <span class="c"># fit failed, move on</span>
            <span class="k">continue</span>

        <span class="p">(</span><span class="n">bg</span><span class="p">,</span> <span class="n">peak</span><span class="p">,</span> <span class="n">x_ctr</span><span class="p">,</span> <span class="n">y_ctr</span><span class="p">,</span> <span class="n">x_width</span><span class="p">,</span> <span class="n">y_width</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span> <span class="o">=</span> <span class="n">new_pars</span>

        <span class="c"># convert fit parameters to FWHM, ellipticity</span>
        <span class="n">fwhmx</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="n">x_width</span><span class="p">)</span>
        <span class="n">fwhmy</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="n">y_width</span><span class="p">)</span>
        <span class="n">pa</span> <span class="o">=</span> <span class="p">(</span><span class="n">theta</span><span class="o">*</span><span class="p">(</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
        <span class="n">pa</span> <span class="o">=</span> <span class="n">pa</span><span class="o">%</span><span class="mi">360</span>
                
        <span class="k">if</span> <span class="n">fwhmy</span> <span class="o">&lt;</span> <span class="n">fwhmx</span><span class="p">:</span>
            <span class="n">ellip</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">fwhmy</span><span class="o">/</span><span class="n">fwhmx</span>
            <span class="n">fwhm</span> <span class="o">=</span> <span class="n">fwhmx</span>
        <span class="k">elif</span> <span class="n">fwhmx</span> <span class="o">&lt;</span> <span class="n">fwhmy</span><span class="p">:</span>
            <span class="n">ellip</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">fwhmx</span><span class="o">/</span><span class="n">fwhmy</span>                    
            <span class="n">pa</span> <span class="o">=</span> <span class="n">pa</span><span class="o">-</span><span class="mi">90</span> 
            <span class="n">fwhm</span> <span class="o">=</span> <span class="n">fwhmy</span>
        <span class="k">else</span><span class="p">:</span> <span class="c">#fwhmx == fwhmy</span>
            <span class="n">ellip</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">fwhm</span> <span class="o">=</span> <span class="n">fwhmx</span>

        <span class="k">if</span> <span class="n">ellip</span><span class="o">&gt;.</span><span class="mi">25</span><span class="p">:</span>
            <span class="c"># source not round enough, skip it</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">fwhm</span><span class="o">&gt;</span><span class="mi">3</span><span class="o">*</span><span class="n">default_fwhm</span><span class="p">:</span> <span class="c"># ie. 2.4 arcsec -- probably not due to seeing</span>
            <span class="c"># source not pointy enough, skip it</span>
            <span class="k">continue</span>

        <span class="c"># update the position from the fit center</span>
        <span class="n">newx</span> <span class="o">=</span> <span class="n">xlow</span> <span class="o">+</span> <span class="n">x_ctr</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">newy</span> <span class="o">=</span> <span class="n">ylow</span> <span class="o">+</span> <span class="n">y_ctr</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">good_source</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">newx</span><span class="p">,</span><span class="n">newy</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">good_source</span>

</div>
<div class="viewcode-block" id="correlateSources"><a class="viewcode-back" href="../modules.html#registration_functions.correlateSources">[docs]</a><span class="k">def</span> <span class="nf">correlateSources</span><span class="p">(</span><span class="n">ad1</span><span class="p">,</span> <span class="n">ad2</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">firstPass</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">cull_sources</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function takes sources from the OBJCAT extensions in two</span>
<span class="sd">    images and attempts to correlate them.  It returns a list of </span>
<span class="sd">    reference source positions and their correlated image source </span>
<span class="sd">    positions.</span>

<span class="sd">    :param ad1: reference image</span>
<span class="sd">    :type ad1: AstroData instance</span>

<span class="sd">    :param ad2: input image</span>
<span class="sd">    :type ad2: AstroData instance</span>

<span class="sd">    :param delta: maximum distance in pixels to allow a match. If</span>
<span class="sd">                  left as None, it will attempt to find an appropriate</span>
<span class="sd">                  number (recommended).</span>
<span class="sd">    :type delta: float</span>
<span class="sd">    </span>
<span class="sd">    :param firstPass: estimated maximum distance between correlated</span>
<span class="sd">                      sources.  This distance represents the expected</span>
<span class="sd">                      mismatch between the WCSs of the input images.</span>
<span class="sd">    :type firstPass: float</span>

<span class="sd">    :param cull_sources: flag to indicate whether to reject sources that</span>
<span class="sd">                   are insufficiently star-like.  If true, will fit</span>
<span class="sd">                   a Gaussian to each correlated source, and return</span>
<span class="sd">                   the fit center of good sources (rather than the raw</span>
<span class="sd">                   OBJCAT position).</span>
<span class="sd">    :type cull_sources: bool</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">log</span> <span class="o">=</span> <span class="n">gemLog</span><span class="o">.</span><span class="n">getGeminiLog</span><span class="p">()</span>

    <span class="c"># get data and WCS from image 1</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">ad1</span><span class="p">[</span><span class="s">&#39;OBJCAT&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">ad1</span><span class="p">[</span><span class="s">&#39;OBJCAT&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">)</span>
    <span class="n">wcs1</span> <span class="o">=</span> <span class="n">pywcs</span><span class="o">.</span><span class="n">WCS</span><span class="p">(</span><span class="n">ad1</span><span class="p">[</span><span class="s">&#39;SCI&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>

    <span class="c"># get data and WCS from image 2    </span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">ad2</span><span class="p">[</span><span class="s">&#39;OBJCAT&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
    <span class="n">y2</span> <span class="o">=</span> <span class="n">ad2</span><span class="p">[</span><span class="s">&#39;OBJCAT&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">)</span>
    <span class="n">wcs2</span> <span class="o">=</span> <span class="n">pywcs</span><span class="o">.</span><span class="n">WCS</span><span class="p">(</span><span class="n">ad2</span><span class="p">[</span><span class="s">&#39;SCI&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>

    <span class="c"># convert image 2 data to sky coordinates</span>
    <span class="n">ra2</span><span class="p">,</span> <span class="n">dec2</span> <span class="o">=</span> <span class="n">wcs2</span><span class="o">.</span><span class="n">wcs_pix2sky</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

    <span class="c"># convert image 2 sky data to image 1 pixel coordinates</span>
    <span class="n">conv_x2</span><span class="p">,</span> <span class="n">conv_y2</span> <span class="o">=</span> <span class="n">wcs1</span><span class="o">.</span><span class="n">wcs_sky2pix</span><span class="p">(</span><span class="n">ra2</span><span class="p">,</span><span class="n">dec2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    

    <span class="c"># find matches</span>
    <span class="n">ind1</span><span class="p">,</span><span class="n">ind2</span> <span class="o">=</span> <span class="n">match_cxy</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">conv_x2</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">conv_y2</span><span class="p">,</span>
                          <span class="n">delta</span><span class="o">=</span><span class="n">delta</span><span class="p">,</span> <span class="n">firstPass</span><span class="o">=</span><span class="n">firstPass</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind1</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">ind2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ScienceError</span><span class="p">(</span><span class="s">&#39;Mismatched arrays returned from match_cxy&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind1</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind2</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[[],[]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">obj_list</span> <span class="o">=</span> <span class="p">[</span><span class="nb">zip</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="n">ind1</span><span class="p">],</span> <span class="n">y1</span><span class="p">[</span><span class="n">ind1</span><span class="p">]),</span>
                    <span class="nb">zip</span><span class="p">(</span><span class="n">x2</span><span class="p">[</span><span class="n">ind2</span><span class="p">],</span> <span class="n">y2</span><span class="p">[</span><span class="n">ind2</span><span class="p">])]</span>

        <span class="k">if</span> <span class="n">cull_sources</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">status</span><span class="p">(</span><span class="s">&#39;Rejecting non-Gaussian sources&#39;</span><span class="p">)</span>
            <span class="n">obj_list_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cullSources</span><span class="p">(</span><span class="n">ad1</span><span class="p">,</span> <span class="n">obj_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">obj_list_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cullSources</span><span class="p">(</span><span class="n">ad2</span><span class="p">,</span> <span class="n">obj_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

            <span class="n">x1</span><span class="p">,</span><span class="n">y1</span> <span class="o">=</span> <span class="n">obj_list_1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">obj_list_1</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">x2</span><span class="p">,</span><span class="n">y2</span> <span class="o">=</span> <span class="n">obj_list_2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">obj_list_2</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>

            <span class="c"># re-match sources</span>
            <span class="n">ra2</span><span class="p">,</span> <span class="n">dec2</span> <span class="o">=</span> <span class="n">wcs2</span><span class="o">.</span><span class="n">wcs_pix2sky</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">conv_x2</span><span class="p">,</span> <span class="n">conv_y2</span> <span class="o">=</span> <span class="n">wcs1</span><span class="o">.</span><span class="n">wcs_sky2pix</span><span class="p">(</span><span class="n">ra2</span><span class="p">,</span><span class="n">dec2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">ind1</span><span class="p">,</span><span class="n">ind2</span> <span class="o">=</span> <span class="n">match_cxy</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">conv_x2</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">conv_y2</span><span class="p">,</span>
                                  <span class="n">delta</span><span class="o">=</span><span class="n">delta</span><span class="p">,</span> <span class="n">firstPass</span><span class="o">=</span><span class="n">firstPass</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind1</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">ind2</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">ScienceError</span><span class="p">(</span><span class="s">&#39;Mismatched arrays returned from match_cxy&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind1</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind2</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[[],[]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">obj_list</span> <span class="o">=</span> <span class="p">[</span><span class="nb">zip</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="n">ind1</span><span class="p">],</span> <span class="n">y1</span><span class="p">[</span><span class="n">ind1</span><span class="p">]),</span>
                            <span class="nb">zip</span><span class="p">(</span><span class="n">x2</span><span class="p">[</span><span class="n">ind2</span><span class="p">],</span> <span class="n">y2</span><span class="p">[</span><span class="n">ind2</span><span class="p">])]</span>

        <span class="k">return</span> <span class="n">obj_list</span>

</div>
<div class="viewcode-block" id="rotate"><a class="viewcode-back" href="../modules.html#registration_functions.rotate">[docs]</a><span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="n">degs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Little helper function to return a basic 2-D rotation matrix.</span>

<span class="sd">    :param degs: rotation amount, in degrees</span>
<span class="sd">    :type degs: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rads</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">degs</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rads</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">rads</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">c</span><span class="p">,</span><span class="o">-</span><span class="n">s</span><span class="p">],</span>
                     <span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">c</span><span class="p">]])</span></div>
<div class="viewcode-block" id="WCSTweak"><a class="viewcode-back" href="../modules.html#registration_functions.WCSTweak">[docs]</a><span class="k">class</span> <span class="nc">WCSTweak</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class allows slight tweaking of an image&#39;s WCS, to fit to a</span>
<span class="sd">    reference WCS, via a minimization of the differences between</span>
<span class="sd">    reference points in both images.</span>

<span class="sd">    Example usage:</span>
<span class="sd">    wcstweak = WCSTweak(inp_wcs, inp_xy, ref_radec)</span>
<span class="sd">    pars = [0,0]</span>
<span class="sd">    new_pars,success = scipy.optimize.leastsq(wcstweak.calcDiff, pars,</span>
<span class="sd">                                              warning=False, maxfev=1000)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wcs</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">rotate</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This instantiates the WCSTweak object.</span>
<span class="sd">        </span>
<span class="sd">        :param wcs: the input image WCS</span>
<span class="sd">        :type wcs: pywcs WCS object</span>

<span class="sd">        :param inp: input object position in input pixel frame</span>
<span class="sd">        :type inp: NumPy array of [x,y] positions</span>

<span class="sd">        :param ref: reference object positions in sky frame (RA/Dec)</span>
<span class="sd">        :type ref: NumPy array of [ra,dec] positions</span>

<span class="sd">        :param rotate: flag to indicate whether to allow rotation of</span>
<span class="sd">                       input WCS with respect to reference WCS</span>
<span class="sd">        :type rotate: bool</span>

<span class="sd">        :param scale: flag to indicate whether to allow scaling of</span>
<span class="sd">                      input WCS with respect to reference WCS</span>
<span class="sd">        :type scale: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="n">wcs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inp</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="c"># in input pixel frame</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">ref</span>           <span class="c"># in ra/dec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span> <span class="o">=</span> <span class="n">rotate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crval</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">crval</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cd</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">cd</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<div class="viewcode-block" id="WCSTweak.transformRef"><a class="viewcode-back" href="../modules.html#registration_functions.WCSTweak.transformRef">[docs]</a>    <span class="k">def</span> <span class="nf">transformRef</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pars</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function transforms reference RA/Dec into input pixel</span>
<span class="sd">        frame, via a WCS tweaked by parameters pars.</span>
<span class="sd">        </span>
<span class="sd">        :param pars: list of parameters to tweak WCS by. Number of </span>
<span class="sd">                     elements is determined by whether rotation/scaling</span>
<span class="sd">                     is allowed.  Order is [dRA, dDec, dTheta, dMag].</span>
<span class="sd">                     dTheta and dMag are optional.</span>
<span class="sd">        :type pars: list of 2, 3, or 4 elements.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">:</span>
            <span class="n">d_ra</span><span class="p">,</span> <span class="n">d_dec</span><span class="p">,</span> <span class="n">d_theta</span><span class="p">,</span> <span class="n">d_mag</span> <span class="o">=</span> <span class="n">pars</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">cd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">d_mag</span><span class="o">*</span><span class="n">rotate</span><span class="p">(</span><span class="n">d_theta</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">cd</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">:</span>
            <span class="n">d_ra</span><span class="p">,</span> <span class="n">d_dec</span><span class="p">,</span> <span class="n">d_theta</span> <span class="o">=</span> <span class="n">pars</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">cd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotate</span><span class="p">(</span><span class="n">d_theta</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">cd</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">:</span>
            <span class="n">d_ra</span><span class="p">,</span> <span class="n">d_dec</span><span class="p">,</span> <span class="n">d_mag</span> <span class="o">=</span> <span class="n">pars</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">cd</span> <span class="o">=</span> <span class="n">d_mag</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cd</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d_ra</span><span class="p">,</span> <span class="n">d_dec</span> <span class="o">=</span> <span class="n">pars</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">crval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crval</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">d_ra</span><span class="p">,</span> <span class="n">d_dec</span><span class="p">])</span><span class="o">/</span><span class="mf">3600.0</span>

        <span class="n">new_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">wcs_sky2pix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_ref</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="c"># calculate residual (called by scipy.optimize.leastsq)</span></div>
<div class="viewcode-block" id="WCSTweak.calcDiff"><a class="viewcode-back" href="../modules.html#registration_functions.WCSTweak.calcDiff">[docs]</a>    <span class="k">def</span> <span class="nf">calcDiff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pars</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns an array of the differences between the</span>
<span class="sd">        input sources and the reference sources in the input pixel frame.</span>
<span class="sd">        It is intended to be fed to an optimization algorithm, such as </span>
<span class="sd">        scipy.optimize.leastsq.</span>

<span class="sd">        :param pars: list of parameters to tweak WCS by. Number of </span>
<span class="sd">                     elements is determined by whether rotation/scaling</span>
<span class="sd">                     is allowed.  Order is [dRA, dDec, dTheta, dMag].</span>
<span class="sd">                     dTheta and dMag are optional.</span>
<span class="sd">        :type pars: list of 2, 3, or 4 elements.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformRef</span><span class="p">(</span><span class="n">pars</span><span class="p">)</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inp</span> <span class="o">-</span> <span class="n">new_ref</span>
        <span class="k">return</span> <span class="n">diff</span>

</div></div>
<div class="viewcode-block" id="alignWCS"><a class="viewcode-back" href="../modules.html#registration_functions.alignWCS">[docs]</a><span class="k">def</span> <span class="nf">alignWCS</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">objIns</span><span class="p">,</span> <span class="n">output_names</span><span class="p">,</span> <span class="n">rotate</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function fits an input image&#39;s WCS to a reference image&#39;s WCS</span>
<span class="sd">    by minimizing the difference in the input image frame between</span>
<span class="sd">    reference points present in both images.</span>

<span class="sd">    :param reference: reference image to register other images to. Must</span>
<span class="sd">                      have only one SCI extension.</span>
<span class="sd">    :type reference: AstroData object</span>
<span class="sd">    </span>
<span class="sd">    :param input: images to register to reference image.  Must have</span>
<span class="sd">                  only one SCI extension.</span>
<span class="sd">    :type input: AstroData objects, either a single instance or a list</span>

<span class="sd">    :param objIns: list of object lists, one for each input image</span>
<span class="sd">    :type objIns: list of output lists from correlateSources</span>

<span class="sd">    :param output_names: filenames of output images</span>
<span class="sd">    :type output_names: string, either a single instance or a list of strings</span>
<span class="sd">                    of the same length as input.</span>

<span class="sd">    :param rotate: flag to indicate whether the input image WCSs should</span>
<span class="sd">                   be allowed to rotate with respect to the reference image</span>
<span class="sd">                   WCS</span>
<span class="sd">    :type rotate: bool</span>

<span class="sd">    :param scale: flag to indicate whether the input image WCSs should</span>
<span class="sd">                  be allowed to scale with respect to the reference image</span>
<span class="sd">                  WCS.  The same scale factor is applied to all dimensions.</span>
<span class="sd">    :type scale: bool</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">log</span> <span class="o">=</span> <span class="n">gemLog</span><span class="o">.</span><span class="n">getGeminiLog</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
        <span class="nb">input</span> <span class="o">=</span> <span class="p">[</span><span class="nb">input</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">objIns</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
        <span class="n">objIns</span> <span class="o">=</span> <span class="p">[</span><span class="n">objIns</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_names</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
        <span class="n">output_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">output_names</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">objIns</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ScienceError</span><span class="p">(</span><span class="s">&#39;Argument objIns should have the same number of &#39;</span> <span class="o">+</span>
                           <span class="s">&#39;elements as input&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_names</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ScienceError</span><span class="p">(</span><span class="s">&#39;Argument output_names should have the same &#39;</span> <span class="o">+</span>
                           <span class="s">&#39;number of elements as input, plus 1&#39;</span><span class="p">)</span>

    <span class="kn">import</span> <span class="nn">scipy.optimize</span>

    <span class="n">adOuts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="p">)):</span>

        <span class="c"># copy input ad and rename</span>
        <span class="n">ad</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="nb">input</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">ad</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">output_names</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">log</span><span class="o">.</span><span class="n">status</span><span class="p">(</span><span class="s">&#39;Starting WCS adjustment for &#39;</span> <span class="o">+</span> <span class="n">ad</span><span class="o">.</span><span class="n">filename</span> <span class="p">)</span>

        <span class="n">ref_xy</span><span class="p">,</span> <span class="n">inp_xy</span> <span class="o">=</span> <span class="n">objIns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">ref_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ref_xy</span><span class="p">)</span>
        <span class="n">inp_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">inp_xy</span><span class="p">)</span>

        <span class="n">ref_wcs</span> <span class="o">=</span> <span class="n">pywcs</span><span class="o">.</span><span class="n">WCS</span><span class="p">(</span><span class="n">reference</span><span class="p">[</span><span class="s">&#39;SCI&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>
        <span class="n">inp_wcs</span> <span class="o">=</span> <span class="n">pywcs</span><span class="o">.</span><span class="n">WCS</span><span class="p">(</span><span class="n">ad</span><span class="p">[</span><span class="s">&#39;SCI&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>

        <span class="c"># convert the reference coordinates to RA/Dec</span>
        <span class="n">ref_radec</span> <span class="o">=</span> <span class="n">ref_wcs</span><span class="o">.</span><span class="n">wcs_pix2sky</span><span class="p">(</span><span class="n">ref_xy</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

        <span class="c"># instantiate the alignment object used to fit input</span>
        <span class="c"># WCS to reference WCS</span>
        <span class="n">wcstweak</span> <span class="o">=</span> <span class="n">WCSTweak</span><span class="p">(</span><span class="n">inp_wcs</span><span class="p">,</span> <span class="n">inp_xy</span><span class="p">,</span> <span class="n">ref_radec</span><span class="p">,</span> 
                            <span class="n">rotate</span><span class="o">=</span><span class="n">rotate</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>        
        
        <span class="c"># find optimum WCS shift and rotation with</span>
        <span class="c"># starting parameters: dRA, dDec = 0</span>
        <span class="c"># (and dTheta=0 if rotate=True, dMag=1 if scale=True)</span>

        <span class="n">update</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">rotate</span> <span class="ow">and</span> <span class="n">scale</span><span class="p">:</span>
            <span class="n">pars</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">rotate</span><span class="p">:</span>
            <span class="n">pars</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">scale</span><span class="p">:</span>
            <span class="n">pars</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pars</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">new_pars</span><span class="p">,</span><span class="n">success</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">leastsq</span><span class="p">(</span><span class="n">wcstweak</span><span class="o">.</span><span class="n">calcDiff</span><span class="p">,</span> <span class="n">pars</span><span class="p">,</span>
                                                   <span class="n">maxfev</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">success</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">:</span>
            <span class="n">update</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="n">rotate</span> <span class="ow">and</span> <span class="n">scale</span><span class="p">:</span>
                <span class="p">(</span><span class="n">dRA</span><span class="p">,</span> <span class="n">dDec</span><span class="p">,</span> <span class="n">dTheta</span><span class="p">,</span> <span class="n">dMag</span><span class="p">)</span> <span class="o">=</span> <span class="n">new_pars</span>
                <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="s">&#39;Best fit dRA, dDec, dTheta, dMag: &#39;</span> <span class="o">+</span>
                             <span class="s">&#39;</span><span class="si">%.5f</span><span class="s"> </span><span class="si">%.5f</span><span class="s"> </span><span class="si">%.5f</span><span class="s"> </span><span class="si">%.5f</span><span class="s">&#39;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">dRA</span><span class="p">,</span> <span class="n">dDec</span><span class="p">,</span> <span class="n">dTheta</span><span class="p">,</span> <span class="n">dMag</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">rotate</span><span class="p">:</span>
                <span class="p">(</span><span class="n">dRA</span><span class="p">,</span> <span class="n">dDec</span><span class="p">,</span> <span class="n">dTheta</span><span class="p">)</span> <span class="o">=</span> <span class="n">new_pars</span>
                <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="s">&#39;Best fit dRA, dDec, dTheta: </span><span class="si">%.5f</span><span class="s"> </span><span class="si">%.5f</span><span class="s"> </span><span class="si">%.5f</span><span class="s">&#39;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">dRA</span><span class="p">,</span> <span class="n">dDec</span><span class="p">,</span> <span class="n">dTheta</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">scale</span><span class="p">:</span>
                <span class="p">(</span><span class="n">dRA</span><span class="p">,</span> <span class="n">dDec</span><span class="p">,</span> <span class="n">dMag</span><span class="p">)</span> <span class="o">=</span> <span class="n">new_pars</span>
                <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="s">&#39;Best fit dRA, dDec, dMag: </span><span class="si">%.5f</span><span class="s"> </span><span class="si">%.5f</span><span class="s"> </span><span class="si">%.5f</span><span class="s">&#39;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">dRA</span><span class="p">,</span> <span class="n">dDec</span><span class="p">,</span> <span class="n">dMag</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="p">(</span><span class="n">dRA</span><span class="p">,</span> <span class="n">dDec</span><span class="p">)</span> <span class="o">=</span> <span class="n">new_pars</span>
                <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="s">&#39;Best fit dRA, dDec: </span><span class="si">%.5f</span><span class="s"> </span><span class="si">%.5f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dRA</span><span class="p">,</span> <span class="n">dDec</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;WCS alignment did not converge. Not updating WCS.&#39;</span><span class="p">)</span>

        <span class="c"># update WCS in ad</span>
        <span class="k">if</span> <span class="n">update</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">status</span><span class="p">(</span><span class="s">&#39;Updating WCS in header&#39;</span><span class="p">)</span>
            <span class="n">ad</span><span class="o">.</span><span class="n">phuSetKeyValue</span><span class="p">(</span><span class="s">&#39;CRVAL1&#39;</span><span class="p">,</span> <span class="n">wcstweak</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">crval</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">ad</span><span class="o">.</span><span class="n">phuSetKeyValue</span><span class="p">(</span><span class="s">&#39;CRVAL2&#39;</span><span class="p">,</span> <span class="n">wcstweak</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">crval</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">ad</span><span class="o">.</span><span class="n">phuSetKeyValue</span><span class="p">(</span><span class="s">&#39;CD1_1&#39;</span><span class="p">,</span> <span class="n">wcstweak</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">cd</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">ad</span><span class="o">.</span><span class="n">phuSetKeyValue</span><span class="p">(</span><span class="s">&#39;CD1_2&#39;</span><span class="p">,</span> <span class="n">wcstweak</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">cd</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">ad</span><span class="o">.</span><span class="n">phuSetKeyValue</span><span class="p">(</span><span class="s">&#39;CD2_1&#39;</span><span class="p">,</span> <span class="n">wcstweak</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">cd</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">ad</span><span class="o">.</span><span class="n">phuSetKeyValue</span><span class="p">(</span><span class="s">&#39;CD2_2&#39;</span><span class="p">,</span> <span class="n">wcstweak</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">cd</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
            
            <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="n">ad</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ext</span><span class="o">.</span><span class="n">extname</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;SCI&#39;</span><span class="p">,</span><span class="s">&#39;VAR&#39;</span><span class="p">,</span><span class="s">&#39;DQ&#39;</span><span class="p">]:</span>
                    <span class="n">ext</span><span class="o">.</span><span class="n">setKeyValue</span><span class="p">(</span><span class="s">&#39;CRVAL1&#39;</span><span class="p">,</span> <span class="n">wcstweak</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">crval</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">ext</span><span class="o">.</span><span class="n">setKeyValue</span><span class="p">(</span><span class="s">&#39;CRVAL2&#39;</span><span class="p">,</span> <span class="n">wcstweak</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">crval</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">ext</span><span class="o">.</span><span class="n">setKeyValue</span><span class="p">(</span><span class="s">&#39;CD1_1&#39;</span><span class="p">,</span> <span class="n">wcstweak</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">cd</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">ext</span><span class="o">.</span><span class="n">setKeyValue</span><span class="p">(</span><span class="s">&#39;CD1_2&#39;</span><span class="p">,</span> <span class="n">wcstweak</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">cd</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">ext</span><span class="o">.</span><span class="n">setKeyValue</span><span class="p">(</span><span class="s">&#39;CD2_1&#39;</span><span class="p">,</span> <span class="n">wcstweak</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">cd</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">ext</span><span class="o">.</span><span class="n">setKeyValue</span><span class="p">(</span><span class="s">&#39;CD2_2&#39;</span><span class="p">,</span> <span class="n">wcstweak</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">cd</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>


        <span class="n">adOuts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ad</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">adOuts</span>

</div>
<div class="viewcode-block" id="headerAlign"><a class="viewcode-back" href="../modules.html#registration_functions.headerAlign">[docs]</a><span class="k">def</span> <span class="nf">headerAlign</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">output_names</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function uses the POFFSET and QOFFSET header keywords</span>
<span class="sd">    to get reference points to use in correcting an input WCS to</span>
<span class="sd">    a reference WCS.  Positive POFFSET is assumed to mean higher x</span>
<span class="sd">    value, and positive QOFFSET is assumed to mean higher y value.</span>
<span class="sd">    This function only allows for relative shifts between the images;</span>
<span class="sd">    rotations and scales will not be handled properly</span>

<span class="sd">    :param reference: reference image to register other images to. Must</span>
<span class="sd">                      have only one SCI extension.</span>
<span class="sd">    :type reference: AstroData object</span>
<span class="sd">    </span>
<span class="sd">    :param input: images to register to reference image.  Must have</span>
<span class="sd">                  only one SCI extension.</span>
<span class="sd">    :type input: AstroData objects, either a single instance or a list</span>

<span class="sd">    :param output_names: filenames of output images</span>
<span class="sd">    :type output_names: string, either a single instance or a list of strings</span>
<span class="sd">                    of the same length as input.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">log</span> <span class="o">=</span> <span class="n">gemLog</span><span class="o">.</span><span class="n">getGeminiLog</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
        <span class="nb">input</span> <span class="o">=</span> <span class="p">[</span><span class="nb">input</span><span class="p">]</span>
 
    <span class="c"># get starting offsets from reference image (first one given)</span>
    <span class="n">pixscale</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">reference</span><span class="o">.</span><span class="n">pixel_scale</span><span class="p">())</span>
    <span class="n">ref_xoff</span> <span class="o">=</span> <span class="n">reference</span><span class="o">.</span><span class="n">phuGetKeyValue</span><span class="p">(</span><span class="s">&#39;POFFSET&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">pixscale</span>
    <span class="n">ref_yoff</span> <span class="o">=</span> <span class="n">reference</span><span class="o">.</span><span class="n">phuGetKeyValue</span><span class="p">(</span><span class="s">&#39;QOFFSET&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">pixscale</span>

    <span class="c"># reference position is the center of the reference frame</span>
    <span class="n">data_shape</span> <span class="o">=</span> <span class="n">reference</span><span class="p">[</span><span class="s">&#39;SCI&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">ref_coord</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">data_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="s">&#39;Pixel scale: </span><span class="si">%.4f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">pixscale</span><span class="p">)</span>
    <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="s">&#39;Reference offsets: </span><span class="si">%.4f</span><span class="s"> </span><span class="si">%.4f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ref_xoff</span><span class="p">,</span> <span class="n">ref_yoff</span><span class="p">))</span>
    <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="s">&#39;Reference coordinates: </span><span class="si">%.1f</span><span class="s"> </span><span class="si">%.1f</span><span class="s">&#39;</span> <span class="o">%</span> 
                 <span class="p">(</span><span class="n">ref_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ref_coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="n">objIns</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="p">)):</span>
        <span class="n">ad</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">pixscale</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">pixel_scale</span><span class="p">())</span>
        <span class="n">xoff</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">phuGetKeyValue</span><span class="p">(</span><span class="s">&#39;POFFSET&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">pixscale</span>
        <span class="n">yoff</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">phuGetKeyValue</span><span class="p">(</span><span class="s">&#39;QOFFSET&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">pixscale</span>

        <span class="n">img_x</span> <span class="o">=</span> <span class="n">xoff</span><span class="o">-</span><span class="n">ref_xoff</span> <span class="o">+</span> <span class="n">ref_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">img_y</span> <span class="o">=</span> <span class="n">yoff</span><span class="o">-</span><span class="n">ref_yoff</span> <span class="o">+</span> <span class="n">ref_coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="s">&#39;For image &#39;</span> <span class="o">+</span> <span class="n">ad</span><span class="o">.</span><span class="n">filename</span> <span class="o">+</span> <span class="s">&#39;:&#39;</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="s">&#39;   Image offsets: </span><span class="si">%.4f</span><span class="s"> </span><span class="si">%.4f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">xoff</span><span class="p">,</span> <span class="n">yoff</span><span class="p">))</span>
        <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="s">&#39;   Coordinates to transform: </span><span class="si">%.4f</span><span class="s"> </span><span class="si">%.4f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">img_x</span><span class="p">,</span> <span class="n">img_y</span><span class="p">))</span>

        <span class="n">objIns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">ref_coord</span><span class="p">],[[</span><span class="n">img_x</span><span class="p">,</span><span class="n">img_y</span><span class="p">]]]))</span>

    <span class="n">adOuts</span> <span class="o">=</span> <span class="n">alignWCS</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">objIns</span><span class="p">,</span> <span class="n">output_names</span><span class="p">,</span> 
                       <span class="n">rotate</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">adOuts</span>

</div>
<div class="viewcode-block" id="userAlign"><a class="viewcode-back" href="../modules.html#registration_functions.userAlign">[docs]</a><span class="k">def</span> <span class="nf">userAlign</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">output_names</span><span class="p">,</span> <span class="n">rotate</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function takes user input to get reference points to use in </span>
<span class="sd">    correcting an input WCS to a reference WCS.  The images are </span>
<span class="sd">    displayed by IRAF and the common points selected by an image cursor.</span>
<span class="sd">    If rotation or scaling degrees of freedom are desired, two </span>
<span class="sd">    common points must be selected.  If only shifts are desired, one</span>
<span class="sd">    common point must be selected.</span>

<span class="sd">    :param reference: reference image to register other images to. Must</span>
<span class="sd">                      have only one SCI extension.</span>
<span class="sd">    :type reference: AstroData object</span>
<span class="sd">    </span>
<span class="sd">    :param input: images to register to reference image.  Must have</span>
<span class="sd">                  only one SCI extension.</span>
<span class="sd">    :type input: AstroData objects, either a single instance or a list</span>

<span class="sd">    :param output_names: filenames of output images</span>
<span class="sd">    :type output_names: string, either a single instance or a list of strings</span>
<span class="sd">                    of the same length as input.</span>
<span class="sd">    </span>
<span class="sd">    :param rotate: flag to indicate whether the input image WCSs should</span>
<span class="sd">                   be allowed to rotate with respect to the reference image</span>
<span class="sd">                   WCS</span>
<span class="sd">    :type rotate: bool</span>

<span class="sd">    :param scale: flag to indicate whether the input image WCSs should</span>
<span class="sd">                  be allowed to scale with respect to the reference image</span>
<span class="sd">                  WCS.  The same scale factor is applied to all dimensions.</span>
<span class="sd">    :type scale: bool</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">log</span> <span class="o">=</span> <span class="n">gemLog</span><span class="o">.</span><span class="n">getGeminiLog</span><span class="p">()</span>

    <span class="c"># load pyraf modules</span>
    <span class="kn">from</span> <span class="nn">astrodata.adutils.gemutil</span> <span class="kn">import</span> <span class="n">pyrafLoader</span>
    <span class="n">pyraf</span><span class="p">,</span> <span class="n">gemini</span><span class="p">,</span> <span class="n">yes</span><span class="p">,</span> <span class="n">no</span> <span class="o">=</span> <span class="n">pyrafLoader</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
        <span class="nb">input</span> <span class="o">=</span> <span class="p">[</span><span class="nb">input</span><span class="p">]</span>
 
    <span class="c"># start cl manager for iraf display</span>
    <span class="n">all_input</span> <span class="o">=</span> <span class="p">[</span><span class="n">reference</span><span class="p">]</span> <span class="o">+</span> <span class="nb">input</span>
    <span class="n">clm</span> <span class="o">=</span> <span class="n">man</span><span class="o">.</span><span class="n">CLManager</span><span class="p">(</span><span class="n">imageIns</span><span class="o">=</span><span class="n">all_input</span><span class="p">,</span> <span class="n">funcName</span><span class="o">=</span><span class="s">&#39;display&#39;</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">)</span>
    <span class="n">tmpfiles</span> <span class="o">=</span> <span class="n">clm</span><span class="o">.</span><span class="n">imageInsFiles</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;list&#39;</span><span class="p">)</span>

    <span class="c"># display the reference image</span>
    <span class="k">print</span> <span class="s">&quot; ==&gt; Reference image: &quot;</span> <span class="o">+</span> <span class="n">reference</span><span class="o">.</span><span class="n">filename</span>
    <span class="n">pyraf</span><span class="o">.</span><span class="n">iraf</span><span class="o">.</span><span class="n">display</span><span class="p">(</span><span class="n">tmpfiles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s">&#39;[SCI]&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">rotate</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">scale</span><span class="p">:</span>
        <span class="c"># only one object needed for pure shifts</span>
        <span class="k">print</span> <span class="s">&quot;Point to one common object in reference image&quot;</span>
        <span class="k">print</span> <span class="s">&quot;    strike any key&quot;</span>
        <span class="n">words</span> <span class="o">=</span> <span class="n">pyraf</span><span class="o">.</span><span class="n">iraf</span><span class="o">.</span><span class="n">cl</span><span class="o">.</span><span class="n">imcur</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">x11</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">y11</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ref_coord</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x11</span><span class="p">,</span><span class="n">y11</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># select two objects for rotation/scaling</span>
        <span class="k">print</span> <span class="s">&quot;Point to first common object in reference image&quot;</span>
        <span class="k">print</span> <span class="s">&quot;    strike any key&quot;</span>
        <span class="n">words</span> <span class="o">=</span> <span class="n">pyraf</span><span class="o">.</span><span class="n">iraf</span><span class="o">.</span><span class="n">cl</span><span class="o">.</span><span class="n">imcur</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">x11</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">y11</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">print</span> <span class="s">&quot;Point to second common object in reference image&quot;</span>
        <span class="k">print</span> <span class="s">&quot;    strike any key&quot;</span>
        <span class="n">words</span> <span class="o">=</span> <span class="n">pyraf</span><span class="o">.</span><span class="n">iraf</span><span class="o">.</span><span class="n">cl</span><span class="o">.</span><span class="n">imcur</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">x12</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">y12</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ref_coord</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x11</span><span class="p">,</span><span class="n">y11</span><span class="p">],[</span><span class="n">x12</span><span class="p">,</span><span class="n">y12</span><span class="p">]]</span>


    <span class="n">objIns</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="p">)):</span>
        <span class="n">ad</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">print</span> <span class="s">&quot; ==&gt; Image to be transformed:&quot;</span><span class="p">,</span> <span class="n">ad</span><span class="o">.</span><span class="n">filename</span>
        <span class="n">pyraf</span><span class="o">.</span><span class="n">iraf</span><span class="o">.</span><span class="n">display</span><span class="p">(</span><span class="n">tmpfiles</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="s">&#39;[SCI]&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">rotate</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">scale</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Point to one common object in image to be transformed&quot;</span>
            <span class="k">print</span> <span class="s">&quot;    coordinates for last image: </span><span class="si">%.1f</span><span class="s">, </span><span class="si">%.1f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">x11</span><span class="p">,</span> <span class="n">y11</span><span class="p">)</span>
            <span class="k">print</span> <span class="s">&quot;    strike any key&quot;</span>
            <span class="n">words</span> <span class="o">=</span> <span class="n">pyraf</span><span class="o">.</span><span class="n">iraf</span><span class="o">.</span><span class="n">cl</span><span class="o">.</span><span class="n">imcur</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="n">x21</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">y21</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">img_coord</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x21</span><span class="p">,</span> <span class="n">y21</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Point to first common object in image to be transformed&quot;</span>
            <span class="k">print</span> <span class="s">&quot;    coordinates for last image: </span><span class="si">%.1f</span><span class="s">, </span><span class="si">%.1f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">x11</span><span class="p">,</span> <span class="n">y11</span><span class="p">)</span>
            <span class="k">print</span> <span class="s">&quot;    strike any key&quot;</span>
            <span class="n">words</span> <span class="o">=</span> <span class="n">pyraf</span><span class="o">.</span><span class="n">iraf</span><span class="o">.</span><span class="n">cl</span><span class="o">.</span><span class="n">imcur</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="n">x21</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">y21</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">print</span> <span class="s">&quot;Point to second common object in image to be transformed&quot;</span>
            <span class="k">print</span> <span class="s">&quot;    coordinates for last image: </span><span class="si">%.1f</span><span class="s">, </span><span class="si">%.1f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">x12</span><span class="p">,</span> <span class="n">y12</span><span class="p">)</span>
            <span class="k">print</span> <span class="s">&quot;    strike any key&quot;</span>
            <span class="n">words</span> <span class="o">=</span> <span class="n">pyraf</span><span class="o">.</span><span class="n">iraf</span><span class="o">.</span><span class="n">cl</span><span class="o">.</span><span class="n">imcur</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="n">x22</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">y22</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">img_coord</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x21</span><span class="p">,</span> <span class="n">y21</span><span class="p">],[</span><span class="n">x22</span><span class="p">,</span><span class="n">y22</span><span class="p">]]</span>

        <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="s">&#39;Reference coordinates: &#39;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">ref_coord</span><span class="p">))</span>
        <span class="n">log</span><span class="o">.</span><span class="n">fullinfo</span><span class="p">(</span><span class="s">&#39;Coordinates to transform: &#39;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">img_coord</span><span class="p">))</span>
        <span class="n">objIns</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ref_coord</span><span class="p">,</span><span class="n">img_coord</span><span class="p">])</span>

    <span class="c"># delete temporary files</span>
    <span class="n">clm</span><span class="o">.</span><span class="n">finishCL</span><span class="p">()</span>


    <span class="n">adOuts</span> <span class="o">=</span> <span class="n">alignWCS</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">objIns</span><span class="p">,</span> <span class="n">output_names</span><span class="p">,</span> 
                      <span class="n">rotate</span><span class="o">=</span><span class="n">rotate</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">adOuts</span>

</div>
<div class="viewcode-block" id="getCorners"><a class="viewcode-back" href="../modules.html#registration_functions.getCorners">[docs]</a><span class="k">def</span> <span class="nf">getCorners</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a recursive function to calculate the corner indices </span>
<span class="sd">    of an array of the specified shape.</span>

<span class="sd">    :param shape: length of the dimensions of the array</span>
<span class="sd">    :type shape: tuple of ints, one for each dimension</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="nb">tuple</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;getCorners argument is non-tuple&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">corners</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,),</span> <span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">shape_less1</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)]</span>
        <span class="n">corners_less1</span> <span class="o">=</span> <span class="n">getCorners</span><span class="p">(</span><span class="n">shape_less1</span><span class="p">)</span>
        <span class="n">corners</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">corner</span> <span class="ow">in</span> <span class="n">corners_less1</span><span class="p">:</span>
            <span class="n">newcorner</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">+</span> <span class="n">corner</span>
            <span class="n">corners</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newcorner</span><span class="p">)</span>
            <span class="n">newcorner</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">corner</span>
            <span class="n">corners</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newcorner</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">corners</span>
</pre></div></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">imcoadd v0.1 documentation</a> &raquo;</li>
          <li><a href="index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, mk.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>